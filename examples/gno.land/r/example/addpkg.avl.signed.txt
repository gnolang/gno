{"msg":[{"@type":"/vm.m_addpkg","creator":"g17d0j59qka0d2vtp4l78w0c59uy34cwsdpfvk5l","pkg_path":"gno.land/p/avl","files":[{"Name":"avl.go","Body":"package avl\n\n// Tree\n\ntype Tree struct {\n\tkey       string\n\tvalue     interface{}\n\theight    int8\n\tsize      int\n\tleftTree  *Tree\n\trightTree *Tree\n}\n\nfunc NewTree(key string, value interface{}) *Tree {\n\treturn \u0026Tree{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\nfunc (tree *Tree) Size() int {\n\tif tree == nil {\n\t\treturn 0\n\t}\n\treturn tree.size\n}\n\nfunc (tree *Tree) Value() interface{} {\n\treturn tree.value\n}\n\nfunc (tree *Tree) _copy() *Tree {\n\tif tree.height == 0 {\n\t\tpanic(\"Why are you copying a value tree?\")\n\t}\n\treturn \u0026Tree{\n\t\tkey:       tree.key,\n\t\theight:    tree.height,\n\t\tsize:      tree.size,\n\t\tleftTree:  tree.leftTree,\n\t\trightTree: tree.rightTree,\n\t}\n}\n\nfunc (tree *Tree) Has(key string) (has bool) {\n\tif tree == nil {\n\t\treturn false\n\t}\n\tif tree.key == key {\n\t\treturn true\n\t}\n\tif tree.height == 0 {\n\t\treturn false\n\t} else {\n\t\tif key \u003c tree.key {\n\t\t\treturn tree.getLeftTree().Has(key)\n\t\t} else {\n\t\t\treturn tree.getRightTree().Has(key)\n\t\t}\n\t}\n}\n\nfunc (tree *Tree) Get(key string) (index int, value interface{}, exists bool) {\n\tif tree == nil {\n\t\treturn 0, nil, false\n\t}\n\tif tree.height == 0 {\n\t\tif tree.key == key {\n\t\t\treturn 0, tree.value, true\n\t\t} else if tree.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t} else {\n\t\t\treturn 0, nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c tree.key {\n\t\t\treturn tree.getLeftTree().Get(key)\n\t\t} else {\n\t\t\trightTree := tree.getRightTree()\n\t\t\tindex, value, exists = rightTree.Get(key)\n\t\t\tindex += tree.size - rightTree.size\n\t\t\treturn index, value, exists\n\t\t}\n\t}\n}\n\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\tif tree.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn tree.key, tree.value\n\t\t} else {\n\t\t\tpanic(\"GetByIndex asked for invalid index\")\n\t\t\treturn \"\", nil\n\t\t}\n\t} else {\n\t\t// TODO: could improve this by storing the sizes\n\t\tleftTree := tree.getLeftTree()\n\t\tif index \u003c leftTree.size {\n\t\t\treturn leftTree.GetByIndex(index)\n\t\t} else {\n\t\t\treturn tree.getRightTree().GetByIndex(index - leftTree.size)\n\t\t}\n\t}\n}\n\nfunc (tree *Tree) Set(key string, value interface{}) (newSelf *Tree, updated bool) {\n\tif tree == nil {\n\t\treturn NewTree(key, value), false\n\t}\n\tif tree.height == 0 {\n\t\tif key \u003c tree.key {\n\t\t\treturn \u0026Tree{\n\t\t\t\tkey:       tree.key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftTree:  NewTree(key, value),\n\t\t\t\trightTree: tree,\n\t\t\t}, false\n\t\t} else if key == tree.key {\n\t\t\treturn NewTree(key, value), true\n\t\t} else {\n\t\t\treturn \u0026Tree{\n\t\t\t\tkey:       key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftTree:  tree,\n\t\t\t\trightTree: NewTree(key, value),\n\t\t\t}, false\n\t\t}\n\t} else {\n\t\ttree = tree._copy()\n\t\tif key \u003c tree.key {\n\t\t\ttree.leftTree, updated = tree.getLeftTree().Set(key, value)\n\t\t} else {\n\t\t\ttree.rightTree, updated = tree.getRightTree().Set(key, value)\n\t\t}\n\t\tif updated {\n\t\t\treturn tree, updated\n\t\t} else {\n\t\t\ttree.calcHeightAndSize()\n\t\t\treturn tree.balance(), updated\n\t\t}\n\t}\n}\n\n// newTree: The new tree to replace tree after remove.\n// newKey: new leftmost leaf key for tree after successfully removing 'key' if changed.\n// value: removed value.\nfunc (tree *Tree) Remove(key string) (\n\tnewTree *Tree, newKey string, value interface{}, removed bool) {\n\tif tree == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif tree.height == 0 {\n\t\tif key == tree.key {\n\t\t\treturn nil, \"\", tree.value, true\n\t\t} else {\n\t\t\treturn tree, \"\", nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c tree.key {\n\t\t\tvar newLeftTree *Tree\n\t\t\tnewLeftTree, newKey, value, removed = tree.getLeftTree().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn tree, \"\", value, false\n\t\t\t} else if newLeftTree == nil { // left tree held value, was removed\n\t\t\t\treturn tree.rightTree, tree.key, value, true\n\t\t\t}\n\t\t\ttree = tree._copy()\n\t\t\ttree.leftTree = newLeftTree\n\t\t\ttree.calcHeightAndSize()\n\t\t\ttree = tree.balance()\n\t\t\treturn tree, newKey, value, true\n\t\t} else {\n\t\t\tvar newRightTree *Tree\n\t\t\tnewRightTree, newKey, value, removed = tree.getRightTree().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn tree, \"\", value, false\n\t\t\t} else if newRightTree == nil { // right tree held value, was removed\n\t\t\t\treturn tree.leftTree, \"\", value, true\n\t\t\t}\n\t\t\ttree = tree._copy()\n\t\t\ttree.rightTree = newRightTree\n\t\t\tif newKey != \"\" {\n\t\t\t\ttree.key = newKey\n\t\t\t}\n\t\t\ttree.calcHeightAndSize()\n\t\t\ttree = tree.balance()\n\t\t\treturn tree, \"\", value, true\n\t\t}\n\t}\n}\n\nfunc (tree *Tree) getLeftTree() *Tree {\n\treturn tree.leftTree\n}\n\nfunc (tree *Tree) getRightTree() *Tree {\n\treturn tree.rightTree\n}\n\n// NOTE: overwrites tree\n// TODO: optimize balance \u0026 rotate\nfunc (tree *Tree) rotateRight() *Tree {\n\ttree = tree._copy()\n\tl := tree.getLeftTree()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightTree\n\t_l.rightTree = tree\n\ttree.leftTree = _lrCached\n\n\ttree.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// NOTE: overwrites tree\n// TODO: optimize balance \u0026 rotate\nfunc (tree *Tree) rotateLeft() *Tree {\n\ttree = tree._copy()\n\tr := tree.getRightTree()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftTree\n\t_r.leftTree = tree\n\ttree.rightTree = _rlCached\n\n\ttree.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// NOTE: mutates height and size\nfunc (tree *Tree) calcHeightAndSize() {\n\ttree.height = maxInt8(tree.getLeftTree().height, tree.getRightTree().height) + 1\n\ttree.size = tree.getLeftTree().size + tree.getRightTree().size\n}\n\nfunc (tree *Tree) calcBalance() int {\n\treturn int(tree.getLeftTree().height) - int(tree.getRightTree().height)\n}\n\n// NOTE: assumes that tree can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (tree *Tree) balance() (newSelf *Tree) {\n\tbalance := tree.calcBalance()\n\tif balance \u003e 1 {\n\t\tif tree.getLeftTree().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn tree.rotateRight()\n\t\t} else {\n\t\t\t// Left Right Case\n\t\t\t// tree = tree._copy()\n\t\t\tleft := tree.getLeftTree()\n\t\t\ttree.leftTree = left.rotateLeft()\n\t\t\t//tree.calcHeightAndSize()\n\t\t\treturn tree.rotateRight()\n\t\t}\n\t}\n\tif balance \u003c -1 {\n\t\tif tree.getRightTree().calcBalance() \u003c= 0 {\n\t\t\t// Right Right Case\n\t\t\treturn tree.rotateLeft()\n\t\t} else {\n\t\t\t// Right Left Case\n\t\t\t// tree = tree._copy()\n\t\t\tright := tree.getRightTree()\n\t\t\ttree.rightTree = right.rotateRight()\n\t\t\t//tree.calcHeightAndSize()\n\t\t\treturn tree.rotateLeft()\n\t\t}\n\t}\n\t// Nothing changed\n\treturn tree\n}\n\n// traverse is a wrapper over traverseInRange when we want the whole tree\nfunc (tree *Tree) Traverse(ascending bool, cb func(*Tree) bool) bool {\n\treturn tree.TraverseInRange(\"\", \"\", ascending, cb)\n}\n\nfunc (tree *Tree) TraverseInRange(start, end string, ascending bool, cb func(*Tree) bool) bool {\n\tif tree == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c= tree.key)\n\tbeforeEnd := (end == \"\" || tree.key \u003c= end)\n\n\tstop := false\n\tif afterStart \u0026\u0026 beforeEnd {\n\t\t// IterateRange ignores this if not leaf\n\t\tstop = cb(tree)\n\t}\n\tif stop {\n\t\treturn stop\n\t}\n\n\tif tree.height \u003e 0 {\n\t\tif ascending {\n\t\t\t// check lower trees, then higher\n\t\t\tif afterStart {\n\t\t\t\tstop = tree.getLeftTree().TraverseInRange(start, end, ascending, cb)\n\t\t\t}\n\t\t\tif stop {\n\t\t\t\treturn stop\n\t\t\t}\n\t\t\tif beforeEnd {\n\t\t\t\tstop = tree.getRightTree().TraverseInRange(start, end, ascending, cb)\n\t\t\t}\n\t\t} else {\n\t\t\t// check the higher trees first\n\t\t\tif beforeEnd {\n\t\t\t\tstop = tree.getRightTree().TraverseInRange(start, end, ascending, cb)\n\t\t\t}\n\t\t\tif stop {\n\t\t\t\treturn stop\n\t\t\t}\n\t\t\tif afterStart {\n\t\t\t\tstop = tree.getLeftTree().TraverseInRange(start, end, ascending, cb)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// Only used in testing...\nfunc (tree *Tree) lmd() *Tree {\n\tif tree.height == 0 {\n\t\treturn tree\n\t}\n\treturn tree.getLeftTree().lmd()\n}\n\n// Only used in testing...\nfunc (tree *Tree) rmd() *Tree {\n\tif tree.height == 0 {\n\t\treturn tree\n\t}\n\treturn tree.getRightTree().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"}],"deposit":"100gnot"}],"fee":{"gas_wanted":"200000","gas_fee":"1gnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AwzdO9QHU6Hc4Dvtt1nDyIDhRNFvngqlP9mt4kVuvu21"},"signature":"2HQgKqnIFLT8fRFHKwuh83eKP//+GsIlW7AQ3AZZ0GdAyuSlcB79U/AFS7PGu/2M3GdgVrhadbHM4raMufMfCQ=="}],"memo":""}
