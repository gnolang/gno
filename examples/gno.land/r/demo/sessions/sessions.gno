// Package sessions implements an authenticator that allows a mother address to
// whitelist session addresses that can then act as the mother address using auth tokens.
package sessions

import (
	"errors"
	"std"
	"time"

	"gno.land/p/demo/auth"
	"gno.land/r/demo/authreg"
)

var (
	sessions map[string]map[string]*time.Time
	source   std.Realm
)

const NoExpiry = int64(0)

func init() {
	sessions = make(map[string]map[string]*time.Time)
	source = std.CurrentRealm()

	authreg.Register(Authenticate)
}

// Login creates a session allowing sessionAddr to act as the caller until we're past the expiry time.
// A nil expiry create a session with no expiration
func Login(sessionAddr std.Address, unixSecondsExpiry int64) {
	if !sessionAddr.IsValid() {
		panic(errors.New("invalid session address"))
	}

	caller := std.PrevRealm().Addr()
	if caller == sessionAddr {
		panic(errors.New("can't login as self"))
	}

	if unixSecondsExpiry < 0 {
		panic(errors.New("negative expiry"))
	}
	expiry := (*time.Time)(nil)
	if unixSecondsExpiry > 0 {
		timeExpiry := time.Unix(unixSecondsExpiry, 0)
		expiry = &timeExpiry
		if !expiry.After(time.Now()) {
			panic(errors.New("expiry is now or in the past"))
		}
	}

	callerStr := caller.String()
	if _, ok := sessions[callerStr]; !ok {
		sessions[callerStr] = make(map[string]*time.Time)
	}

	sessions[callerStr][sessionAddr.String()] = expiry
}

// Logout allows to delete sessions.
//
// The caller must be one of addr or sessionAddr.
// addr is the mother address.
// sessionAddr is the allowed address.
//
// If the caller is addr and a zero sessionAddr is passed, Logout will delete all sessions for addr
func Logout(addr std.Address, sessionAddr std.Address) {
	caller := std.PrevRealm().Addr()
	if caller != sessionAddr && caller != addr {
		panic(errors.New("caller must be addr or sessionAddr"))
	}

	addrSessions, ok := sessions[addr.String()]
	if !ok {
		panic(errors.New("addr has no sessions"))
	}

	// delete all sessions if requested
	if sessionAddr == std.Address("") {
		delete(sessions, addr.String())
		return
	}

	if _, ok := addrSessions[sessionAddr.String()]; !ok {
		panic(errors.New("sessionAddr is not a session of addr"))
	}
	// delete all sessions if it was the last one
	if len(addrSessions) == 1 {
		delete(sessions, addr.String())
		return
	}

	delete(addrSessions, sessionAddr.String())
}

// AuthToken constructs a session token.
// `as` is the mother address and the caller is the allowed address.
//
// It is not validated at creation.
// We need to validate at authentication anyway since prevalidated tokens could be stored and reused after the session is deleted or expired.
//
// A token is always considered valid if caller == as
func AuthToken(as std.Address) auth.Token {
	return &token{
		addr:        as,
		sessionAddr: std.PrevRealm().Addr(),
	}
}

// Authenticate validates a token generated by [AuthToken]. It panics if the session does not exists or is expired
func Authenticate(autok auth.Token) string {
	val, ok := autok.(*token)
	if !ok || val == nil {
		panic(auth.ErrInvalidToken)
	}

	addr := val.addr.String()
	sessionAddr := val.sessionAddr.String()

	if addr != sessionAddr {
		expiry, ok := sessions[addr][sessionAddr]
		if !ok {
			panic(auth.ErrInvalidToken)
		}
		if expiry != nil && !time.Now().Before(*expiry) {
			panic(auth.ErrInvalidToken)
		}
	}

	return "/" + addr
}

// EntityID returns the full entity ID for an address
func EntityID(addr std.Address) string {
	return "/" + source.Addr().String() + "/" + addr.String()
}

type token struct {
	addr        std.Address
	sessionAddr std.Address
}

func (t *token) Source() std.Realm {
	return source
}
