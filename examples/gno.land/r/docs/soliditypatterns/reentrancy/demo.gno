package reentrancy

import "std"

var (
    balances map[std.Address]std.Coins
    locked   bool
)

func init() {
    balances = make(map[std.Address]std.Coins)
}

func requireNonReentrant() {
    if locked {
        panic("ReentrancyGuard: reentrant call")
    }
    locked = true
}

func unlockReentrancy() {
    locked = false
}

func Deposit() {
    std.AssertOriginCall()
    caller := std.OriginCaller()
    amount := std.OriginSend()

    balances[caller] = balances[caller].Add(amount)
}

func Withdraw(amount std.Coins) {
    std.AssertOriginCall()
    requireNonReentrant()
    defer unlockReentrancy()

    caller := std.OriginCaller()

    newBalance := balances[caller].AmountOf("ugnot") - amount.AmountOf("ugnot")
    if newBalance < 0 {
        panic("Insufficient balance")
    }

    balances[caller].Add(std.NewCoins(std.NewCoin("ugnot", newBalance)))

    banker := std.NewBanker(std.BankerTypeRealmSend)
    banker.SendCoins(std.CurrentRealm().Address(), caller, amount)
}

func IsLocked() bool {
    return locked
}

func RenderDemo() string {
    content := "## Live Demo\n\n"
    content += "**Contract Status:** "
    if locked {
        content += "ðŸ”’ Locked (call in progress)\n\n"
    } else {
        content += "ðŸ”“ Unlocked\n\n"
    }

    content += "[Deposit 100ugnot](reentrancy$help&func=Deposit&send=100ugnot)\n\n"
    content += "[Withdraw 50ugnot](reentrancy$help&func=Withdraw&args=50ugnot)\n\n"

    content += "**Security Note:** This contract uses reentrancy protection to prevent malicious recursive calls during withdrawals.\n\n"

    return content
}
