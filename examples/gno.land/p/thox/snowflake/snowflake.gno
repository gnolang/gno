// Package snowflake provides utility functions for generating unique identifiers
// (Snowflake IDs) based on a custom implementation inspired by the Snowflake algorithm (https://pkg.go.dev/github.com/godruoyi/go-snowflake#section-sourcefiles).
// The Snowflake IDs generated by this package ensure uniqueness and are suitable for
// distributed systems. The package offers a mechanism to convert these IDs
// to standard SnowflakeID format strings, making them compatible with systems
// requiring UUIDs.
// Add import "gno.land/p/demo/entropy" to use the entropy package. For of the pseudo-random number generator.
// TimestampLength is 42-bit.
// 42 it's the maximum value that can be returned "2^42", It's represent 139 years (2^42 secondes)
// SequenBits allows for 4096 unique IDs to be generated per millisecond.

package snowflake

import (
	"chain/runtime"
	"encoding/binary"
	"encoding/hex"
	"time"

	"gno.land/p/demo/entropy"
	"gno.land/p/nt/ufmt/v0"
)

const (
	TimestampBits uint8  = 42
	MachineIDBits uint64 = 10
	SequenceBits  uint64 = 12
	MaxSequence   uint16 = 1<<SequenceBits - 1
	MaxTimestamp  uint64 = 1<<TimestampBits - 1
	MaxMachineID  uint64 = 1<<MachineIDBits - 1

	machineIDMoveLength = SequenceBits
	timestampMoveLength = MachineIDBits + SequenceBits

	startTime uint64 = 1226354400000 // 10 Nov 2008 23:00:00 UTC in milliseconds (Snowflake epoch)
)

// SnowflakeID struct for generating unique Snowflake-based identifiers.
type SnowflakeID struct {
	machineID     uint64
	sequence      uint16
	startTime     uint64
	lastTimestamp uint64
	entropy       *entropy.Instance
}

func NewSnowflakeID() *SnowflakeID {
	s := &SnowflakeID{
		startTime: startTime,
		entropy:   entropy.New(),
	}
	s.SetMachineID()
	return s
}

// GenerateID generates a unique identifier based on the Snowflake algorithm.
// It combines the current timestamp, machine ID, and a sequence number to ensure uniqueness
// across distributed systems.
func (s *SnowflakeID) GenerateID() uint64 {
	current := s.getTimenow()

	if current == s.lastTimestamp {
		s.incrementSequence()
	} else {
		s.sequence = 0
		s.lastTimestamp = current
	}

	elapsedTime := uint64(current-s.startTime) % MaxTimestamp

	id := (uint64(elapsedTime) << timestampMoveLength) |
		(uint64(s.machineID) << machineIDMoveLength) |
		uint64(s.incrementSequence())
	return id
}

func (s *SnowflakeID) incrementSequence() uint16 {
	random := uint16(s.entropy.Value())
	s.sequence = (s.sequence + 1 + random) & MaxSequence
	return s.sequence
}

func (s *SnowflakeID) getTimenow() uint64 {
	return uint64(time.Now().UnixMilli())
}

// SetMachineID sets the machine ID based on the caller’s address.
func (s *SnowflakeID) SetMachineID() {
	caller := runtime.PreviousRealm().Address() // Retrieve the caller’s address
	machineID := uint64(0)
	for _, c := range caller.String() {
		machineID += uint64(c)
	}
	machineID %= MaxMachineID
	s.machineID = machineID
}

func SnowflakeIDToUUIDString(id uint64) string {
	bytes := make([]byte, 16)

	// Copy transformed ID into the second half of the array
	copy(bytes[8:], uint64ToBytes(id))

	// Use bits from the Snowflake ID to generate the first half of the SnowflakeID
	bytes[0] = byte(id >> 60)
	bytes[1] = byte(id >> 52)
	bytes[2] = byte(id >> 44)
	bytes[3] = byte(id >> 36)
	bytes[4] = byte(id >> 28)
	bytes[5] = byte(id >> 20)
	bytes[6] = byte(id >> 12)
	bytes[7] = byte(id >> 4)

	// set the version and variant bits according to SnowflakeID specification.
	bytes[6] = (bytes[6] & 0x0f) | 0x40 // version 4 (random)
	bytes[8] = (bytes[8] & 0x3f) | 0x80 // variant 1 (RFC 4122)

	hexStr := hex.EncodeToString(bytes)
	return ufmt.Sprintf("%s-%s-%s-%s-%s",
		hexStr[0:8],
		hexStr[8:12],
		hexStr[12:16],
		hexStr[16:20],
		hexStr[20:],
	)
}

func uint64ToBytes(i uint64) []byte {
	buf := make([]byte, 8)
	binary.BigEndian.PutUint64(buf, i)
	return buf
}
