package governor

import (
	"errors"
	"gno.land/p/demo/avl"
	stake "gno.land/p/demo/governance/stake"
	std "std"
)

var _ Tally = (*GovernorCountingBase)(nil)

// no, no with burn, no with veto, yes, can these be paramlized?
type VoteType int

// customizable vote type
const (
	Against VoteType = iota
	For
	Abstain
	NoWithVeto
)

func (vt VoteType) String() string {
	switch vt {
	case Against:
		return "against"
	case For:
		return "for"
	case Abstain:
		return "abstain"
	case NoWithVeto:
		return "veto"
	default:
		panic("no such VoteType")
	}
}

type TallyResult struct {
	tr map[VoteType]uint64 // vote type and counts
}

func NewTallyResult() *TallyResult {
	return &TallyResult{
		tr: make(map[VoteType]uint64),
	}
}
func (tr *TallyResult) GetVotes(vt VoteType) uint64 {
	return tr.tr[vt]
}

type VoteSet struct {
	votes map[string]VoteType // address => vote type
}

func NewVoteSet() *VoteSet {
	return &VoteSet{
		votes: make(map[string]VoteType),
	}
}

// who votes what
func (vs *VoteSet) setVote(account std.Address, vt VoteType) {
	vs.votes[account.String()] = vt
}

type GovernorCountingBase struct {
	proposalVotes *avl.Tree // proposalId => proposalVote
	gvqf          *GovernorVotesQuorumFraction
	gvvf          *GovernorVotesVetoFraction
	gvsf          *GovernorVotesSucceedFraction
	stake         *stake.Stake
}

func NewGovernorCountingBase(quorumNumerator uint64, vetoNumerator uint64, succeedNumerator uint64, token stake.GovToken, stake *stake.Stake) *GovernorCountingBase {
	return &GovernorCountingBase{
		proposalVotes: avl.NewTree(),
		gvqf:          NewGovernorVotesQuorumFraction(quorumNumerator, token),
		gvvf:          NewGovernorVotesVetoFraction(vetoNumerator),
		gvsf:          NewGovernorVotesSucceedFraction(succeedNumerator),
		stake:         stake,
	}
}

func (gcs *GovernorCountingBase) hasVoted(proposalId string, account std.Address) bool {
	vsI, found := gcs.proposalVotes.Get(proposalId)
	if !found {
		panic("GCS: proposal not exist")
	}
	voteSet := vsI.(*VoteSet)

	_, found = voteSet.votes[account.String()]
	if !found {
		return false
	}
	return true
}

// deduct vote from delegates and delegators who voting themselves,
// that counting independently from delegates' voting power
func (gcs *GovernorCountingBase) Tally(proposalId string) (*TallyResult, bool, error) {
	// TODO: or get from args?
	denom := gcs.stake.GetDenom()
	snapshot := std.GetHeight()

	// init voting power, to check quorum and veto
	var votingPower uint64 // total voting power, to determine if quorum or veto reached
	var result = NewTallyResult()

	// fetch all bonded delegates, convert from avl.Tree to a map
	// TODO: is this necessary?
	var delegates = make(map[string]*stake.Delegate)

	gcs.stake.IterateDelegates(func(n *avl.Node) bool {
		addr := n.Key()
		d := n.Value().(*stake.Delegate)
		delegates[addr] = d
		return false
	})

	// get all votes, and iterate to tally
	vsI, found := gcs.proposalVotes.Get(proposalId)
	if !found {
		return new(TallyResult), false, errors.New("no votes for proposal")
	}
	// addr => voteType: for, against...
	voteSet := vsI.(*VoteSet)

	// first, get all voter that is not delegate, votes from them should be deducted from it's counterpart, the delegate
	// delegate  still represents itself, means not votes doubled, so it's excluded thought it self-delegate
	// self-delegate won't not cause double vote when override
	for voter, vt := range voteSet.votes {
		if _, ok := delegates[voter]; ok { // filter out all delegate to get all independent vote, that is the delegator
			continue
		}
		// check delegation existence
		indexedDelegations, err := gcs.stake.GetDelegationByDelegator(voter)
		if err != nil {
			panic("no delegation exist, should not happen")
		}

		// deduct all overrided voting power
		// iterate delegate(at least one here, because delegator votes, that delegation exist) of voter => the delegator,
		// deduct all delegate
		var vp uint64
		// iterate all delegations from delegator, in denom
		indexedDelegations.IterateIndexedDelegation(func(index string, d *stake.Delegation) {
			shares := d.GetSnapshotDelegationShares(snapshot)
			// get snapshot shares of this delegation
			// TODO: or get from addr?
			delegate, ok := delegates[d.GetDelegate()]
			if !ok {
				panic("no delegate exist, should not happen")
			}
			// get shares
			delegate.TallyDeductionShares = shares // this would be deduct from delegatorShares when counter deletgate vp later
			// convert to voting power
			vp = delegate.Shares2VotingPower(snapshot, shares, denom)
			// voting power sums up
			votingPower += vp
			result.tr[vt] += vp // this assume an independant vote by all his voting power in one time, could it be splitted?
		})
	}

	// iterate delegats list, deduct overrided voting power by `TallyDeductionShares`, count results
	for voter, vt := range voteSet.votes {
		if d, ok := delegates[voter]; ok {
			// this would not push a substract to history, deduct here for this voting period
			remainedShares := d.GetSnapshotDelegatorShares(snapshot, denom) - d.TallyDeductionShares
			println("remained shares of voter is: ", voter, remainedShares)
			// println("remaind shares :", remainedShares)
			dvp := d.Shares2VotingPower(snapshot, remainedShares, denom)
			// println("dvp is: ", dvp)
			votingPower += dvp
			result.tr[vt] += dvp
		}
	}

	// now we have a voting power, and results
	println("voting power of all : ", votingPower)

	isBurnDeposit := gcs.isBurnDeposit(proposalId)
	// pass when super majority achieved
	return result, isBurnDeposit, nil
}

// check if quorum reached
func (gcs *GovernorCountingBase) quorumReached(totalVotingPower uint64) bool {
	return gcs.gvqf.quorum() <= totalVotingPower
}

// veto reached, 33.4
func (gcs *GovernorCountingBase) vetoReached(result *TallyResult) bool {
	votes := result.tr[For] + result.tr[Abstain] + result.tr[Against] + result.tr[NoWithVeto]
	vetoThreshold := votes * gcs.gvvf.getVetoNumerator() / gcs.gvvf.getVetoDenominator()
	return result.tr[NoWithVeto] >= vetoThreshold
}

// TODO: super majority required
func (gcs *GovernorCountingBase) voteSucceeded(result *TallyResult) bool {
	// get all votes count
	votes := result.tr[For] + result.tr[Abstain] + result.tr[Against] + result.tr[NoWithVeto]
	succeedThreshold := votes * gcs.gvsf.getSucceedNumerator() / gcs.gvsf.getSucceedDenominator()
	return result.tr[For] >= succeedThreshold
}

// this method counts who votes, in a map vote => voteType
// 1:1, voting power will be calculated in Tally process
func (gcs *GovernorCountingBase) AddVote(proposalId string, account std.Address, vt VoteType, memo string) error {
	var voteSet *VoteSet

	vsI, found := gcs.proposalVotes.Get(proposalId)
	if !found { // if vote not exist, means no one vote yet
		voteSet = NewVoteSet()
		voteSet.setVote(account, vt)
	} else { // has vote set for this proposal
		voteSet = vsI.(*VoteSet)
		_, exists := voteSet.votes[account.String()]
		// only vote when not voted before
		if !exists {
			// set vote state
			voteSet.setVote(account, vt)
		} else {
			return errors.New("GCS: You have voted for this before")
		}
	}
	// update
	gcs.proposalVotes.Set(proposalId, voteSet)
	return nil
}

// TODO: undetermined rules
func (gcs *GovernorCountingBase) isBurnDeposit(proposalId string) bool {
	return false
}
