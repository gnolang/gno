package grc20

import (
	"std"
)

//--------------------
// package myGnosisSafe
// var privateInstanceOfFoo20 = foo20.UserBank()
// privateInstanceOfFoo20.Transfer(to, 4242)
//--------------------

type relativeBank struct{}
func relativeBank.Transfer() {

}

// userToken implements the IGRC20 interface.
//
// It is generated by userBank.GRC20().
// It can safely be explosed publicly.
type userBank struct {
	IGRC20 // implements the GRC20 interface.

	admin *AdminUserBanker20
	user  std.Address // TODO: userBank is relative to the user
}

// IGRC20 implementation.
//

func (t *userBank) GetName() string     { return t.admin.name }
func (t *userBank) GetSymbol() string   { return t.admin.symbol }
func (t *userBank) GetDecimals() uint   { return t.admin.decimals }
func (t *userBank) TotalSupply() uint64 { return t.admin.totalSupply }

func (t *userBank) BalanceOf(owner std.Address) (uint64, error) {
	return t.admin.balanceOf(owner)
}

func (t *userBank) Transfer(to std.Address, amount uint64) error {
	owner := t.user
	if owner == nil {
		owner = std.PrevRealm()
	}
	return t.admin.transfer(owner, to, amount)
}

func (t *userBank) Allowance(owner, spender std.Address) (uint64, error) {
	return t.admin.allowance(owner, spender)
}

func (t *userBank) Approve(spender std.Address, amount uint64) error {
	owner := std.GetOrigCaller()
	return t.admin.approve(owner, spender, amount)
}

func (t *userBank) TransferFrom(from, to std.Address, amount uint64) error {
	spender := std.GetOrigCaller()
	if err := t.admin.spendAllowance(from, spender, amount); err != nil {
		return err
	}
	return t.admin.transfer(from, to, amount)
}
