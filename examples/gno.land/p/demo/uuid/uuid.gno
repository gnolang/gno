// Package uuid provides utility functions for generating unique identifiers
// (UUIDs) based on a custom implementation inspired by the Snowflake algorithm.
// The UUIDs generated by this package ensure uniqueness and are suitable for
// distributed systems. The package offers a mechanism to convert these IDs
// to standard UUID format strings, making them compatible with systems
// requiring UUIDs.

package uuid

import (
	"encoding/binary"
	"std"
	"strings"
	"time"

	"gno.land/p/demo/ufmt"
)

const (
	TimestampLength uint8  = 41
	MachineIDLength uint8  = 10
	SequenceLength  uint8  = 12
	MaxSequence     uint16 = 1<<SequenceLength - 1
	MaxTimestamp    uint64 = 1<<TimestampLength - 1
	MaxMachineID    uint64 = 1<<MachineIDLength - 1

	machineIDMoveLength = SequenceLength
	timestampMoveLength = MachineIDLength + SequenceLength
)

// UUID struct for generating unique identifiers.
type UUID struct {
	MachineID     uint64
	sequence      uint16
	StartTime     int64
	LastTimestamp int64
	counter       int64 // counter local for simulate the time because time.Now() is not available
}

func NewUUID() *UUID {
	u := &UUID{
		StartTime: time.Date(2008, 11, 10, 23, 0, 0, 0, time.UTC).Unix() * 1000,
		counter:   0,
	}
	u.SetMachineID()
	return u
}

// ID generates
func (u *UUID) ID() uint64 {
	current := u.incrementCounter()
	elapsedTime := current - u.StartTime
	u.LastTimestamp = current

	if uint64(elapsedTime) < MaxTimestamp {
		panic("Exceeding the time limit")
	}

	id := (uint64(elapsedTime) << uint64(timestampMoveLength)) |
		(uint64(u.MachineID) << uint64(machineIDMoveLength)) |
		uint64(u.incrementSequence())
	return id
}

func (u *UUID) incrementSequence() uint16 {
	u.sequence = (u.sequence + 1) & MaxSequence
	return u.sequence
}

func (u *UUID) incrementCounter() int64 {
	u.counter++
	if u.counter > int64(MaxTimestamp) {
		u.counter = 0
	}
	return u.counter
}

// SetMachineID sets the machine ID based on the caller’s address.
func (u *UUID) SetMachineID() {
	caller := std.PrevRealm().Addr() // Retrieve the caller’s address
	machineID := uint64(0)
	for _, c := range caller.String() {
		machineID += uint64(c)
	}
	machineID %= MaxMachineID
	u.MachineID = machineID
}

func IDToUUID(id uint64) string {
	bytes := make([]byte, 16)

	// Copy transformed ID into the second half of the array
	copy(bytes[8:], uint64ToBytes(id))

	// Use bits from the Snowflake ID to generate the first half of the UUID
	bytes[0] = byte(id >> 60)
	bytes[1] = byte(id >> 52)
	bytes[2] = byte(id >> 44)
	bytes[3] = byte(id >> 36)
	bytes[4] = byte(id >> 28)
	bytes[5] = byte(id >> 20)
	bytes[6] = byte(id >> 12)
	bytes[7] = byte(id >> 4)

	// set the version and variant bits according to UUID specification.
	bytes[6] = (bytes[6] & 0x0f) | 0x40 // version 4 (random)
	bytes[8] = (bytes[8] & 0x3f) | 0x80 // variant 1 (RFC 4122)

	return ufmt.Sprintf("%s-%s-%s-%s-%s",
		bytesToHex(bytes[0:4]),
		bytesToHex(bytes[4:6]),
		bytesToHex(bytes[6:8]),
		bytesToHex(bytes[8:10]),
		bytesToHex(bytes[10:16]))
}

func uint64ToBytes(i uint64) []byte {
	buf := make([]byte, 8)
	binary.BigEndian.PutUint64(buf, i)
	return buf
}

func bytesToHex(bs []byte) string {
	hexChars := "0123456789abcdef"

	sb := strings.Builder{}
	for _, b := range bs {
		sb.WriteByte(hexChars[b>>4])   // high 4 bits
		sb.WriteByte(hexChars[b&0x0f]) // low 4 bits
	}

	return sb.String()
}
