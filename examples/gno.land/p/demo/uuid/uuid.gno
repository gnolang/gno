// Package uuid provides utility functions for generating unique identifiers
// (UUIDs) based on a custom implementation inspired by the Snowflake algorithm (https://pkg.go.dev/github.com/godruoyi/go-snowflake#section-sourcefiles).
// The UUIDs generated by this package ensure uniqueness and are suitable for
// distributed systems. The package offers a mechanism to convert these IDs
// to standard UUID format strings, making them compatible with systems
// requiring UUIDs.
// Add import "gno.land/p/demo/entropy" to use the entropy package. For of the pseudo-random number generator.
// TimestampLength is 42-bit.
// 42 it's the maximum value that can be returned "2^42", It's represent 139 years (2^42 secondes)

package uuid

import (
	"encoding/binary"
	"encoding/hex"
	"std"

	"gno.land/p/demo/entropy"
	"gno.land/p/demo/ufmt"
)

const (
	TimestampBits uint8  = 42
	MachineIDBits uint64 = 10
	SequenceBits  uint64 = 12
	MaxSequence   uint16 = 1<<SequenceBits - 1
	MaxTimestamp  uint64 = 1<<TimestampBits - 1
	MaxMachineID  uint64 = 1<<MachineIDBits - 1

	machineIDMoveLength = SequenceBits
	timestampMoveLength = MachineIDBits + SequenceBits

	startTime uint32 = 1226354400 // 10 Nov 2008 23:00:00 UTC in seconds (Snowflake epoch)
)

// UUID struct for generating unique identifiers.
type UUID struct {
	machineID     uint64
	sequence      uint16
	startTime     uint32
	lastTimestamp uint32
	entropy       *entropy.Instance
}

func NewUUID() *UUID {
	u := &UUID{
		startTime: startTime,
		entropy:   entropy.New(),
	}
	u.SetMachineID()
	return u
}

// ID generates
func (u *UUID) ID() uint64 {
	current := u.getEntropy()
	elapsedTime := uint64(current - u.startTime)
	u.lastTimestamp = current

	if elapsedTime < 0 || elapsedTime > MaxTimestamp {
		panic("Exceeding the time limit")
	}

	id := (uint64(elapsedTime) << timestampMoveLength) |
		(uint64(u.machineID) << machineIDMoveLength) |
		uint64(u.incrementSequence())
	return id
}

func (u *UUID) incrementSequence() uint16 {
	u.sequence = (u.sequence + 1) & MaxSequence
	return u.sequence
}

func (u *UUID) getEntropy() uint32 {
	return u.entropy.Value()
}

// SetMachineID sets the machine ID based on the caller’s address.
func (u *UUID) SetMachineID() {
	caller := std.PrevRealm().Addr() // Retrieve the caller’s address
	machineID := uint64(0)
	for _, c := range caller.String() {
		machineID += uint64(c)
	}
	machineID %= MaxMachineID
	u.machineID = machineID
}

func UUIDIntToUUIDString(id uint64) string {
	bytes := make([]byte, 16)

	// Copy transformed ID into the second half of the array
	copy(bytes[8:], uint64ToBytes(id))

	// Use bits from the Snowflake ID to generate the first half of the UUID
	bytes[0] = byte(id >> 60)
	bytes[1] = byte(id >> 52)
	bytes[2] = byte(id >> 44)
	bytes[3] = byte(id >> 36)
	bytes[4] = byte(id >> 28)
	bytes[5] = byte(id >> 20)
	bytes[6] = byte(id >> 12)
	bytes[7] = byte(id >> 4)

	// set the version and variant bits according to UUID specification.
	bytes[6] = (bytes[6] & 0x0f) | 0x40 // version 4 (random)
	bytes[8] = (bytes[8] & 0x3f) | 0x80 // variant 1 (RFC 4122)

	hexStr := hex.EncodeToString(bytes)
	return ufmt.Sprintf("%s-%s-%s-%s-%s",
		hexStr[0:8],
		hexStr[8:12],
		hexStr[12:16],
		hexStr[16:20],
		hexStr[20:],
	)
}

func uint64ToBytes(i uint64) []byte {
	buf := make([]byte, 8)
	binary.BigEndian.PutUint64(buf, i)
	return buf
}
