package blog

import (
	"strconv"
	"time"

	"gno.land/p/demo/avl"
	"gno.land/p/demo/seqid"
	"gno.land/p/moul/md"
)

type Comment struct {
	id        seqid.ID
	author    string
	content   string
	createdAt time.Time
	editedAt  *time.Time // nil if unedited
	pinned    bool
	likes     int
	RepliesId seqid.ID
	Replies   *avl.Tree // id --> *Comment

	footer       string // additional text, e.g. "via @lou" or txlink calls
	DisableLikes bool
}

func (c Comment) ID() string {
	return c.id.String()
}

func (c Comment) Author() string {
	return c.author
}

func (c Comment) Content() string {
	return c.content
}

func (c Comment) CreatedAt() time.Time {
	return c.createdAt
}

func (c Comment) EditedAt() *time.Time {
	return c.editedAt
}

func (c Comment) Pinned() bool {
	return c.pinned
}

func (c Comment) Likes() int {
	return c.likes
}

func (c Comment) Footer() string {
	return c.footer
}

func NewComment(author, content string) (*Comment, error) {
	if content == "" {
		return nil, ErrEmptyComment
	}
	return &Comment{
		author:       author,
		content:      content,
		createdAt:    time.Now(),
		editedAt:     nil,
		pinned:       false,
		likes:        0,
		RepliesId:    seqid.ID(0),
		Replies:      avl.NewTree(),
		footer:       "",
		DisableLikes: false,
	}, nil
}

func (c *Comment) Edit(content string) error {
	if content == "" {
		return ErrEmptyComment
	}
	c.content = content
	now := time.Now()
	c.editedAt = &now
	return nil
}

func (c *Comment) AddReply(reply *Comment) error {
	if err := CheckAddr(reply.Author()); err != nil {
		return err
	}
	if reply == nil {
		return ErrEmptyComment
	}
	if c.Replies == nil {
		c.Replies = avl.NewTree()
	}
	reply.SetID(c.RepliesId.Next())
	if !c.Replies.Set(c.RepliesId.String(), reply) {
		return ErrCommentAddFailed
	}
	return nil
}

func (c *Comment) EditReplyByID(id, content string) error { // NECESSARY?
	reply, err := c.GetReplyByID(id)
	if err != nil {
		return err
	}
	err = reply.Edit(content)
	if err != nil {
		return err
	}
	return nil
}

func (c *Comment) DeleteReplyByID(id string) error { // NECESSARY?
	reply, err := c.GetReplyByID(id)
	if err != nil {
		return err
	}
	if _, removed := c.Replies.Remove(reply.ID()); !removed {
		return ErrCommentAddFailed
	}
	return nil
}

func (c Comment) GetReplyByID(id string) (*Comment, error) { // NECESSARY?
	reply, found := c.Replies.Get(id)
	if !found {
		return nil, ErrCommentNotFound
	}
	return reply.(*Comment), nil
}

func (c *Comment) Pin() {
	c.pinned = true
}

func (c *Comment) Unpin() {
	c.pinned = false
}

func (c *Comment) AddLike() {
	c.likes++
}

func (c *Comment) RemoveLike() {
	if c.likes > 0 {
		c.likes--
	}
}

func (c *Comment) SetID(id seqid.ID) {
	c.id = id
}

func (c *Comment) SetFooter(footer string) {
	c.footer = footer
}

func (c *Comment) Render(blogPrefix string, depth int, resolver *UserResolver) string {
	prefix := ""
	for i := 0; i < depth; i++ {
		prefix += "> "
	}
	user, _ := CheckUser(c.Author(), resolver)
	out := prefix + md.Bold(md.Link("@"+user, blogPrefix+":commenters/"+user)) + " "
	if c.Pinned() {
		out += "📌 "
	}
	if c.EditedAt() != nil {
		out += md.Italic(formatTime(*c.EditedAt(), "relative")+" (edited)") + "\n"
	} else {
		out += md.Italic(formatTime(c.CreatedAt(), "relative")) + "\n"
	}
	out += "\n" + prefix + c.Content() + "\n"
	if !c.DisableLikes {
		out += prefix + "❤️ " + strconv.Itoa(c.Likes()) + " \n\n"
	}
	if c.Footer() != "" {
		out += prefix + c.Footer() + "\n\n"
	}

	if c.Replies != nil && c.Replies.Size() > 0 {
		c.Replies.ReverseIterate("", "", func(key string, value any) bool {
			reply := value.(*Comment)
			out += reply.Render(blogPrefix, depth+1, resolver)
			return false
		})
	}
	return out
}
