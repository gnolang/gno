package uint256

import "testing"

func TestIsUint64(t *testing.T) {
	tests := []struct {
		x    string
		want bool
	}{
		{"0x0", true},
		{"0x1", true},
		{"0x10", true},
		{"0xffffffffffffffff", true},
		{"0x10000000000000000", false},
	}

	for _, tt := range tests {
		x := MustFromHex(tt.x)
		got := x.IsUint64()

		if got != tt.want {
			t.Errorf("IsUint64(%s) = %v, want %v", tt.x, got, tt.want)
		}
	}
}

func TestDec(t *testing.T) {
	tests := []struct {
		name string
		z    Uint
		want string
	}{
		{
			name: "zero",
			z:    Uint{arr: [4]uint64{0, 0, 0, 0}},
			want: "0",
		},
		{
			name: "less than 20 digits",
			z:    Uint{arr: [4]uint64{1234567890, 0, 0, 0}},
			want: "1234567890",
		},
		{
			name: "max possible value",
			z:    Uint{arr: [4]uint64{^uint64(0), ^uint64(0), ^uint64(0), ^uint64(0)}},
			want: twoPow256Sub1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.z.Dec()
			if result != tt.want {
				t.Errorf("Dec(%v) = %s, want %s", tt.z, result, tt.want)
			}
		})
	}
}

func TestHex(t *testing.T) {
	tests := []struct {
		name string
		z    Uint
		want string
	}{
		{
			name: "zero",
			z:    Uint{arr: [4]uint64{0, 0, 0, 0}},
			want: "0x0",
		},
		{
			name: "less than 20 digits",
			z:    Uint{arr: [4]uint64{0xbebecaca, 0, 0, 0}},
			want: "0xbebecaca",
		},
		{
			name: "max possible value",
			z:    Uint{arr: [4]uint64{^uint64(0), ^uint64(0), ^uint64(0), ^uint64(0)}},
			want: "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.z.Hex()
			if result != tt.want {
				t.Errorf("Hex(%v) = %s, want %s", tt.z, result, tt.want)
			}
		})
	}
}

func TestUint_Scan(t *testing.T) {
	tests := []struct {
		name    string
		input   any
		want    *Uint
		wantErr bool
	}{
		{
			name:  "nil",
			input: nil,
			want:  NewUint(0),
		},
		{
			name:  "valid scientific notation",
			input: "1e4",
			want:  NewUint(10000),
		},
		{
			name:  "valid decimal string",
			input: "12345",
			want:  NewUint(12345),
		},
		{
			name:  "valid byte slice",
			input: []byte("12345"),
			want:  NewUint(12345),
		},
		{
			name:    "invalid string",
			input:   "invalid",
			wantErr: true,
		},
		{
			name:    "out of range",
			input:   "115792089237316195423570985008687907853269984665640564039457584007913129639936", // 2^256
			wantErr: true,
		},
		{
			name:    "unsupported type",
			input:   123,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			z := new(Uint)
			err := z.Scan(tt.input)

			if tt.wantErr {
				if err == nil {
					t.Errorf("Scan() error = %v, wantErr %v", err, tt.wantErr)
				}
			} else {
				if err != nil {
					t.Errorf("Scan() error = %v, wantErr %v", err, tt.wantErr)
				}
				if !z.Eq(tt.want) {
					t.Errorf("Scan() = %v, want %v", z, tt.want)
				}
			}
		})
	}
}

func TestBytes32(t *testing.T) {
	tests := []struct {
		name string
		z    Uint
		want [32]byte
	}{
		{
			name: "zero",
			z:    Uint{arr: [4]uint64{0, 0, 0, 0}},
			want: [32]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
		},
		{
			name: "less than 20 digits",
			z:    Uint{arr: [4]uint64{0xbebecaca, 0, 0, 0}},
			want: [32]byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xbe, 0xbe, 0xca, 0xca},
		},
		{
			name: "max possible value",
			z:    Uint{arr: [4]uint64{^uint64(0), ^uint64(0), ^uint64(0), ^uint64(0)}},
			want: [32]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.z.Bytes32()
			if result != tt.want {
				t.Errorf("Hex(%v) = %s, want %s", tt.z, result, tt.want)
			}
		})
	}
}
func TestBytes(t *testing.T) {
	tests := []struct {
		name string
		z    Uint
		want []byte
	}{
		{
			name: "zero",
			z:    Uint{arr: [4]uint64{0, 0, 0, 0}},
			want: []byte{},
		},
		{
			name: "less than 20 digits",
			z:    Uint{arr: [4]uint64{0xbebecaca, 0, 0, 0}},
			want: []byte{0xbe, 0xbe, 0xca, 0xca},
		},
		{
			name: "max possible value",
			z:    Uint{arr: [4]uint64{^uint64(0), ^uint64(0), ^uint64(0), ^uint64(0)}},
			want: []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := tt.z.Bytes()
			err := false

			if len(result) != len(tt.want) {
				err = true
			}
			for i := 0; !err && i < len(result); i++ {
				if result[i] != tt.want[i] {
					err = true
				}
			}

			if err {
				t.Errorf("Bytes(%v) = %v, want %v", tt.z, result, tt.want)
			}
		})
	}
}

func TestSetBytes(t *testing.T) {
	tests := []struct {
		input    []byte
		expected string
	}{
		{[]byte{}, "0"},
		{[]byte{0x01}, "1"},
		{[]byte{0x12, 0x34}, "4660"},
		{[]byte{0x12, 0x34, 0x56}, "1193046"},
		{[]byte{0x12, 0x34, 0x56, 0x78}, "305419896"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a}, "78187493530"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc}, "20015998343868"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde}, "5124095576030430"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}, "1311768467463790320"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12}, "335812727670730321938"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34}, "85968058283706962416180"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56}, "22007822920628982378542166"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78}, "5634002667681019488906794616"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a}, "1442304682926340989160139421850"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc}, "369229998829143293224995691993788"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde}, "94522879700260683065598897150409950"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}, "24197857203266734864793317670504947440"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12}, "6194651444036284125387089323649266544658"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34}, "1585830769673288736099094866854212235432500"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56}, "405972677036361916441368285914678332270720086"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78}, "103929005321308650608990281194157653061304342136"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a}, "26605825362255014555901511985704359183693911586970"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc}, "6811091292737283726310787068340315951025641366264508"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde}, "1743639370940744633935561489495120883462564189763714270"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}, "446371678960830626287503741310750946166416432579510853360"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12}, "114271149813972640329600957775552242218602606740354778460178"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34}, "29253414352376995924377845190541374007962267325530823285805620"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56}, "7488874074208510956640728368778591746038340435335890761166238806"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78}, "1917151762997378804900026462407319486985815151445988034858557134456"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a}, "490790851327328974054406774376273788668368678770172936923790626420890"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc}, "125642457939796217357928134240326089899102381765164271852490400363748028"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde}, "32164469232587831643629602365523479014170209731882053594237542493119495390"},
		{[]byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}, "8234104123542484900769178205574010627627573691361805720124810878238590820080"},
		// over 32 bytes (last 32 bytes are used)
		{append([]byte{0xff}, []byte{0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0, 0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0}...), "8234104123542484900769178205574010627627573691361805720124810878238590820080"},
	}

	for _, test := range tests {
		z := new(Uint)
		z.SetBytes(test.input)
		expected := MustFromDecimal(test.expected)
		if z.Cmp(expected) != 0 {
			t.Errorf("SetBytes(%x) = %s, expected %s", test.input, z.String(), test.expected)
		}
	}
}
