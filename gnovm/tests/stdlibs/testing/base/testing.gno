// Shim for Go's "testing" package to support minimal testing types.
package testing

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

// ----------------------------------------
// Top level functions

// SkipErr is the type of the panic created by SkipNow
// and FailNow. Having it as a simple string means that it can be fmt.Printf'd
// easily (and doesn't get "corrupted" through gno2go).
type SkipErr string

func (s SkipErr) Error() string {
	return string(s)
}

// Recover functions like recover(), but it ensures that the recovered error is
// not an internal error of the testing package.
//
// Due to a lack of goroutines and thus runtime.Goexit, gno's testing system resorts
// to panics to abort testing with FailNow (and Fatal* functions) or SkipNow
// (and Skip* functions).
//
// NOTE: Recover() is likely to be removed.
func Recover(result Setter) {
	r := recover()
	if _, ok := r.(SkipErr); !ok {
		result.Set(r)
		return
	}

	panic(r)
}

type Setter interface {
	Set(v any)
}

func Short() bool {
	return true // TODO configure somehow.
}

func Verbose() bool {
	return true // TODO configure somehow.
}

// Like AllocsPerRun() but returns an integer.
// TODO: actually compute allocations; for now return 0.
func AllocsPerRun2(runs int, f func()) (total int) {
	for i := 0; i < runs; i++ {
		f()
	}
	return 0
}

// ----------------------------------------
// T

type T struct {
	name      string
	failed    bool
	skipped   bool
	subs      []*T
	parent    *T
	output    []byte // Output generated by test
	verbose   bool
	failfast  bool
	runFilter filterMatch
	dur       string
}

func NewT(name string) *T {
	return &T{name: name}
}

type testingFunc func(*T)

type testingFunc_cur func(realm, *T) // (jae) Special case in gnovm/pkg/test

// Not yet implemented:
// func (t *T) Cleanup(f func()) {
// func (t *T) Deadline() (deadline time.Time, ok bool)
func (t *T) Error(args ...any) {
	t.Log(args...)
	t.Fail()
}

func (t *T) Errorf(format string, args ...any) {
	t.Logf(format, args...)
	t.Fail()
}

func (t *T) Fail() {
	t.failed = true
}

func (t *T) FailNow() {
	t.Fail()
	panic(SkipErr("testing: you have recovered a panic attempting to interrupt a test, as a consequence of FailNow. " +
		"Use testing.Recover to recover panics within tests"))
}

func (t *T) Failed() bool {
	if t.failed {
		return true
	}
	for _, sub := range t.subs {
		if sub.Failed() {
			return true
		}
	}
	return false
}

// only called when verbose == false
func (t *T) printFailure() {
	fmt.Fprintf(os.Stderr, "--- FAIL: %s (%s)\n", t.name, t.dur)
	if t.failed {
		fmt.Fprint(os.Stderr, string(t.output))
	}
	for _, sub := range t.subs {
		if sub.Failed() {
			sub.printFailure()
		}
	}
}

func (t *T) Fatal(args ...any) {
	t.Log(args...)
	t.FailNow()
}

func (t *T) Fatalf(format string, args ...any) {
	t.Logf(format, args...)
	t.FailNow()
}

func (t *T) Log(args ...any) {
	t.log(fmt.Sprintln(args...))
}

func (t *T) Logf(format string, args ...any) {
	t.log(fmt.Sprintf(format, args...))
	t.log(fmt.Sprintln())
}

func (t *T) Name() string {
	return t.name
}

func (t *T) Parallel() {
	// does nothing.
}

func (t *T) Run(name string, f testingFunc) bool {
	fullName := t.name + "/" + rewrite(name)

	subT := &T{
		parent:    t,
		name:      fullName,
		verbose:   t.verbose,
		runFilter: t.runFilter,
	}

	if t.failfast && t.Failed() {
		return false
	}

	t.subs = append(t.subs, subT)

	tRunner(subT, f, t.verbose)
	return true
}

func (t *T) Setenv(key, value string) {
	panic("not yet implemented")
}

func (t *T) Skip(args ...any) {
	t.Log(args...)
	t.SkipNow()
}

func (t *T) SkipNow() {
	t.skipped = true
	panic(SkipErr("testing: you have recovered a panic attempting to interrupt a test, as a consequence of SkipNow. " +
		"Use testing.Recover to recover panics within tests"))
}

func (t *T) Skipped() bool {
	return t.skipped
}

func (t *T) Skipf(format string, args ...any) {
	t.Logf(format, args...)
	t.SkipNow()
}

func (t *T) TempDir() string {
	panic("not yet implemented")
}

func (t *T) Helper() {
}

func (t *T) log(s string) {
	if t.verbose {
		// verbose, print immediately
		fmt.Fprint(os.Stderr, s)
	} else {
		// defer printing only if test is failed
		t.output = append(t.output, s...)
	}
}

type Report struct {
	Failed  bool
	Skipped bool
}

func (r *Report) marshal() string {
	failed := "false"
	skipped := "false"
	if r.Failed {
		failed = "true"
	}
	if r.Skipped {
		skipped = "true"
	}
	return `{"Failed":` + failed + `,"Skipped":` + skipped + `}`
}

func (t *T) report() Report {
	return Report{
		Failed:  t.Failed(),
		Skipped: t.skipped,
	}
}

// ----------------------------------------
// B
// TODO: actually implement

type B struct {
	N int
}

func (b *B) Cleanup(f func())                    { panic("not yet implemented") }
func (b *B) Error(args ...any)                   { panic("not yet implemented") }
func (b *B) Errorf(format string, args ...any)   { panic("not yet implemented") }
func (b *B) Fail()                               { panic("not yet implemented") }
func (b *B) FailNow()                            { panic("not yet implemented") }
func (b *B) Failed() bool                        { panic("not yet implemented") }
func (b *B) Fatal(args ...any)                   { panic("not yet implemented") }
func (b *B) Fatalf(format string, args ...any)   { panic("not yet implemented") }
func (b *B) Helper()                             { panic("not yet implemented") }
func (b *B) Log(args ...any)                     { panic("not yet implemented") }
func (b *B) Logf(format string, args ...any)     { panic("not yet implemented") }
func (b *B) Name() string                        { panic("not yet implemented") }
func (b *B) ReportAllocs()                       { panic("not yet implemented") }
func (b *B) ReportMetric(n float64, unit string) { panic("not yet implemented") }
func (b *B) ResetTimer()                         { panic("not yet implemented") }
func (b *B) Run(name string, f func(b *B)) bool  { panic("not yet implemented") }
func (b *B) RunParallel(body func(*PB))          { panic("not yet implemented") }
func (b *B) SetBytes(n int64)                    { panic("not yet implemented") }
func (b *B) SetParallelism(p int)                { panic("not yet implemented") }
func (b *B) Setenv(key, value string)            { panic("not yet implemented") }
func (b *B) Skip(args ...any)                    { panic("not yet implemented") }
func (b *B) SkipNow()                            { panic("not yet implemented") }
func (b *B) Skipf(format string, args ...any)    { panic("not yet implemented") }
func (b *B) Skipped() bool                       { panic("not yet implemented") }
func (b *B) StartTimer()                         { panic("not yet implemented") }
func (b *B) StopTimer()                          { panic("not yet implemented") }
func (b *B) TempDir() string                     { panic("not yet implemented") }

// ----------------------------------------
// PB
// TODO: actually implement

type PB struct{}

func (pb *PB) Next() bool { panic("not yet implemented") }

type InternalTest struct {
	Name  string
	F     testingFunc
	F_cur testingFunc_cur // (jae) Special case in gnovm/pkg/test.
	Cur   realm           // (jae) Ditto. This won't work except through gnovm/pkg/test.
}

func (t *T) shouldRun(name string) bool {
	if t.runFilter == nil {
		return true
	}

	elem := strings.Split(name, "/")
	ok, partial := t.runFilter.matches(elem)
	_ = partial // we don't care right now
	return ok
}

func RunTest(runFlag string, verbose bool, failfast bool, test InternalTest) (ret string) {
	t := &T{
		name:     test.Name,
		verbose:  verbose,
		failfast: failfast,
	}

	if runFlag != "" {
		t.runFilter = splitRegexp(runFlag)
	}

	tRunner(t, test.F, verbose)
	if !t.verbose && t.Failed() {
		// use printFailure to print output log of this
		// and/or any subtests that may have failed.
		t.printFailure()
	}

	report := t.report()
	return report.marshal()
}

// (jae) Special case in gnovm/pkg/test.
func runTest_cur(runFlag string, verbose bool, failfast bool, test InternalTest) (ret string) {
	t := &T{
		name:     test.Name,
		verbose:  verbose,
		failfast: failfast,
	}

	if runFlag != "" {
		t.runFilter = splitRegexp(runFlag)
	}

	tRunner_cur(t, test.F_cur, test.Cur, verbose)
	if !t.verbose && t.Failed() {
		// use printFailure to print output log of this
		// and/or any subtests that may have failed.
		t.printFailure()
	}

	report := t.report()
	return report.marshal()
}

func formatDur(dur int64) string {
	// XXX switch to FormatFloat after it's been added
	// 1 sec = 1e9 nsec
	// this gets us the "centiseconds" which is what we show in tests.
	dstr := strconv.Itoa(int(dur / 1e7))
	if len(dstr) < 3 {
		const pad = "000"
		dstr = pad[:3-len(dstr)] + dstr
	}
	return dstr[:len(dstr)-2] + "." + dstr[len(dstr)-2:] + "s"
}

// used to calculate execution times; only present in testing stdlibs
func unixNano() int64

// recovers panics and returns their related stacktraces, as well
func recoverWithStacktrace() (interface{}, string)

// used to filter tests, we can't directly use regexp here due to a cyclic import; only present in testing stdlibs
func matchString(pat, str string) (bool, string)

func tRunner(t *T, fn testingFunc, verbose bool) {
	if !t.shouldRun(t.name) {
		return
	}

	start := unixNano()

	defer func() {
		err, st := recoverWithStacktrace()
		switch err.(type) {
		case nil:
		case SkipErr:
		default:
			t.Fail()
			fmt.Fprintf(os.Stderr, "panic: %v\nStacktrace:\n%s\n", err, st)
		}

		dur := unixNano() - start
		t.dur = formatDur(dur)

		if t.verbose {
			switch {
			case t.Failed():
				fmt.Fprintf(os.Stderr, "--- FAIL: %s (%s)\n", t.name, t.dur)
			case t.skipped:
				fmt.Fprintf(os.Stderr, "--- SKIP: %s (%s)\n", t.name, t.dur)
			case t.verbose:
				fmt.Fprintf(os.Stderr, "--- PASS: %s (%s)\n", t.name, t.dur)
			}
		}
	}()

	if verbose {
		fmt.Fprintf(os.Stderr, "=== RUN   %s\n", t.name)
	}

	fn(t)
}

func tRunner_cur(t *T, fn testingFunc_cur, next realm, verbose bool) {
	if !t.shouldRun(t.name) {
		return
	}

	start := unixNano()

	defer func() {
		err, st := recoverWithStacktrace()
		switch err.(type) {
		case nil:
		case SkipErr:
		default:
			t.Fail()
			fmt.Fprintf(os.Stderr, "panic: %v\nStacktrace:\n%s\n", err, st)
		}

		dur := unixNano() - start
		t.dur = formatDur(dur)

		if t.verbose {
			switch {
			case t.Failed():
				fmt.Fprintf(os.Stderr, "--- FAIL: %s (%s)\n", t.name, t.dur)
			case t.skipped:
				fmt.Fprintf(os.Stderr, "--- SKIP: %s (%s)\n", t.name, t.dur)
			case t.verbose:
				fmt.Fprintf(os.Stderr, "--- PASS: %s (%s)\n", t.name, t.dur)
			}
		}
	}()

	if verbose {
		fmt.Fprintf(os.Stderr, "=== RUN   %s\n", t.name)
	}

	// (jae) handled by gnovm/pkg/test and gnovm preprocessor.
	// Normally the first argument must be `cur` or `cross`,
	// but from this package it is possible to pass a realm
	// value without crossing.
	fn(next, t)
}
