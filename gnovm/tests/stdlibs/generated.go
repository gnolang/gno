// Code generated by the genstd tool (@/misc/genstd); DO NOT EDIT.
// To regenerate it, run `go generate` from this directory.

package stdlibs

import (
	"reflect"

	gno "github.com/gnolang/gno/gnovm/pkg/gnolang"
	testlibs_chain_runtime "github.com/gnolang/gno/gnovm/tests/stdlibs/chain/runtime"
	testlibs_fmt "github.com/gnolang/gno/gnovm/tests/stdlibs/fmt"
	testlibs_os "github.com/gnolang/gno/gnovm/tests/stdlibs/os"
	testlibs_testing "github.com/gnolang/gno/gnovm/tests/stdlibs/testing"
	testlibs_unicode "github.com/gnolang/gno/gnovm/tests/stdlibs/unicode"
)

// NativeFunc represents a function in the standard library which has a native
// (go-based) implementation, commonly referred to as a "native binding".
type NativeFunc struct {
	gnoPkg     string
	gnoFunc    gno.Name
	params     []gno.FieldTypeExpr
	results    []gno.FieldTypeExpr
	hasMachine bool
	f          func(m *gno.Machine)
}

// HasMachineParam returns whether the given native binding has a machine parameter.
// This means that the Go version of this function expects a *gno.Machine
// as its first parameter.
func (n *NativeFunc) HasMachineParam() bool {
	return n.hasMachine
}

var nativeFuncs = [...]NativeFunc{
	{
		"chain/runtime",
		"AssertOriginCall",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			testlibs_chain_runtime.AssertOriginCall(
				m,
			)
		},
	},
	{
		"chain/runtime",
		"getRealm",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("int")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  int
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0, r1 := testlibs_chain_runtime.X_getRealm(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"fmt",
		"typeString",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0 := testlibs_fmt.X_typeString(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"fmt",
		"valueOfInternal",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r2"), Type: gno.X("uint64")},
			{NameExpr: *gno.Nx("r3"), Type: gno.X("any")},
			{NameExpr: *gno.Nx("r4"), Type: gno.X("int")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0, r1, r2, r3, r4 := testlibs_fmt.X_valueOfInternal(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r2).Elem(),
			))
			m.PushValue(r3)
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r4).Elem(),
			))
		},
	},
	{
		"fmt",
		"getAddr",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("uint64")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0 := testlibs_fmt.X_getAddr(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"fmt",
		"getPtrElem",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("any")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0 := testlibs_fmt.X_getPtrElem(p0)

			m.PushValue(r0)
		},
	},
	{
		"fmt",
		"mapKeyValues",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[]any")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("[]any")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0, r1 := testlibs_fmt.X_mapKeyValues(p0)

			m.PushValue(r0)
			m.PushValue(r1)
		},
	},
	{
		"fmt",
		"arrayIndex",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("int")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("any")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  = *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)
				p1  int
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			r0 := testlibs_fmt.X_arrayIndex(
				m,
				p0, p1)

			m.PushValue(r0)
		},
	},
	{
		"fmt",
		"fieldByIndex",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("int")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("any")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  = *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)
				p1  int
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			r0, r1 := testlibs_fmt.X_fieldByIndex(p0, p1)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(r1)
		},
	},
	{
		"fmt",
		"asByteSlice",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("any")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[]byte")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			p0 := *(b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV)

			r0, r1 := testlibs_fmt.X_asByteSlice(p0)

			m.PushValue(r0)
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"os",
		"write",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("[]byte")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("bool")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("int")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  []byte
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  bool
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			r0 := testlibs_os.X_write(
				m,
				p0, p1)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"os",
		"sleep",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  int64
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			testlibs_os.X_sleep(
				m,
				p0)
		},
	},
	{
		"testing",
		"getContext",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("r2"), Type: gno.X("[]int64")},
			{NameExpr: *gno.Nx("r3"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("r4"), Type: gno.X("[]int64")},
			{NameExpr: *gno.Nx("r5"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r6"), Type: gno.X("int64")},
			{NameExpr: *gno.Nx("r7"), Type: gno.X("int64")},
			{NameExpr: *gno.Nx("r8"), Type: gno.X("int64")},
		},
		true,
		func(m *gno.Machine) {
			r0, r1, r2, r3, r4, r5, r6, r7, r8 := testlibs_testing.X_getContext(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r2).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r3).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r4).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r5).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r6).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r7).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r8).Elem(),
			))
		},
	},
	{
		"testing",
		"setContext",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p4"), Type: gno.X("[]int64")},
			{NameExpr: *gno.Nx("p5"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p6"), Type: gno.X("[]int64")},
			{NameExpr: *gno.Nx("p7"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p8"), Type: gno.X("int64")},
			{NameExpr: *gno.Nx("p9"), Type: gno.X("int64")},
			{NameExpr: *gno.Nx("p10"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0   string
				rp0  = reflect.ValueOf(&p0).Elem()
				p1   string
				rp1  = reflect.ValueOf(&p1).Elem()
				p2   string
				rp2  = reflect.ValueOf(&p2).Elem()
				p3   []string
				rp3  = reflect.ValueOf(&p3).Elem()
				p4   []int64
				rp4  = reflect.ValueOf(&p4).Elem()
				p5   []string
				rp5  = reflect.ValueOf(&p5).Elem()
				p6   []int64
				rp6  = reflect.ValueOf(&p6).Elem()
				p7   string
				rp7  = reflect.ValueOf(&p7).Elem()
				p8   int64
				rp8  = reflect.ValueOf(&p8).Elem()
				p9   int64
				rp9  = reflect.ValueOf(&p9).Elem()
				p10  int64
				rp10 = reflect.ValueOf(&p10).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)
			tv4 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 4, "")).TV
			tv4.DeepFill(m.Store)
			gno.Gno2GoValue(tv4, rp4)
			tv5 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 5, "")).TV
			tv5.DeepFill(m.Store)
			gno.Gno2GoValue(tv5, rp5)
			tv6 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 6, "")).TV
			tv6.DeepFill(m.Store)
			gno.Gno2GoValue(tv6, rp6)
			tv7 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 7, "")).TV
			tv7.DeepFill(m.Store)
			gno.Gno2GoValue(tv7, rp7)
			tv8 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 8, "")).TV
			tv8.DeepFill(m.Store)
			gno.Gno2GoValue(tv8, rp8)
			tv9 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 9, "")).TV
			tv9.DeepFill(m.Store)
			gno.Gno2GoValue(tv9, rp9)
			tv10 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 10, "")).TV
			tv10.DeepFill(m.Store)
			gno.Gno2GoValue(tv10, rp10)

			testlibs_testing.X_setContext(
				m,
				p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)
		},
	},
	{
		"testing",
		"testIssueCoins",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("[]int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  []int64
				rp2 = reflect.ValueOf(&p2).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)

			testlibs_testing.X_testIssueCoins(
				m,
				p0, p1, p2)
		},
	},
	{
		"testing",
		"newRealm",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("runtime.Realm")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			r0 := testlibs_testing.X_newRealm(
				m,
				p0, p1)

			m.PushValue(r0)
		},
	},
	{
		"testing",
		"isRealm",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := testlibs_testing.X_isRealm(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"testing",
		"unixNano",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("int64")},
		},
		false,
		func(m *gno.Machine) {
			r0 := testlibs_testing.X_unixNano()

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"testing",
		"recoverWithStacktrace",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.AnyT()},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			r0, r1 := testlibs_testing.X_recoverWithStacktrace(
				m,
			)

			m.PushValue(r0)
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"testing",
		"matchString",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("string")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			r0, r1 := testlibs_testing.X_matchString(p0, p1)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"unicode",
		"IsPrint",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("rune")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  rune
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := testlibs_unicode.IsPrint(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"unicode",
		"IsGraphic",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("rune")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  rune
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := testlibs_unicode.IsGraphic(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"unicode",
		"SimpleFold",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("rune")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("rune")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  rune
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := testlibs_unicode.SimpleFold(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"unicode",
		"IsUpper",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("rune")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  rune
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := testlibs_unicode.IsUpper(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
}

var initOrder = [...]string{}

// InitOrder returns the initialization order of the standard libraries.
// This is calculated starting from the list of all standard libraries and
// iterating through each: if a package depends on an unitialized package, that
// is processed first, and so on recursively; matching the behaviour of Go's
// [program initialization].
//
// [program initialization]: https://go.dev/ref/spec#Program_initialization
func InitOrder() []string {
	return initOrder[:]
}
