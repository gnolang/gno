package repl

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"text/template"

	gno "github.com/gnolang/gno/gnovm/pkg/gnolang"
	"github.com/gnolang/gno/gnovm/tests"
)

const (
	executedFunc = "main"
	fileTemplate = `// generated by 'gno repl'
// FILE NAME: test{{$.ID}}.gno
package test
{{range .Imports}}
{{.}}
{{end}}
{{range .Declarations}}
{{.}}
{{end}}
{{with .Expression}}
// main function
func main{{$.ID}}() {
	{{.}}
}
{{end}}
`
)

type tempModel struct {
	ID           int
	Declarations []string
	Imports      []string
	Expression   string
}

type state struct {
	// b is the buffer where the VM is writing. It is used to get the output when a expression is executed
	b bytes.Buffer

	// imports contains all the imports added. they will be added to the following generated source code
	imports map[string]string

	// files are all generated files. This is used when source code is requested
	files map[string]string

	// id is the actual execution number. Used to avoid duplicated functions and file names.
	id int

	fileset *token.FileSet
	machine *gno.Machine
}

type Repl struct {
	state *state
	tmpl  *template.Template
}

func newState() *state {
	s := &state{
		imports: make(map[string]string),
		files:   make(map[string]string),
		fileset: token.NewFileSet(),
	}

	s.machine = newMachine(&s.b)

	return s
}

func newMachine(b *bytes.Buffer) *gno.Machine {
	testStore := tests.TestStore("teststore", "", b, b, b, tests.ImportModeStdlibsOnly)
	return gno.NewMachineWithOptions(gno.MachineOptions{
		PkgPath: "test",
		Output:  b,
		Store:   testStore,
	})
}

// NewRepl creates a Repl struct. It is able to process input source code and eventually run it.
func NewRepl() *Repl {
	t, err := template.New("tmpl").Parse(fileTemplate)
	if err != nil {
		panic(fmt.Errorf("error parsing template: %w", err))
	}

	return &Repl{
		tmpl:  t,
		state: newState(),
	}
}

// Process will accept any valid code and execute it if it is an expression,
// or store it for later use if they are declarations.
// If the provided input is not valid source code, an error is returned.
// If the execution on the VM is not successful, the panic is recovered and returned as an error.
func (r *Repl) Process(input string) (out string, err error) {
	defer func() {
		if r := recover(); r != nil {
			err = fmt.Errorf("recovered from panic: %q", r)
		}
	}()
	r.state.id++
	exp, expErr := r.parseExpression(input)
	if expErr == nil {
		return r.handleExpression(exp)
	}

	decl, declErr := r.parseDeclaration(input)
	if declErr == nil {
		return r.handleDeclarations(decl)
	}

	return "", fmt.Errorf("error parsing code as expression (error: %w) and as declarations (error: %w)", expErr, declErr)
}

func (r *Repl) handleExpression(e *ast.File) (string, error) {
	var b bytes.Buffer
	if err := printer.Fprint(&b, r.state.fileset, e); err != nil {
		return "", fmt.Errorf("error handling expression: %w", err)
	}

	fn := r.filename()
	src := r.nodeToString(e)

	n := gno.MustParseFile(fn, src)
	r.state.files[fn] = src
	r.state.machine.RunFiles(n)
	r.state.machine.RunStatement(gno.S(gno.Call(gno.X(fmt.Sprintf("%s%d", executedFunc, r.state.id)))))

	// read the result from the output buffer after calling main function
	out := r.state.b.String()
	r.state.b.Reset()

	return out, nil
}

func (r *Repl) handleDeclarations(fn *ast.File) (string, error) {
	var b bytes.Buffer
	var nonImportsCount int
	ast.Inspect(fn, func(n ast.Node) bool {
		var writeNode bool
		var ns string
		switch t := n.(type) {
		// TODO:
		//	token.CONST   *ValueSpec
		//	token.TYPE    *TypeSpec
		//	token.VAR     *ValueSpec
		case *ast.GenDecl:
			if t.Tok != token.IMPORT {
				break
			}
			writeNode = true

			i, ok := t.Specs[0].(*ast.ImportSpec)
			if !ok {
				break
			}

			ns = r.nodeToString(n)
			r.state.imports[i.Path.Value] = ns
		case *ast.FuncDecl:
			writeNode = true
			nonImportsCount++
			ns = r.nodeToString(n)
		}

		if !writeNode {
			return true
		}

		b.WriteString(ns)
		b.WriteByte('\n')

		return false
	})

	// Avoid adding files with only imports on it
	if nonImportsCount != 0 {
		name := r.filename()
		src := r.nodeToString(fn)

		n := gno.MustParseFile(name, src)
		r.state.files[name] = src
		r.state.machine.RunFiles(n)
	}

	return b.String(), nil
}

func (r *Repl) nodeToString(n ast.Node) string {
	var b bytes.Buffer
	if err := printer.Fprint(&b, r.state.fileset, n); err != nil {
		panic(err)
	}
	return b.String()
}

func (r *Repl) filename() string {
	return fmt.Sprintf("test%d.gno", r.state.id)
}

func (r *Repl) parseExpression(input string) (*ast.File, error) {
	return r.executeAndParse(&tempModel{
		Expression: input,
	})
}

func (r *Repl) parseDeclaration(input string) (*ast.File, error) {
	return r.executeAndParse(&tempModel{
		Declarations: []string{input},
	})
}

func (r *Repl) executeAndParse(m *tempModel) (*ast.File, error) {
	var b bytes.Buffer

	// set the id to the template
	m.ID = r.state.id

	// add all the imports to all the files, they will be removed after formatting
	for _, e := range r.state.imports {
		m.Imports = append(m.Imports, e)
	}

	err := r.tmpl.Execute(&b, m)
	if err != nil {
		return nil, fmt.Errorf("error executing the template: %w", err)
	}

	// format the source code to remove unused imports and improve code readability
	formatted, err := format.Source(b.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error formatting code: %w", err)
	}

	name := r.filename()
	return parser.ParseFile(r.state.fileset, name, formatted, parser.AllErrors|parser.ParseComments)
}

// Reset will reset the actual repl state, restarting the internal VM
func (r *Repl) Reset() {
	r.state.machine.Release()
	r.state = newState()
}

const separator = "//----------------------------------//\n"

// Src will print all the valid code introduced on this Repl session.
func (r *Repl) Src() string {
	var b bytes.Buffer

	b.WriteString(separator)
	for _, s := range r.state.files {
		b.WriteString(s)
		b.WriteString(separator)
	}

	return b.String()
}
