--- ./testdata/goversion/t03.go.orig	2025-02-27 18:57:18.000000000 +0100
+++ ./testdata/goversion/t03.go	2025-07-30 17:41:28.886734480 +0200
@@ -1,3 +1,3 @@
-//go:build linux && go1.2 || windows
+//go:build (linux && go1.2) || windows
 
 package none
--- ./parser_test.go.orig	2025-02-27 18:57:18.000000000 +0100
+++ ./parser_test.go	2025-07-30 17:41:28.887802487 +0200
@@ -81,6 +81,7 @@
 	}
 }
 
+/*
 func TestIssue42951(t *testing.T) {
 	path := "./testdata/issue42951"
 	_, err := ParseDir(token.NewFileSet(), path, nil, 0)
@@ -88,6 +89,7 @@
 		t.Errorf("ParseDir(%s): %v", path, err)
 	}
 }
+*/
 
 func TestParseExpr(t *testing.T) {
 	// just kicking the tires:
--- ./interface.go.orig	2025-02-27 18:57:18.000000000 +0100
+++ ./interface.go	2025-08-19 17:08:07.525010743 +0200
@@ -133,6 +133,65 @@
 	return
 }
 
+// Stats contains the statistics collected during parsing: number of tokens and maximum nesting level.
+type Stats struct {
+	TopNest, NumTok int
+}
+
+// ParseFileStats is indentical to ParseFile execpt it also returns statistics on parsing.
+func ParseFileStats(fset *token.FileSet, filename string, src any, mode Mode) (f *ast.File, s *Stats, err error) {
+	if fset == nil {
+		panic("parser.ParseFile: no token.FileSet provided (fset == nil)")
+	}
+
+	// get source
+	text, err := readSource(filename, src)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	file := fset.AddFile(filename, -1, len(text))
+
+	var p parser
+	defer func() {
+		if e := recover(); e != nil {
+			// resume same panic if it's not a bailout
+			bail, ok := e.(bailout)
+			if !ok {
+				panic(e)
+			} else if bail.msg != "" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
+			}
+		}
+
+		// set result values
+		if f == nil {
+			// source is not a valid Go source file - satisfy
+			// ParseFile API and return a valid (but) empty
+			// *ast.File
+			f = &ast.File{
+				Name:  new(ast.Ident),
+				Scope: ast.NewScope(nil),
+			}
+		}
+
+		// Ensure the start/end are consistent,
+		// whether parsing succeeded or not.
+		f.FileStart = token.Pos(file.Base())
+		f.FileEnd = token.Pos(file.Base() + file.Size())
+
+		p.errors.Sort()
+		err = p.errors.Err()
+	}()
+
+	// parse source
+	p.init(file, text, mode)
+	f = p.parseFile()
+	s = &Stats{p.topNest, p.numTok}
+
+	return
+}
+
 // ParseDir calls [ParseFile] for all files with names ending in ".go" in the
 // directory specified by path and returns a map of package name -> package
 // AST with all the packages found.
@@ -236,6 +295,49 @@
 	return
 }
 
+// ParseExprFromStats is identical to ParseExprFrom except it also returns parsing statistics.
+func ParseExprFromStats(fset *token.FileSet, filename string, src any, mode Mode) (expr ast.Expr, s *Stats, err error) {
+	if fset == nil {
+		panic("parser.ParseExprFrom: no token.FileSet provided (fset == nil)")
+	}
+
+	// get source
+	text, err := readSource(filename, src)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	var p parser
+	defer func() {
+		if e := recover(); e != nil {
+			// resume same panic if it's not a bailout
+			bail, ok := e.(bailout)
+			if !ok {
+				panic(e)
+			} else if bail.msg != "" {
+				p.errors.Add(p.file.Position(bail.pos), bail.msg)
+			}
+		}
+		p.errors.Sort()
+		err = p.errors.Err()
+	}()
+
+	// parse expr
+	file := fset.AddFile(filename, -1, len(text))
+	p.init(file, text, mode)
+	expr = p.parseRhs()
+
+	// If a semicolon was inserted, consume it;
+	// report an error if there's more tokens.
+	if p.tok == token.SEMICOLON && p.lit == "\n" {
+		p.next()
+	}
+	p.expect(token.EOF)
+	s = &Stats{p.topNest, p.numTok}
+
+	return
+}
+
 // ParseExpr is a convenience function for obtaining the AST of an expression x.
 // The position information recorded in the AST is undefined. The filename used
 // in error messages is the empty string.
@@ -246,3 +348,8 @@
 func ParseExpr(x string) (ast.Expr, error) {
 	return ParseExprFrom(token.NewFileSet(), "", []byte(x), 0)
 }
+
+// ParseExprStats is identical to ParseExpr except it also returns parsing statistics.
+func ParseExprStats(x string) (ast.Expr, *Stats, error) {
+	return ParseExprFromStats(token.NewFileSet(), "", []byte(x), 0)
+}
--- ./performance_test.go.orig	2025-02-27 18:57:18.000000000 +0100
+++ ./performance_test.go	2025-07-30 17:41:28.888251824 +0200
@@ -10,7 +10,7 @@
 	"testing"
 )
 
-var src = readFile("../printer/nodes.go")
+var src = readFile("nodes.go.src")
 
 func readFile(filename string) []byte {
 	data, err := os.ReadFile(filename)
--- ./parser.go.orig	2025-02-27 18:57:18.000000000 +0100
+++ ./parser.go	2025-08-19 16:47:28.738256046 +0200
@@ -63,6 +63,12 @@
 	// nestLev is used to track and limit the recursion depth
 	// during parsing.
 	nestLev int
+
+	// Gno: topNest is the maximum nesting level reached during parsing.
+	topNest int
+
+	// Gno: numTok is the number of parsed tokens.
+	numTok int
 }
 
 func (p *parser) init(file *token.File, src []byte, mode Mode) {
@@ -107,7 +113,8 @@
 }
 
 // maxNestLev is the deepest we're willing to recurse during parsing
-const maxNestLev int = 1e5
+// Gno: Changed from 1e5 to 1e4.
+const maxNestLev int = 1e4
 
 func incNestLev(p *parser) *parser {
 	p.nestLev++
@@ -115,6 +122,9 @@
 		p.error(p.pos, "exceeded max nesting depth")
 		panic(bailout{})
 	}
+	if p.topNest < p.nestLev {
+		p.topNest = p.nestLev
+	}
 	return p
 }
 
@@ -144,6 +154,7 @@
 
 	for {
 		p.pos, p.tok, p.lit = p.scanner.Scan()
+		p.numTok++
 		if p.tok == token.COMMENT {
 			if p.top && strings.HasPrefix(p.lit, "//go:build") {
 				if x, err := constraint.Parse(p.lit); err == nil {
