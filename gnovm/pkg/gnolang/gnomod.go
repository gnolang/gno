package gnolang

import (
	"cmp"
	"fmt"
	"html/template"
	"strconv"
	"strings"
	"sync"

	"github.com/gnolang/gno/gnovm/pkg/gnomod"
	"github.com/gnolang/gno/tm2/pkg/std"
)

const gnomodTemplate = `{{/*
This is a comment in a Go template in pkg/gnolang/gnomod.go.
The gnomodTemplate is used with the 'text/template' package
to generate the final gnomod.toml file. */}}
module = "{{.PkgPath}}"
gno = "{{.GnoVersion}}"`

var gnomodTemplateOnce = sync.OnceValue(func() *template.Template {
	return template.Must(template.New("").Parse(gnomodTemplate))
})

func GenGnoModLatest(pkgPath string) string  { return genGnoMod(pkgPath, GnoVerLatest) }
func GenGnoModTesting(pkgPath string) string { return genGnoMod(pkgPath, GnoVerTesting) }
func GenGnoModDefault(pkgPath string) string { return genGnoMod(pkgPath, GnoVerDefault) }
func GenGnoModMissing(pkgPath string) string { return genGnoMod(pkgPath, GnoVerMissing) }

func genGnoMod(pkgPath string, gnoVersion string) string {
	var bld strings.Builder
	err := gnomodTemplateOnce().Execute(&bld, struct {
		PkgPath    string
		GnoVersion string
	}{pkgPath, gnoVersion})
	if err != nil {
		panic(fmt.Errorf("generating gnomod.toml: %w", err))
	}
	return bld.String()
}

const (
	GnoVerLatest  = `0.9` // current version
	GnoVerTesting = `0.9` // version of our tests
	GnoVerDefault = `0.9` // auto generated gnomod.toml
	GnoVerMissing = `0.0` // missing gnomod.toml, !autoGnoMod XXX
)

// ========================================
// Parses and checks the gnomod.toml file from mpkg.
// To generate default ones, GenGnoMod*().
// Generates the latest default for stdlibs.
//
// Results:
//   - mod: the gnomod.toml file, or nil if not found.
//   - err: wrapped error, or nil if file not found.
func ParseCheckGnoMod(mpkg *std.MemPackage) (mod *gnomod.File, err error) {
	if IsStdlib(mpkg.Path) {
		// stdlib/extern packages are assumed up to date.
		modstr := GenGnoModLatest(mpkg.Path)
		mod, _ = gnomod.ParseBytes("<stdlibs_autogenerated>/gnomod.toml", []byte(modstr))
	} else if mpkg.GetFile("gnomod.toml") == nil && mpkg.GetFile("gno.mod") == nil {
		// gnomod.toml or gno.mod doesn't exist.
		return nil, nil
	} else if mod, err = gnomod.ParseMemPackage(mpkg); err != nil {
		// error parsing gnomod.toml.
		err = fmt.Errorf("%s/gnomod.toml: parse error: %w", mpkg.Path, err)
	} else if mod.Gno == "" {
		// gnomod.toml was never specified; set missing.
		mod.SetGno(GnoVerMissing)
	} else if mod.Gno == GnoVerLatest {
		// current version, nothing to do.
	} else {
		panic("unsupported gno version " + mod.Gno)
	}
	return
}

func CompareVersions(a, b string) (int, bool) {
	amaj, amin, aok := cutAndConvert(a, ".")
	bmaj, bmin, bok := cutAndConvert(b, ".")
	if !aok || !bok {
		return 0, false
	}
	if c := cmp.Compare(amaj, bmaj); c != 0 {
		return c, true
	}
	return cmp.Compare(amin, bmin), true
}

func cutAndConvert(s, sep string) (int, int, bool) {
	x, y, ok := strings.Cut(s, sep)
	if !ok {
		return 0, 0, false
	}
	cx, errx := strconv.Atoi(x)
	cy, erry := strconv.Atoi(y)
	if errx != nil || erry != nil {
		return 0, 0, false
	}
	return cx, cy, true
}
