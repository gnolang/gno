package gnoffee

import (
	"bytes"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"testing"
)

func TestPackage(t *testing.T) {
	inputCode := `
package sample

export foo as Bar

type foo struct{}

func (f *foo) Hello() string {
	return "Hello from foo!"
}

func (f *foo) Bye() {
	println("Goodbye from foo!")
}

type Bar interface {
	Hello() string
	Bye()
}
`
	expectedOutput := `
package sample

// This function was generated by gnoffee due to the export directive.
func Hello() string {
	return foo.Hello()
}

// This function was generated by gnoffee due to the export directive.
func Bye() {
	foo.Bye()
}
`

	// Stage 1
	inputCode = Stage1(inputCode)

	// Stage 2
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "sample.go", inputCode, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse input: %v", err)
	}

	files := map[string]*ast.File{
		"sample.go": file,
	}

	generatedFile, err := Stage2(files)
	if err != nil {
		t.Fatalf("Error during Stage2 generation: %v", err)
	}

	var buf bytes.Buffer
	if err := format.Node(&buf, fset, generatedFile); err != nil {
		t.Fatalf("Failed to format generated output: %v", err)
	}

	generatedCode := normalizeGoCode(buf.String())
	expected := normalizeGoCode(expectedOutput)
	if generatedCode != expected {
		t.Errorf("Generated code does not match expected output.\nExpected:\n\n%v\n\nGot:\n\n%v", expected, generatedCode)
	}
}
