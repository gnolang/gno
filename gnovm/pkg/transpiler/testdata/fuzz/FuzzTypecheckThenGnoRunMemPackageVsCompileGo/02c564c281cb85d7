go test fuzz v1
[]byte("package fp\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestMap(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"multiply numbers by 2\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tfn:       func(v interface{}) interface{} { return v.(int) * 2 },\n\t\t\texpected: []interface{}{2, 4, 6},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(v interface{}) interface{} { return v.(int) * 2 },\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"convert numbers to strings\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tfn:       func(v interface{}) interface{} { return fmt.Sprintf(\"%d\", v.(int)) },\n\t\t\texpected: []interface{}{\"1\", \"2\", \"3\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Map(tt.input, tt.fn)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Map failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFilter(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) bool\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"filter even numbers\",\n\t\t\tinput:    []interface{}{1, 2, 3, 4},\n\t\t\tfn:       func(v interface{}) bool { return v.(int)%2 == 0 },\n\t\t\texpected: []interface{}{2, 4},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(v interface{}) bool { return v.(int)%2 == 0 },\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"no matches\",\n\t\t\tinput:    []interface{}{1, 3, 5},\n\t\t\tfn:       func(v interface{}) bool { return v.(int)%2 == 0 },\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"all matches\",\n\t\t\tinput:    []interface{}{2, 4, 6},\n\t\t\tfn:       func(v interface{}) bool { return v.(int)%2 == 0 },\n\t\t\texpected: []interface{}{2, 4, 6},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Filter(tt.input, tt.fn)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Filter failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReduce(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}, interface{}) interface{}\n\t\tinitial  interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"sum numbers\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(int) + b.(int) },\n\t\t\tinitial:  0,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(int) + b.(int) },\n\t\t\tinitial:  0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"concatenate strings\",\n\t\t\tinput:    []interface{}{\"a\", \"b\", \"c\"},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(string) + b.(string) },\n\t\t\tinitial:  \"\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Reduce(tt.input, tt.fn, tt.initial)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Reduce failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFlatMap(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"split words into chars\",\n\t\t\tinput: []interface{}{\"go\", \"fn\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tchars := []interface{}{}\n\t\t\t\tfor _, c := range word.(string) {\n\t\t\t\t\tchars = append(chars, string(c))\n\t\t\t\t}\n\t\t\t\treturn chars\n\t\t\t},\n\t\t\texpected: []interface{}{\"g\", \"o\", \"f\", \"n\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string handling\",\n\t\t\tinput: []interface{}{\"\", \"a\", \"\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tchars := []interface{}{}\n\t\t\t\tfor _, c := range word.(string) {\n\t\t\t\t\tchars = append(chars, string(c))\n\t\t\t\t}\n\t\t\t\treturn chars\n\t\t\t},\n\t\t\texpected: []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"nil handling\",\n\t\t\tinput: []interface{}{nil, \"a\", nil},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tif word == nil {\n\t\t\t\t\treturn []interface{}{}\n\t\t\t\t}\n\t\t\t\treturn []interface{}{word}\n\t\t\t},\n\t\t\texpected: []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty slice result\",\n\t\t\tinput: []interface{}{\"\", \"\", \"\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\treturn []interface{}{}\n\t\t\t},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array flattening\",\n\t\t\tinput: []interface{}{1, 2, 3},\n\t\t\tfn: func(n interface{}) interface{} {\n\t\t\t\treturn []interface{}{n, n}\n\t\t\t},\n\t\t\texpected: []interface{}{1, 1, 2, 2, 3, 3},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := FlatMap(tt.input, tt.fn)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"FlatMap failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllAnyNone(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []interface{}\n\t\tfn           func(interface{}) bool\n\t\texpectedAll  bool\n\t\texpectedAny  bool\n\t\texpectedNone bool\n\t}{\n\t\t{\n\t\t\tname:         \"all even numbers\",\n\t\t\tinput:        []interface{}{2, 4, 6, 8},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  true,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"no even numbers\",\n\t\t\tinput:        []interface{}{1, 3, 5, 7},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  false,\n\t\t\texpectedAny:  false,\n\t\t\texpectedNone: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"mixed even/odd numbers\",\n\t\t\tinput:        []interface{}{1, 2, 3, 4},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  false,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"empty slice\",\n\t\t\tinput:        []interface{}{},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  true,  // vacuously true\n\t\t\texpectedAny:  false, // vacuously false\n\t\t\texpectedNone: true,  // vacuously true\n\t\t},\n\t\t{\n\t\t\tname:         \"nil predicate handling\",\n\t\t\tinput:        []interface{}{nil, nil, nil},\n\t\t\tfn:           func(x interface{}) bool { return x == nil },\n\t\t\texpectedAll:  true,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresultAll := All(tt.input, tt.fn)\n\t\t\tif resultAll != tt.expectedAll {\n\t\t\t\tt.Errorf(\"All failed, expected %v, got %v\", tt.expectedAll, resultAll)\n\t\t\t}\n\n\t\t\tresultAny := Any(tt.input, tt.fn)\n\t\t\tif resultAny != tt.expectedAny {\n\t\t\t\tt.Errorf(\"Any failed, expected %v, got %v\", tt.expectedAny, resultAny)\n\t\t\t}\n\n\t\t\tresultNone := None(tt.input, tt.fn)\n\t\t\tif resultNone != tt.expectedNone {\n\t\t\t\tt.Errorf(\"None failed, expected %v, got %v\", tt.expectedNone, resultNone)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestChunk(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tsize     int\n\t\texpected [][]interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal chunks\",\n\t\t\tinput:    []interface{}{1, 2, 3, 4, 5},\n\t\t\tsize:     2,\n\t\t\texpected: [][]interface{}{{1, 2}, {3, 4}, {5}},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tsize:     2,\n\t\t\texpected: [][]interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"chunk size equals length\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tsize:     3,\n\t\t\texpected: [][]interface{}{{1, 2, 3}},\n\t\t},\n\t\t{\n\t\t\tname:     \"chunk size larger than length\",\n\t\t\tinput:    []interface{}{1, 2},\n\t\t\tsize:     3,\n\t\t\texpected: [][]interface{}{{1, 2}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Chunk(tt.input, tt.size)\n\t\t\tif !equalNestedSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Chunk failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       []interface{}\n\t\tfn          func(interface{}) bool\n\t\texpected    interface{}\n\t\tshouldFound bool\n\t}{\n\t\t{\n\t\t\tname:        \"find first number greater than 2\",\n\t\t\tinput:       []interface{}{1, 2, 3, 4},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 2 },\n\t\t\texpected:    3,\n\t\t\tshouldFound: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"empty slice\",\n\t\t\tinput:       []interface{}{},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 2 },\n\t\t\texpected:    nil,\n\t\t\tshouldFound: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"no match\",\n\t\t\tinput:       []interface{}{1, 2},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 10 },\n\t\t\texpected:    nil,\n\t\t\tshouldFound: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, found := Find(tt.input, tt.fn)\n\t\t\tif found != tt.shouldFound {\n\t\t\t\tt.Errorf(\"Find failed, expected found=%v, got found=%v\", tt.shouldFound, found)\n\t\t\t}\n\t\t\tif found && result != tt.expected {\n\t\t\t\tt.Errorf(\"Find failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal sequence\",\n\t\t\tinput:    []interface{}{1, 2, 3, 4},\n\t\t\texpected: []interface{}{4, 3, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []interface{}{1},\n\t\t\texpected: []interface{}{1},\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed types\",\n\t\t\tinput:    []interface{}{1, \"a\", true, 2.5},\n\t\t\texpected: []interface{}{2.5, true, \"a\", 1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Reverse(tt.input)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Reverse failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestZipUnzip(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\ta           []interface{}\n\t\tb           []interface{}\n\t\texpectedZip [][2]interface{}\n\t\texpectedA   []interface{}\n\t\texpectedB   []interface{}\n\t}{\n\t\t{\n\t\t\tname:        \"normal case\",\n\t\t\ta:           []interface{}{1, 2, 3},\n\t\t\tb:           []interface{}{\"a\", \"b\", \"c\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}, {2, \"b\"}, {3, \"c\"}},\n\t\t\texpectedA:   []interface{}{1, 2, 3},\n\t\t\texpectedB:   []interface{}{\"a\", \"b\", \"c\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"empty slices\",\n\t\t\ta:           []interface{}{},\n\t\t\tb:           []interface{}{},\n\t\t\texpectedZip: [][2]interface{}{},\n\t\t\texpectedA:   []interface{}{},\n\t\t\texpectedB:   []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:        \"different lengths - a shorter\",\n\t\t\ta:           []interface{}{1, 2},\n\t\t\tb:           []interface{}{\"a\", \"b\", \"c\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}, {2, \"b\"}},\n\t\t\texpectedA:   []interface{}{1, 2},\n\t\t\texpectedB:   []interface{}{\"a\", \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"different lengths - b shorter\",\n\t\t\ta:           []interface{}{1, 2, 3},\n\t\t\tb:           []interface{}{\"a\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}},\n\t\t\texpectedA:   []interface{}{1},\n\t\t\texpectedB:   []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"mixed types\",\n\t\t\ta:           []interface{}{1, true, \"x\"},\n\t\t\tb:           []interface{}{2.5, false, \"y\"},\n\t\t\texpectedZip: [][2]interface{}{{1, 2.5}, {true, false}, {\"x\", \"y\"}},\n\t\t\texpectedA:   []interface{}{1, true, \"x\"},\n\t\t\texpectedB:   []interface{}{2.5, false, \"y\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tzipped := Zip(tt.a, tt.b)\n\t\t\tif len(zipped) != len(tt.expectedZip) {\n\t\t\t\tt.Errorf(\"Zip failed, expected length %v, got %v\", len(tt.expectedZip), len(zipped))\n\t\t\t}\n\t\t\tfor i, pair := range zipped {\n\t\t\t\tif pair[0] != tt.expectedZip[i][0] || pair[1] != tt.expectedZip[i][1] {\n\t\t\t\t\tt.Errorf(\"Zip failed at index %d, expected %v, got %v\", i, tt.expectedZip[i], pair)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tunzippedA, unzippedB := Unzip(zipped)\n\t\t\tif !equalSlices(unzippedA, tt.expectedA) {\n\t\t\t\tt.Errorf(\"Unzip failed for slice A, expected %v, got %v\", tt.expectedA, unzippedA)\n\t\t\t}\n\t\t\tif !equalSlices(unzippedB, tt.expectedB) {\n\t\t\t\tt.Errorf(\"Unzip failed for slice B, expected %v, got %v\", tt.expectedB, unzippedB)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGroupBy(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) interface{}\n\t\texpected map[interface{}][]interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"group by even/odd\",\n\t\t\tinput: []interface{}{1, 2, 3, 4, 5, 6},\n\t\t\tfn:    func(v interface{}) interface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t0: {2, 4, 6},\n\t\t\t\t1: {1, 3, 5},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(v interface{}) inte\t\t},\n\t\t{\n\t\t\tname:     \"all matches\",\n\t\t\tinput:    []interface{}{2, 4, 6},\n\t\t\tfn:       func(v interface{}) bool { return v.(int)%2 == 0 },\n\t\t\texpected: []interface{}{2, 4, 6},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Filter(tt.input, tt.fn)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Filter failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReduce(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}, interface{}) interface{}\n\t\tinitial  interface{}\n\t\texpected interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"sum numbers\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(int) + b.(int) },\n\t\t\tinitial:  0,\n\t\t\texpected: 6,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(int) + b.(int) },\n\t\t\tinitial:  0,\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tname:     \"concatenate strings\",\n\t\t\tinput:    []interface{}{\"a\", \"b\", \"c\"},\n\t\t\tfn:       func(a, b interface{}) interface{} { return a.(string) + b.(string) },\n\t\t\tinitial:  \"\",\n\t\t\texpected: \"abc\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Reduce(tt.input, tt.fn, tt.initial)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Reduce failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFlatMap(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"split words into chars\",\n\t\t\tinput: []interface{}{\"go\", \"fn\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tchars := []interface{}{}\n\t\t\t\tfor _, c := range word.(string) {\n\t\t\t\t\tchars = append(chars, string(c))\n\t\t\t\t}\n\t\t\t\treturn chars\n\t\t\t},\n\t\t\texpected: []interface{}{\"g\", \"o\", \"f\", \"n\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty string handling\",\n\t\t\tinput: []interface{}{\"\", \"a\", \"\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tchars := []interface{}{}\n\t\t\t\tfor _, c := range word.(string) {\n\t\t\t\t\tchars = append(chars, string(c))\n\t\t\t\t}\n\t\t\t\treturn chars\n\t\t\t},\n\t\t\texpected: []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"nil handling\",\n\t\t\tinput: []interface{}{nil, \"a\", nil},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\tif word == nil {\n\t\t\t\t\treturn []interface{}{}\n\t\t\t\t}\n\t\t\t\treturn []interface{}{word}\n\t\t\t},\n\t\t\texpected: []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:  \"empty slice result\",\n\t\t\tinput: []interface{}{\"\", \"\", \"\"},\n\t\t\tfn: func(word interface{}) interface{} {\n\t\t\t\treturn []interface{}{}\n\t\t\t},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"nested array flattening\",\n\t\t\tinput: []interface{}{1, 2, 3},\n\t\t\tfn: func(n interface{}) interface{} {\n\t\t\t\treturn []interface{}{n, n}\n\t\t\t},\n\t\t\texpected: []interface{}{1, 1, 2, 2, 3, 3},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := FlatMap(tt.input, tt.fn)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"FlatMap failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAllAnyNone(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []interface{}\n\t\tfn           func(interface{}) bool\n\t\texpectedAll  bool\n\t\texpectedAny  bool\n\t\texpectedNone bool\n\t}{\n\t\t{\n\t\t\tname:         \"all even numbers\",\n\t\t\tinput:        []interface{}{2, 4, 6, 8},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  true,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"no even numbers\",\n\t\t\tinput:        []interface{}{1, 3, 5, 7},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  false,\n\t\t\texpectedAny:  false,\n\t\t\texpectedNone: true,\n\t\t},\n\t\t{\n\t\t\tname:         \"mixed even/odd numbers\",\n\t\t\tinput:        []interface{}{1, 2, 3, 4},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  false,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t\t{\n\t\t\tname:         \"empty slice\",\n\t\t\tinput:        []interface{}{},\n\t\t\tfn:           func(x interface{}) bool { return x.(int)%2 == 0 },\n\t\t\texpectedAll:  true,  // vacuously true\n\t\t\texpectedAny:  false, // vacuously false\n\t\t\texpectedNone: true,  // vacuously true\n\t\t},\n\t\t{\n\t\t\tname:         \"nil predicate handling\",\n\t\t\tinput:        []interface{}{nil, nil, nil},\n\t\t\tfn:           func(x interface{}) bool { return x == nil },\n\t\t\texpectedAll:  true,\n\t\t\texpectedAny:  true,\n\t\t\texpectedNone: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresultAll := All(tt.input, tt.fn)\n\t\t\tif resultAll != tt.expectedAll {\n\t\t\t\tt.Errorf(\"All failed, expected %v, got %v\", tt.expectedAll, resultAll)\n\t\t\t}\n\n\t\t\tresultAny := Any(tt.input, tt.fn)\n\t\t\tif resultAny != tt.expectedAny {\n\t\t\t\tt.Errorf(\"Any failed, expected %v, got %v\", tt.expectedAny, resultAny)\n\t\t\t}\n\n\t\t\tresultNone := None(tt.input, tt.fn)\n\t\t\tif resultNone != tt.expectedNone {\n\t\t\t\tt.Errorf(\"None failed, expected %v, got %v\", tt.expectedNone, resultNone)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestChunk(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tsize     int\n\t\texpected [][]interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal chunks\",\n\t\t\tinput:    []interface{}{1, 2, 3, 4, 5},\n\t\t\tsize:     2,\n\t\t\texpected: [][]interface{}{{1, 2}, {3, 4}, {5}},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tsize:     2,\n\t\t\texpected: [][]interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"chunk size equals length\",\n\t\t\tinput:    []interface{}{1, 2, 3},\n\t\t\tsize:     3,\n\t\t\texpected: [][]interface{}{{1, 2, 3}},\n\t\t},\n\t\t{\n\t\t\tname:     \"chunk size larger than length\",\n\t\t\tinput:    []interface{}{1, 2},\n\t\t\tsize:     3,\n\t\t\texpected: [][]interface{}{{1, 2}},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Chunk(tt.input, tt.size)\n\t\t\tif !equalNestedSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Chunk failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFind(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       []interface{}\n\t\tfn          func(interface{}) bool\n\t\texpected    interface{}\n\t\tshouldFound bool\n\t}{\n\t\t{\n\t\t\tname:        \"find first number greater than 2\",\n\t\t\tinput:       []interface{}{1, 2, 3, 4},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 2 },\n\t\t\texpected:    3,\n\t\t\tshouldFound: true,\n\t\t},\n\t\t{\n\t\t\tname:        \"empty slice\",\n\t\t\tinput:       []interface{}{},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 2 },\n\t\t\texpected:    nil,\n\t\t\tshouldFound: false,\n\t\t},\n\t\t{\n\t\t\tname:        \"no match\",\n\t\t\tinput:       []interface{}{1, 2},\n\t\t\tfn:          func(v interface{}) bool { return v.(int) > 10 },\n\t\t\texpected:    nil,\n\t\t\tshouldFound: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult, found := Find(tt.input, tt.fn)\n\t\t\tif found != tt.shouldFound {\n\t\t\t\tt.Errorf(\"Find failed, expected found=%v, got found=%v\", tt.shouldFound, found)\n\t\t\t}\n\t\t\tif found && result != tt.expected {\n\t\t\t\tt.Errorf(\"Find failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal sequence\",\n\t\t\tinput:    []interface{}{1, 2, 3, 4},\n\t\t\texpected: []interface{}{4, 3, 2, 1},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element\",\n\t\t\tinput:    []interface{}{1},\n\t\t\texpected: []interface{}{1},\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed types\",\n\t\t\tinput:    []interface{}{1, \"a\", true, 2.5},\n\t\t\texpected: []interface{}{2.5, true, \"a\", 1},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Reverse(tt.input)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Reverse failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestZipUnzip(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\ta           []interface{}\n\t\tb           []interface{}\n\t\texpectedZip [][2]interface{}\n\t\texpectedA   []interface{}\n\t\texpectedB   []interface{}\n\t}{\n\t\t{\n\t\t\tname:        \"normal case\",\n\t\t\ta:           []interface{}{1, 2, 3},\n\t\t\tb:           []interface{}{\"a\", \"b\", \"c\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}, {2, \"b\"}, {3, \"c\"}},\n\t\t\texpectedA:   []interface{}{1, 2, 3},\n\t\t\texpectedB:   []interface{}{\"a\", \"b\", \"c\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"empty slices\",\n\t\t\ta:           []interface{}{},\n\t\t\tb:           []interface{}{},\n\t\t\texpectedZip: [][2]interface{}{},\n\t\t\texpectedA:   []interface{}{},\n\t\t\texpectedB:   []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:        \"different lengths - a shorter\",\n\t\t\ta:           []interface{}{1, 2},\n\t\t\tb:           []interface{}{\"a\", \"b\", \"c\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}, {2, \"b\"}},\n\t\t\texpectedA:   []interface{}{1, 2},\n\t\t\texpectedB:   []interface{}{\"a\", \"b\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"different lengths - b shorter\",\n\t\t\ta:           []interface{}{1, 2, 3},\n\t\t\tb:           []interface{}{\"a\"},\n\t\t\texpectedZip: [][2]interface{}{{1, \"a\"}},\n\t\t\texpectedA:   []interface{}{1},\n\t\t\texpectedB:   []interface{}{\"a\"},\n\t\t},\n\t\t{\n\t\t\tname:        \"mixed types\",\n\t\t\ta:           []interface{}{1, true, \"x\"},\n\t\t\tb:           []interface{}{2.5, false, \"y\"},\n\t\t\texpectedZip: [][2]interface{}{{1, 2.5}, {true, false}, {\"x\", \"y\"}},\n\t\t\texpectedA:   []interface{}{1, true, \"x\"},\n\t\t\texpectedB:   []interface{}{2.5, false, \"y\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tzipped := Zip(tt.a, tt.b)\n\t\t\tif len(zipped) != len(tt.expectedZip) {\n\t\t\t\tt.Errorf(\"Zip failed, expected length %v, got %v\", len(tt.expectedZip), len(zipped))\n\t\t\t}\n\t\t\tfor i, pair := range zipped {\n\t\t\t\tif pair[0] != tt.expectedZip[i][0] || pair[1] != tt.expectedZip[i][1] {\n\t\t\t\t\tt.Errorf(\"Zip failed at index %d, expected %v, got %v\", i, tt.expectedZip[i], pair)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tunzippedA, unzippedB := Unzip(zipped)\n\t\t\tif !equalSlices(unzippedA, tt.expectedA) {\n\t\t\t\tt.Errorf(\"Unzip failed for slice A, expected %v, got %v\", tt.expectedA, unzippedA)\n\t\t\t}\n\t\t\tif !equalSlices(unzippedB, tt.expectedB) {\n\t\t\t\tt.Errorf(\"Unzip failed for slice B, expected %v, got %v\", tt.expectedB, unzippedB)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGroupBy(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []interface{}\n\t\tfn       func(interface{}) interface{}\n\t\texpected map[interface{}][]interface{}\n\t}{\n\t\t{\n\t\t\tname:  \"group by even/odd\",\n\t\t\tinput: []interface{}{1, 2, 3, 4, 5, 6},\n\t\t\tfn:    func(v interface{}) interface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t0: {2, 4, 6},\n\t\t\t\t1: {1, 3, 5},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tinput:    []interface{}{},\n\t\t\tfn:       func(v interface{}) interface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"single group\",\n\t\t\tinput: []interface{}{2, 4, 6},\n\t\t\tfn:    func(v interface{}) interface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t0: {2, 4, 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"group by type\",\n\t\t\tinput: []interface{}{1, \"a\", 2, \"b\", true},\n\t\t\tfn: func(v interface{}) interface{} {\n\t\t\t\tswitch v.(type) {\n\t\t\t\tcase int:\n\t\t\t\t\treturn \"int\"\n\t\t\t\tcase string:\n\t\t\t\t\treturn \"string\"\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"other\"\n\t\t\t\t}\n\t\t\t},\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t\"int\":    {1, 2},\n\t\t\t\t\"string\": {\"a\", \"b\"},\n\t\t\t\t\"other\":  {true},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := GroupBy(tt.input, tt.fn)\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"GroupBy failed, expected %d groups, got %d\", len(tt.expected), len(result))\n\t\t\t}\n\t\t\tfor k, v := range tt.expected {\n\t\t\t\tif !equalSlices(result[k], v) {\n\t\t\t\t\tt.Errorf(\"GroupBy failed for key %v, expected %v, got %v\", k, v, result[k])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFlatten(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    [][]interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal nested slices\",\n\t\t\tinput:    [][]interface{}{{1, 2}, {3, 4}, {5}},\n\t\t\texpected: []interface{}{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty outer slice\",\n\t\t\tinput:    [][]interface{}{},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty inner slices\",\n\t\t\tinput:    [][]interface{}{{}, {}, {}},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed types\",\n\t\t\tinput:    [][]interface{}{{1, \"a\"}, {true, 2.5}, {nil}},\n\t\t\texpected: []interface{}{1, \"a\", true, 2.5, nil},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slices\",\n\t\t\tinput:    [][]interface{}{{1}, {2}, {3}},\n\t\t\texpected: []interface{}{1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, frface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:  \"single group\",\n\t\t\tinput: []interface{}{2, 4, 6},\n\t\t\tfn:    func(v interface{}) interface{} { return v.(int) % 2 },\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t0: {2, 4, 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:  \"group by type\",\n\t\t\tinput: []interface{}{1, \"a\", 2, \"b\", true},\n\t\t\tfn: func(v interface{}) interface{} {\n\t\t\t\tswitch v.(type) {\n\t\t\t\tcase int:\n\t\t\t\t\treturn \"int\"\n\t\t\t\tcase string:\n\t\t\t\t\treturn \"string\"\n\t\t\t\tdefault:\n\t\t\t\t\treturn \"other\"\n\t\t\t\t}\n\t\t\t},\n\t\t\texpected: map[interface{}][]interface{}{\n\t\t\t\t\"int\":    {1, 2},\n\t\t\t\t\"string\": {\"a\", \"b\"},\n\t\t\t\t\"other\":  {true},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := GroupBy(tt.input, tt.fn)\n\t\t\tif len(result) != len(tt.expected) {\n\t\t\t\tt.Errorf(\"GroupBy failed, expected %d groups, got %d\", len(tt.expected), len(result))\n\t\t\t}\n\t\t\tfor k, v := range tt.expected {\n\t\t\t\tif !equalSlices(result[k], v) {\n\t\t\t\t\tt.Errorf(\"GroupBy failed for key %v, expected %v, got %v\", k, v, result[k])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestFlatten(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    [][]interface{}\n\t\texpected []interface{}\n\t}{\n\t\t{\n\t\t\tname:     \"normal nested slices\",\n\t\t\tinput:    [][]interface{}{{1, 2}, {3, 4}, {5}},\n\t\t\texpected: []interface{}{1, 2, 3, 4, 5},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty outer slice\",\n\t\t\tinput:    [][]interface{}{},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"empty inner slices\",\n\t\t\tinput:    [][]interface{}{{}, {}, {}},\n\t\t\texpected: []interface{}{},\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed types\",\n\t\t\tinput:    [][]interface{}{{1, \"a\"}, {true, 2.5}, {nil}},\n\t\t\texpected: []interface{}{1, \"a\", true, 2.5, nil},\n\t\t},\n\t\t{\n\t\t\tname:     \"single element slices\",\n\t\t\tinput:    [][]interface{}{{1}, {2}, {3}},\n\t\t\texpected: []interface{}{1, 2, 3},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := Flatten(tt.input)\n\t\t\tif !equalSlices(result, tt.expected) {\n\t\t\t\tt.Errorf(\"Flatten failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestContains(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tslice    []interface{}\n\t\titem     interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"contains integer\",\n\t\t\tslice:    []interface{}{1, 2, 3},\n\t\t\titem:     2,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"does not contain integer\",\n\t\t\tslice:    []interface{}{1, 2, 3},\n\t\t\titem:     4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"contains string\",\n\t\t\tslice:    []interface{}{\"a\", \"b\", \"c\"},\n\t\t\titem:     \"b\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"empty slice\",\n\t\t\tslice:    []interface{}{},\n\t\t\titem:     1,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"contains nil\",\n\t\t\tslice:    []interface{}{1, nil, 3},\n\t\t\titem:     nil,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"mixed types\",\n\t\t\tslice:    []interface{}{1, \"a\", true},\n\t\t\titem:     true,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := contains(tt.slice, tt.item)\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"contains failed, expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Helper function for testing\nfunc contains(slice []interface{}, item interface{}) bool {\n\tfor _, v := range slice {\n\t\tif v == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Helper functions for comparing slices\nfunc equalSlices(a, b []interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc equalNestedSlices(a, b [][]interface{}) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif !equalSlices(a[i], b[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n")
