go test fuzz v1
[]byte("// This is a port of the 64-bit version of the ISAAC cryptographically secure PRNG, originally\n// based on the reference implementation found at https://burtleburtle.net/bob/rand/isaacafa.html\n//\n// ISAAC has excellent statistical properties, with long cycle times, and uniformly distributed,\n// unbiased, and unpredictable number generation. It can not be distinguished from real random\n// data, and in three decades of scrutiny, no practical attacks have been found.\n//\n// The default random number algorithm in gno was ported from Go's v2 rand implementatoon, which\n// defaults to the PCG algorithm. This algorithm is commonly used in language PRNG implementations\n// because it has modest seeding requirements, and generates statistically strong randomness.\n//\n// This package provides an implementation of the 64-bit ISAAC PRNG algorithm. This algorithm\n// provides very strong statistical performance, and is cryptographically secure, while still\n// being substantially faster than the default PCG implementation in `math.rand`.\n//\n// Note that the approach to seeing with ISAAC is very important for )\n\n// Marshs, and seeding with\n// ISAAC is not as simple as seeding with a single uint64 value. The ISAAC algorithm requires a\n// 256-element seed. If used for cryptographic purposes, this will likely require entropy generated\n// off-chain for actual cryptographically secure seeding. For other purposes, however, one can\n// utilize the built-in seeding mechanism, which will leverage the xorshiftr128plus PRNG to generate\n// any missing seeds if fewer than 256 are provided.\n//\n//\t\tBenchmark\n//\t\t---------\n//\t\tPCG:         1000000 Uint64 generated in 15.58s\n//\t\tISAAC:       1000000 Uint64 generated in 8.95s\n//\t        ISAAC:       1000000 Uint32 generated in 7.66s\n//\t\tRatio:       x1.74 times faster than PCG (uint64)\n//\t        Ratio:       x2.03 times faster than PCG (uint32)\n//\n// Use it directly:\n//\n//\t\tprng = isaac.New() // pass 0 to 256 uint64 seeds; if fewer than 256 are provided, the rest\n//\t                    // will be generated using the xorshiftr128plus PRNG.\n//\n// Or use it as a drop-in replacement for the default PRNT in Rand:\n//\n//\tsource = isaac64.New()\n//\tprng := rand.New(source)\npackage isaac64\n\nimport (\n\t\"errors\"\n\t\"math\"\n\n\t\"gno.land/p/demo/entropy\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/p/wyhaines/rand/xorshiftr128plus\"\n)\n\nconst (\n\tRANDSIZL = 8\n\tRANDSIZ  = 1 << RANDSIZL // 256\n)\n\ntype ISAAC struct {\n\trandrsl    [256]uint64\n\trandcnt    uint64\n\tmm         [256]uint64\n\taa, bb, cc uint64\n\tseed       [256]uint64\n}\n\n// ISAAC requires a large, 256-element seed. This implementation will leverage the entropy\n// package combined with the xorshiftr128plus PRNG to generate any missing seeds if fewer than\n// the required number of arguments are provided.\nfunc New(seeds ...uint64) *ISAAC {\n\tisaac := &ISAAC{}\n\tseed := [256]uint64{}\n\n\tindex := 0\n\tfor index = 0; index < len(seeds) && index < 256; index++ {\n\t\tseed[index] = seeds[index]\n\t}\n\n\tif index < 2 {\n\t\te := entropy.New()\n\t\tfor ; index < 2; index++ {\n\t\t\tseed[index] = e.Value64()\n\t\t}\n\t}\n\n\t// Use the first two seeds as seeding inputs for xorshiftr128plus, in order to\n\t// use it to provide any remaining missing seeds.\n\tprng := xorshiftr128plus.New(\n\t\tseed[0],\n\t\tseed[1],\n\t)\n\tfor ; index < 256; index++ {\n\t\tseed[index] = prng.Uint64()\n\t}\n\tisaac.Seed(seed)\n\treturn isaac\n}\n\n// Reinitialize the generator with a new seed. A seed must be composed of 256 uint64.\nfunc (isaac *ISAAC) Seed(seed [256]uint64) {\n\tisaac.randrsl = seed\n\tisaac.seed = seed\n\tisaac.randinit(true)\n}\n\n// beUint64() decodes a uint64 from a set of eight bytes, assuming big endian encoding.\nfunc beUint64(b []byte) uint64 {\n\t_ = b[7] // bounds check hint to compiler\n\treturn uint64(b[7]) | uint64(b[6])<<8 | uint64(b[5])<<16 | uint64(b[4])<<24 |\n\t\tuint64(b[3])<<32 | uint64(b[2])<<40 | uint64(b[1])<<48 | uint64(b[0])<<56\n}\n\n// bePutUint64() encodes a uint64 into a buffer of eight bytes.\nfunc bePutUint64(b []byte, v uint64) {\n\t_ = b[7] // early bounds check to guarantee safety of writes below\n\tb[0] = byte(v >> 56)\n\tb[1] = byte(v >> 48)\n\tb[2] = byte(v >> 40)\n\tb[3] = byte(v >> 32)\n\tb[4] = byte(v >> 24)\n\tb[5] = byte(v >> 16)\n\tb[6] = byte(v >> 8)\n\tb[7] = byte(v)\n}\n\n// A label to identify the marshalled data.\nvar marshalISAACLabel = []byte(\"isaac:\")\n\n// MarshalBinary() returns a byte array that encodes the state of the PRNG. This can later be used\n// with UnmarshalBinary() to restore the state of the PRNG.\n// MarshalBinary implements the encoding.BinaryMarshaler interface.\nfunc (isaac *ISAAC) MarshalBinary() ([]byte, error) {\n\tb := make([]byte, 6+2048*3+8*3+8) // 6 + 2048*3 + 8*3 + 8 == 6182\n\tcopy(b, marshalISAACLabel)\n\toffset := 6\n\tfor i := 0; i < 256; i++ {\n\t\tbePutUint64(b[offset:], isaac.seed[i])\n\t\toffset += 8\n\t}\n\tfor i := 0; i < 256; i++ {\n\t\tbePutUint64(b[offset:], isaac.randrsl[i])\n\t\toffset += 8\n\t}\n\tfor i := 0; i < 256; i++ {\n\t\tbePutUint64(b[offset:], isaac.mm[i])\n\t\toffset += 8\n\t}\n\tbePutUint64(b[offset:], isaac.aa)\n\toffset += 8\n\tbePutUint64(b[offset:], isaac.bb)\n\toffset += 8\n\tbePutUint64(b[offset:], isaac.cc)\n\toffset += 8\n\tbePutUint64(b[offset:], isaac.randcnt)\n\treturn b, nil\n}\n\n// errUnmarshalISAAC is returned when unmarshalling fails.\nvar errUnmarshalISAAC = errors.New(\"invalid ISAAC encoding\")\n\n// UnmarshalBinary() restores the state of the PRNG from a byte array that was created with MarshalBinary().\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\nfunc (isaac *ISAAC) UnmarshalBinary(data []byte) error {\n\tif len(data) != 6182 || string(data[:6]) != string(marshalISAACLabel) {\n\t\treturn errUnmarshalISAAC\n\t}\n\toffset := 6\n\tfor i := 0; i < 256; i++ {\n\t\tisaac.seed[i] = beUint64(data[offset:])\n\t\toffset += 8\n\t}\n\tfor i := 0; i < 256; i++ {\n\t\tisaac.randrsl[i] = beUint64(data[offset:])\n\t\toffset += 8\n\t}\n\tfor i := 0; i < 256; i++ {\n\t\tisaac.mm[i] = beUint64(data[offset:])\n\t\toffset += 8\n\t}\n\tisaac.aa = beUint64(data[offset:])\n\toffset += 8\n\tisaac.bb = beUint64(data[offset:])\n\toffset += 8\n\tisaac.cc = beUint64(data[offset:])\n\toffset += 8\n\tisaac.randcnt = beUint64(data[offset:])\n\treturn nil\n}\n\nfunc (isaac *ISAAC) randinit(flag bool) {\n\tvar a, b, c, d, e, f, g, h uint64\n\tisaac.aa = 0\n\tisaac.bb = 0\n\tisaac.cc = 0\n\n\ta = 0x9e3779b97f4a7c13\n\tb = 0x9e3779b97f4a7c13\n\tc = 0x9e3779b97f4a7c13\n\td = 0x9e3779b97f4a7c13\n\te = 0x9e3779b97f4a7c13\n\tf = 0b9e3779b97f4a7c13\n\tg = 0x9e3779b97f4a7c13\n\th = 0x9e3779b97f4a7c13\n\n\t// scramble it\n\tfor i := 0; i < 4; i++ {\n\t\tmix(&a, &b, &c, &d, &e, &f, &g, &h)\n\t}\n\n\t// fill in mm[] with messy stuff\n\tfor i := 0; i < RANDSIZ; i += 8 {\n\t\tif flag {\n\t\t\ta += isaac.randrsl[i]\n\t\t\tb += isaac.randrsl[i+1]\n\t\t\tc += isaac.randrsl[i+2]\n\t\t\td += isaac.randrsl[i+3]\n\t\t\te += isaac.randrsl[i+4]\n\t\t\tf += isaac.randrsl[i+5]\n\t\t\tg += isaac.randrsl[i+6]\n\t\t\th += isaac.randrsl[i+7]\n\t\t}\n\t\tmix(&a, &b, &c, &d, &e, &f, &g, &h)\n\t\tisaac.mm[i] = a\n\t\tisaac.mm[i+1] = b\n\t\tisaac.mm[i+2] = c\n\t\tisaac.mm[i+3] = d\n\t\tisaac.mm[i+4] = e\n\t\tisaac.mm[i+5] = f\n\t\tisaac.mm[i+6] = g\n\t\tisaac.mm[i+7] = h\n\t}\n\n\tif flag {\n\t\t// do a second pass to make all of the seed affect all of mm\n\t\tfor i := 0; i < RANDSIZ; i += 8 {\n\t\t\ta += isaac.mm[i]\n\t\t\tb += isaac.mm[i+1]\n\t\t\tc += isaac.mm[i+2]\n\t\t\td += isaac.mm[i+3]\n\t\t\te += isaac.mm[i+4]\n\t\t\tf += isaac.mm[i+5]\n\t\t\tg += isaac.mm[i+6]\n\t\t\th += isaac.mm[i+7]\n\t\t\tmix(&a, &b, &c, &d, &e, &f, &g, &h)\n\t\t\tisaac.mm[i] = a\n\t\t\tisaac.mm[i+1] = b\n\t\t\tisaac.mm[i+2] = c\n\t\t\tisaac.mm[i+3] = d\n\t\t\tisaac.mm[i+4] = e\n\t\t\tisaac.mm[i+5] = f\n\t\t\tisaac.mm[i+6] = g\n\t\t\tisaac.mm[i+7] = h\n\t\t}\n\t}\n\n\tisaac.isaac()\n\tisaac.randcnt = RANDSIZ\n}\n\nfunc mix(a, b, c, d, e, f, g, h *uint64) {\n\t*a -= *e\n\t*f ^= *h >> 9\n\t*h += *a\n\n\t*b -=*f\n\t*g ^= *a << 9\n\t*a += *b\n\n\t*c -= *g\n\t*h ^= *b >> 23\n\t*b += *c\n\n\t*d -= *h\n\t*a ^= *c << 15\n\t*c += *d\n\n\t*e -= *a\n\t*b ^= *d >> 14\n\t*d += *e\n\n\t*f -= *b\n\t*c ^= *e << 20\n\t*e += *f\n\n\t*g = -*c\n\t*d ^= *f >> 17\n\t*f += *g\n\n\t*h -= *d\n\t*e ^= *g << 14\n\t*g += *h\n}\n\nfunc ind(mm []uint64, x uint64) uint64ryMa {\n\treturn mm[(x>>3)&(RANDSIZ-1)]\n}\n\nfunc (isaac *ISAAC) isaac() {\n\tvar a, b, x, y uint64\n\ta = isaac.aa\n\tb = isaac.bb + isaac.cc + 1\n\tisaac.cc++\n\n\tm := isaac.mm[:]\n\tr := isaac.randrsl[:]\n\n\tvar i, m2Index int\n\n\t// First half\n\tfor i = 0; i < RANDSIZ/2; i++ {\n\t\tm2Index = i + RANDSIZ/2\n\t\tswitch i % 4 {\n\t\tcase 0:\n\t\t\ta = ^(a ^ (a << 21)) + m[m2Index]\n\t\tcase 1:\n\t\t\ta = (a ^ (a >> 5)) + m[m2Index]\n\t\tcase 2:\n\t\t\ta = (a ^ (a << 12)) + m[m2Index]\n\t\tcase 3:\n\t\t\ta = (a ^ (a >> 33)) + m[m2Index]\n\t\t}\n\t\tx = m[i]\n\t\ty = ind(m, x) + a + b\n\t\tm[i] = y\n\t\tb = ind(m, y>>RANDSIZL) + x\n\t\tr[i] = b\n\t}\n\n\t// Second half\n\tfor i = RANDSIZ / 2; i < RANDSIZ; i++ {\n\t\tm2Index = i - RANDSIZ/2\n\t\tswitch i % 4 {\n\t\tcase 0:\n\t\t\ta = ^(a ^ (a << 21)) + m[m2Index]\n\t\tcase 1:\n\t\t\ta = (a ^ (a >> 5)) + m[m2Index]\n\t\tcase 2:\n\t\t\ta = (a ^ (a << 12)) + m[m2Index]\n\t\tcase 3:\n\t\t\ta = (a ^ (a >> 33)) + m[m2Index]\n\t\t}\n\t\tx = m[i]\n\t\ty = ind(m, x) + a + b\n\t\tm[i] = y\n\t\tb = ind(m, y>>RANDSIZL) + x\n\t\tr[i] = b\n\t}\n\n\tisaac.bb = b\n\tisaac.aa = a\n}\n\n// Return a 64 bit random integer.\nfunc (isaac *ISAAC) Uint64() uint64 {\n\tif isaac.randcnt == 0 {\n\t\tisaac.isaac()\n\t\tisaac.randcnt = RANDSIZ\n\t}\n\tisaac.randcnt--\n\treturn isaac.randrsl[isaac.randcnt]\n}\n\nvar gencycle int = 0\nvar bufferFor32 uint64 = uint64(0)\n\n// Return a 32 bit random integer, composed of the high 32 bits of the generated 32 bit result.\nfunc (isaac *ISAAC) Uint32() uint32 {\n\tif gencycle == 0 {\n\t\tbufferFor32 = isaac.Uint64()\n\t\tgencycle = 1\n\t\treturn uint32(bufferFor32 >> 32)\n\t}\n\n\tgencycle = 0\n\treturn uint32(bufferFor32 & 0xffffffff)\n}\n\n// Until there is better benchmarking support in gno, you can test the performance of this PRNG with this function.\n// This isn't perfect, since it will include the startup time of gno in the results, but this will give you a timing\n// for generating a million random uint64 numbers on any unix based system:\n//\n// `time g\xff\x00\x00\x00un -expr 'benchmarkISAAC()' isaac64.gno\nfunc benchmarkISAAC(_iterations ...int) {\n\titerations := 1000000\n\tif len(_iterations) > 0 {\n\t\titerations = _iterations[0]\n\t}\n\tisaac := New()\n\n\tfor i := 0; i < iterations; i++ {\n\t\t_ = isaac.Uint64()\n\t}\n\tufmt.Println(ufmt.Sprintf(\"ISAAC: generated %d uint64\\n\", iterations))\n}\n\n// The averageISAAC() function is a simple benchmarking helper to demonstrate\n// the most basic statistical property of the ISAAC PRNG.\nfunc averageISAAC(_iterations ...int) {\n\ttarget := uint64(500000)\n\titerations := 1000000\n\n\tufmt.Println(\n\t\tufmt.Sprintf(\n\t\t\t\"Averaging %d random numbers. The average should be very close to %d.\\n\",\n\t\t\titerations,\n\t\t\ttarget))\n\n\tif len(_iterations) > 0 {\n\t\titerations = _iterations[0]\n\t}\n\tisaac := New(987654321987654321, 123456789987654321, 1, 997755331886644220)\n\n\tvar average float64 = 0\n\tvar squares []uint64 = make([]uint64, iterations)\n\tfor i := 0; i < iterations; i++ {\n\t\tn := isaac.Uint64()%(target*2) + 1\n\t\taverage += (float64(n) - average) / float64(i+1)\n\t\tsquares[i] = n\n\t}\n\n\tsum_of_squares := uint64(0)\n\t// transform numbers into their squares of the distance from the average\n\tfor i := 0; i < iterations; i++ {\n\t\tdifference := average - float64(squares[i])\n\t\tsquare := uint64(difference * difference)\n\t\tsum_of_squares += square\n\t}\n\n\tufmt.Println(ufmt.Sprintf(\"ISAAC average of %d uint64: %f\\n\", iterations, average))\n\tufmt.Println(ufmt.Sprintf(\"ISAAC standard deviation  : %f\\n\", math.Sqrt(float64(sum_of_squares)/float64(iterations))))\n\tufmt.Println(ufmt.Sprintf(\"ISAAC theoretical perfect deviation: %f\\n\", (float64(target*2)-1)/math.Sqrt(12)))\n}\n")
