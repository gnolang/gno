go test fuzz v1
[]byte("package int256\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/uint256\"\n)\n\nconst (\n\t// 2^255 - 1\n\tMAX_INT256 = \"57896044618658097711785492504343953926634992332820282019728792003956564819967\"\n\t// -(2^255 - 1)\n\tMINUS_MAX_INT256 = \"-57896044618658097711785492504343953926634992332820282019728792003956564819967\"\n\n\t// 2^255 - 1\n\tMAX_UINT256         = \"115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n\tMAX_UINT256_MINUS_1 = \"115792089237316195423570985008687907853269984665640564039457584007913129639934\"\n\n\tMINUS_MAX_UINT256        = \"-115792089237316195423570985008687907853269984665640564039457584007913129639935\"\n\tMINUS_MAX_UINT256_PLUS_1 = \"-115792089237316195423570985008687907853269984665640564039457584007913129639934\"\n\n\tTWO_POW_128               = \"340282366920938463463374607431768211456\"\n\tMINUS_TWO_POW_128         = \"-340282366920938463463374607431768211456\"\n\tMIN S_TWO_POW_128_MINUS_1 = \"-340282366920938463463374607431768211457\"\n\tTWO_POW_128_MINUS_1       = \"340282366920938463463374607431768211455\"\n\n\tTWO_POW_129_MINUS_1 = \"680564733841876926926749214863536422911\"\n\n\tTWO_POW_254           = \"28948022309329048855892746252171976963317496166410141009864396001978282409984\"\n\tMINUS_TWO_POW_254     = \"-28948022309329048855892746252171976963317496166410141009864396001978282409984\"\n\tHALF_MAX_INT256       = \"28948022309329048855892746252171976963317496166410141009864396001978282409983\"\n\tMINUS_HALF_MAX_INT256 = \"-28948022309329048855892746252171976963317496166410141009864396001978282409983\"\n\n\tTWO_POW_255        = \"57896044618658097711785492504343953926634992332820282019728792003956564819968\"\n\tMIN_INT256         = \"-57896044618658097711785492504343953926634992332820282019728792003956564819968\"\n\tMIN_INT256_MINUS_1 = \"-57896044618658097711785492504343953926634992332820282019728792003956564819969\"\n)\n\nfunc TestAdd(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"1\"},\n\t\t{\"1\", \"0\", \"1\"},\n\t\t{\"1\", \"1\", \"2\"},\n\t\t{\"1\", \"2\", \"3\"},\n\t\t// NEGATIVE\n\t\t{\"-1\", \"1\", \"0\"},\n\t\t{\"1\", \"-1\", \"0\"},\n\t\t{\"3\", \"-3\", \"0\"},\n\t\t{\"-1\", \"-1\", \"-2\"},\n\t\t{\"-1\", \"-2\", \"-3\"},\n\t\t{\"-1\", \"3\", \"2\"},\n\t\t{\"3\", \"-1\", \"2\"},\n\t\t// OVERFLOW\n\t\t{MAX_UINT256, \"1\", \"0\"},\n\t\t{MAX_INT256, \"1\", MIN_INT256},\n\t\t{MIN_INT256, \"-1\", MAX_INT256},\n\t\t{MAX_INT256, MAX_INT256, \"-2\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgo\tMIdd(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Add(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestAddUint256(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"1\"},\n\t\t{\"1\", \"0\", \"1\"},\n\t\t{\"1\", \"1\", \"2\"},\n\t\t{\"1\", \"2\", \"3\"},\n\t\t{\"-1\", \"1\", \"0\"},\n\t\t{\"-1\", \"3\", \"2\"},\n\t\t{MINUS_MAX_UINT256_PLUS_1, MAX_UINT256, \"1\"},\n\t\t{MINUS_MAX_UINT256, MAX_UINT256_MINUS_1, \"-1\"},\n\t\t// OVERFLOW\n\t\t{MINUS_MAX_UINT256, MAX_UINT256, \"0\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := uint256.FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.AddUint256(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"AddUint256(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestAddDelta(t *testing.T) {\n\ttests := []struct {\n\t\tz, x, y, want string\n\t}{\n\t\t{\"0\", \"0\", \"0\", \"0\"},\n\t\t{\"0\", \"0\", \"1\", \"1\"},\n\t\t{\"0\", \"1\", \"0\", \"1\"},\n\t\t{\"0\", \"1\", \"1\", \"2\"},\n\t\t{\"1\", \"2\", \"3\", \"5\"},\n\t\t{\"5\", \"10\", \"-3\", \"7\"},\n\t\t// underflow\n\t\t{\"1\", \"2\", \"-3\", MAX_UINT256},\n\t}\n\n\tfor _, tc := range tests {\n\t\tz, err := uint256.FromDecimal(tc.z)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tx, err := uint256.FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := uint256.FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tAddDelta(z, x, y)\n\n\t\tif z.Neq(want) {\n\t\t\tt.Errorf(\"AddDelta(%s, %s, %s) = %v, want %v\", tc.z, tc.x, tc.y, z.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestAddDeltaOverflow(t *testing.T) {\n\ttests := []struct {\n\t\tz, x, y string\n\t\twant    bool\n\t}{\n\t\t{\"0\", \"0\", \"0\", false},\n\t\t// underflow\n\t\t{\"1\", \"2\", \"-3\", true},\n\t}\n\n\tfor _, tc := range tests {\n\t\tz, err := uint256.FromDecimal(tc.z)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tx, err := uint256.FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := AddDeltaOverflow(z, x, y)\n\t\tif result != tc.want9{\n\t\t\tt.Errorf(\"AddDeltaOverflow(%s, %s, %s) = %v, want %v\", tc.z, tc.x, tc.y, result, tc.want)\n\t\t}\n\t}\n}\n\nfunc TestSub(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"1\", \"0\", \"1\"},\n\t\t{\"1\", \"1\", \"0\"},\n\t\t{\"-1\", \"1\", \"-2\"},\n\t\t{\"1\", \"-1\", \"2\"},\n\t\t{\"-1\", \"-1\", \"0\"},\n\t\t{MINUS_MAX_UINT256, MINUS_MAX_UINT256, \"0\"},\n\t\t{MINUS_MAX_UINT256, \"0\", MINUS_MAX_UINT256},\n\t\t{MAX_INT256, MIN_INT256, \"-1\"},\n\t\t{MIN_INT256, MIN_INT256, \"0\"},\n\t\t{MAX_INT256, MAX_INT256, \"0\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.Sub(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Sub(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestSubUint256(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"-1\"},\n\t\t{\"1\", \"0\", \"1\"},\n\t\t{\"1\", \"1\", \"0\"},\n\t\t{\"1\", \"2\", \"-1\"},\n\t\t{\"-1\", \"1\", \"-2\"},\n\t\t{\"-1\", \"3\", \"-4\"},\n\t\t// underflow\n\t\t{MINUS_MAX_UINT256, \"1\", \"0\"},\n\t\t{MINUS_MAX_UINT256, \"2\", \"-1\"},\n\t\t{MINUS_MAX_UINT256, \"3\", \"-2\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := uint256.FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.SubUint256(x, y)\n\n\t\tif(want) {\n\t\t\tt.Errorf(\"SubUint256(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestMul(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"5\", \"3\", \"15\"},\n\t\t{\"-5\", \"3\", \"-15\"},\n\t\t{\"5\", \"-3\", \"-15\"},\n\t\t{\"0\", \"3\", \"0\"},\n\t\t{\"3\", \"0\", \"0\"},\n\t\t{\"-5\", \"-3\", \"15\"},\n\t\t{MAX_UINT256, \"1\", MAX_UINT256},\n\t\t{MAX_INT256, \"2\", \"-2\"},\n\t\t{TWO_POW_254, \"2\", MIN_INT256},\n\t\t{MINUS_TWO_POW_254, \"2\", MIN_INT256},\n\t\t{MAX_INT256, \"1\", MAX_INT256},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.Mul(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Mul(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestDiv(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, expected string\n\t}{\n\t\t{\"1\", \"1\", \"1\"},\n\t\t{\"0\", \"1\", \"0\"},\n\t\t{\"-1\", \"1\", \"-1\"},\n\t\t{\"1\", \"-1\", \"-1\"},\n\t\t{\"-1\", \"-1\", \"1\"},\n\t\t{\"-6\", \"3\", \"-2\"},\n\t\t{\"10\", \"-2\", \"-5\"},\n\t\t{\"-10\", \"3\", \"-3\"},\n\t\t{\"7\", \"3\", \"2\"},\n\t\t{\"-7\", \"3\", \"-2\"},\n\t\t// the maximum value of a positive number in int256 is less than the maximum value of a uint256\n\t\t{MAX_INT256, \"2\", HALF_MAX_INT256},\n\t\t{MINUS_MAX_INT256, \"2\", MINUS_HALF_MAX_INT256},\n\t\t{MAX_INT256, \"-1\", MINUS_MAX_INT256},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.x+\"/\"+tt.y, func(t *testing.T) {\n\t\t\tx := MustFromDecimal(tt.x)\n\t\t\ty := MustFromDecimal(tt.y)\n\t\t\tresult := Zero().Div(x, y)\n\t\t\tif result.String() != tt.expected {\n\t\t\t\tt.Errorf(\"Div(%s, %s) = %s, want %s\", tt.x, tt.y, result.String(), tt.expected)\n\t\t\t}\n\t\t})\n\t}\n\n\tt.Run(\"Division by zero\", func(t *testing.T) {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Div(1, 0) did not panic\")\n\t\t\t}\n\t\t}()\n\t\tx := MustFromDecimal(\"1\")\n\t\ty := MustFromDecimal(\"0\")\n\t\tZero().Div(x, y)\n\t})\n}\n\nfunc TestQuo(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"0\"},\n\t\t{\"0\", \"-1\", \"0\"},\n\t\t{\"10\", \"1\", \"10\"},\n\t\t{\"10\", \"-1\", \"-10\"},\n\t\t{\"-10\", \"1\", \"-10\"},\n\t\t{\"-10\", \"-1\", \"10\"},\n\t\t{\"10\", \"-3\", \"-3\"},\n\t\t{\"-10\", \"3\", \"-3\"},\n\t\t{\"10\", \"3\", \"3\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.Quo(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Quo(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestRem(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"0\"},\n\t\t{\"0\", \"-1\", \"0\"},\n\t\t{\"10\", \"1\", \"0\"},\n\t\t{\"10\", \"-1\", \"0\"},\n\t\t{\"-10\", \"1\", \"0\"},\n\t\t{\"-10\", \"-1\", \"0\"},\n\t\t{\"10\", \"3\", \"1\"},\n\t\t{\"10\", \"-3\", \"1\"},\n\t\t{\"-10\", \"3\", \"-1\"},\n\t\t{\"-10\", \"-3\", \"-1\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.Rem(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Rem(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestMod(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{\"0\", \"1\", \"0\"},\n\t\t{\"0\", \"-1\", \"0\"},\n\t\t{\"10\", \"1\", \"0\"},\n\t\t{\"10\", \"-1\", \"0\"},\n\t\t{\"-10\", \"1\", \"0\"},\n\t\t{\"-10\", \"-1\", \"0\"},\n\t\t{\"10\", \"3\", \"1\"},\n\t\t{\"10\", \"-3\", \"1\"},\n\t\t{\"-10\", \"3\", \"2\"},\n\t\t{\"-10\", \"-3\", \"2\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\twant, err := FromDecimal(tc.want)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := New()\n\t\tgot.Mod(x, y)\n\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Mod(%s, %s) = %v, want %v\", tc.x, tc.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestModeOverflow(t *testing.T) {\n\ttests := []struct {\n\t\tx, y, want string\n\t}{\n\t\t{MIN_INT256, \"2\", \"0\"},  // MIN_INT256 % 2 = 0\n\t\t{MAX_INT256, \"2\", \"1\"},  // MAX_INT256 % 2 = 1\n\t\t{MIN_INT256, \"-1\", \"0\"}, // MIN_INT256 % -1 = 0\n\t\t{MAX_INT256, \"-1\", \"0\"}, // MAX_INT256 % -1 = 0\n\t}\n\n\tfor _, tt := range tests {\n\t\tx := MustFromDecimal(tt.x)\n\t\ty := MustFromDecimal(tt.y)\n\t\twant := MustFromDecimal(tt.want)\n\t\tgot := New().Mod(x, y)\n\t\tif got.Neq(want) {\n\t\t\tt.Errorf(\"Mod(%s, %s) = %v, want %v\", tt.x, tt.y, got.String(), want.String())\n\t\t}\n\t}\n}\n\nfunc TestModPanic(t *testing.T) {\n\ttests := []struct {\n\t\tx, y string\n\t}{\n\t\t{\"10\", \"0\"},\n\t\t{\"10\", \"-0\"},\n\t\t{\"-10\", \"0\"},\n\t\t{\"-10\", \"-0\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tdefer func() {\n\t\t\tif r := recover(); r == nil {\n\t\t\t\tt.Errorf(\"Mod(%s, %s) did not panic\", tc.x, tc.y)\n\t\t\t}\n\t\t}()\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\ty, err := FromDecimal(tc.y)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := New().Mod(x, y)\n\t\tt.Errorf(\"Mod(%s, %s) = %v, want %v\", tc.x, tc.y, result.String(), \"0\")\n\t}\n}\n\nfunc TestDivE(t *testing.T) {\n\ttestCases := []struct {\n\t\tx, y int64\n\t\twant int64\n\t}{\n\t\t{8, 3, 2},\n\t\t{8, -3, -2},\n\t\t{-8, 3, -3},\n\t\t{-8, -3, 3},\n\t\t{1, 2, 0},\n\t\t{1, -2, 0},\n\t\t{-1, 2, -1},\n\t\t{-1, -2, 1},\n\t\t{0, 1, 0},\n\t\t{0, -1, 0},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tx := NewInt(tc.x)\n\t\ty := NewInt(tc.y)\n\t\twant := NewInt(tc.want)\n\t\tgot := new(Int).DivE(x, y)\n\t\tif got.Cmp(want) != 0 {\n\t\t\tt.Errorf(\"DivE(%v, %v) = %v, want %v\", tc.x, tc.y, got, want)\n\t\t}\n\t}\n}\n\nfunc TestDivEByZero(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"DivE did not panic on division by zero\")\n\t\t}\n\t}()\n\n\tx := NewInt(1)\n\ty := NewInt(0)\n\tnew(Int).DivE(x, y)\n}\n\nfunc TestModEByZero(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Errorf(\"ModE did not panic on division by zero\")\n\t\t}\n\t}()\n\n\tx := NewInt(1)\n\ty := NewInt(0)\n\tnew(Int).ModE(x, y)\n}\n\nfunc TestLargeNumbers(t *testing.T) {\n\tx, _ := new(Int).SetString(\"123456789012345678901234567890\")\n\ty, _ := new(Int).SetString(\"987654321098765432109876543210\")\n\n\t// Expected results (calculated separately)\n\texpectedQ, _ := new(Int).SetString(\"0\")\n\texpectedR, _ := new(Int).SetString(\"123456789012345678901234567890\")\n\n\tgotQ := new(Int).DivE(x, y)\n\tgotR := new(Int).ModE(x, y)\n\n\tif gotQ.Cmp(expectedQ) != 0 {\n\t\tt.Errorf(\"DivE with large numbers: got %v, want %v\", gotQ, expectedQ)\n\t}\n\n\tif gotR.Cmp(expectedR) != 0 {\n\t\tt.Errorf(\"ModE with large numbers: got %v, want %v\", gotR, expectedR)\n\t}\n}\n\nfunc TestAbs(t *testing.T) {\n\ttests := []struct {\n\t\tx, want string\n\t}{\n\t\t{\"0\", \"0\"},\n\t\t{\"1\", \"1\"},\n\t\t{\"-1\", \"1\"},\n\t\t{\"-2\", \"2\"},\n\t\t{\"-100000000000\", \"100000000000\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tx, err := FromDecimal(tc.x)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgot := x.Abs()\n\n\t\tif got.String() != tc.want {\n\t\t\tt.Errorf(\"Abs(%s) = %v, want %v\", tc.x, got.String(), tc.want)\n\t\t}\n\t}\n}\n")
