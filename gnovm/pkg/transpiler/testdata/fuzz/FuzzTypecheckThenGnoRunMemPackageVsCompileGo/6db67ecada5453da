go test fuzz v1
[]byte("package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tasc  bool\n\t}{\n\t\t{\"ascending\", true},\n\t\t{\"descending\", false},\n\t}\n\n\tfor _, tt := range tt {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\t// use sl to insert the values, and reversed to match the values\n\t\t\t// we do this to ensure that the order of TraverseByOffset is independent\n\t\t\t// from the insertion order\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\t\t\tsort.Strings(sl)\n\t\t\treversed := append([]string{}, sl...)\n\t\t\treverseSlice(reversed)\n\n\t\t\tif !tt.asc {\n\t\t\t\tsl, reversed = reversed, sl\n\t\t\t}\n\n\t\t\tr := NewNode(reversed[0], nil)\n\t\t\tfor _, v := range reversed[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i < len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tt.asc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l <= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i <= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max > len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tt.asc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestHas(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\thasKey   string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\t\"has key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in non-empty tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"has key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"A\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in single-node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t\"B\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"does not have key in empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tresult := tree.Has(tt.hasKey)\n\n\t\t\tif result != tt.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGet(t *testing.T) {\n\ttests := []struct {\n\t\tname         string\n\t\tinput        []string\n\t\tgetKey       string\n\t\texpectIdx    int\n\t\texpectVal    interface{}\n\t\texpectExists bool\n\t}{\n\t\t{\n\t\t\t\"get existing key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"B\",\n\t\t\t1,\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (smaller)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"@\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get non-existent key (larger)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t5,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get from empty tree\",\n\t\t\t[]string{},\n\t\t\t\"A\",\n\t\t\t0,\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tidx, val, exists := tree.Get(tt.getKey)\n\n\t\t\tif idx != tt.expectIdx {\n\t\t\t\tt.Errorf(\"Expected index %d, got %d\", tt.expectIdx, idx)\n\t\t\t}\n\n\t\t\tif val != tt.expectVal {\n\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t}\n\n\t\t\tif exists != tt.expectExists {\n\t\t\t\tt.Errorf(\"Expected exists %t, got %t\", tt.expectExists, exists)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetByIndex(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tinput       []string\n\t\tidx         int\n\t\texpectKey   string\n\t\texpectVal   interface{}\n\t\texpectPanic bool\n\t}{\n\t\t{\n\t\t\t\"get by valid index\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t2,\n\t\t\t\"C\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (smallest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t0,\n\t\t\t\"A\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by valid index (largest)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t4,\n\t\t\t\"E\",\n\t\t\tnil,\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (negative)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t-1,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"get by invalid index (out of range)\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t5,\n\t\t\t\"\",\n\t\t\tnil,\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tif tt.expectPanic {\n\t\t\t\tdefer func() {\n\t\t\t\t\tif r := recover(); r == nil {\n\t\t\t\t\t\tt.Errorf(\"Expected a panic but didn't get one\")\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t}\n\n\t\t\tkey, val := tree.GetByIndex(tt.idx)\n\n\t\t\tif !tt.expectPanic {\n\t\t\t\tif key != tt.expectKey {\n\t\t\t\t\tt.Errorf(\"Expected key %s, got %s\", tt.expectKey, key)\n\t\t\t\t}\n\n\t\t\t\tif val != tt.expectVal {\n\t\t\t\t\tt.Errorf(\"Expected value %v, got %v\", tt.expectVal, val)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemove(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tinput     []string\n\t\tremoveKey string\n\t\texpected  []string\n\t}{\n\t\t{\n\t\t\t\"remove leaf node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"B\",\n\t\t\t[]string{\"A\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with one child\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"D\"},\n\t\t\t\"A\",\n\t\t\t[]string{\"B\", \"C\", \"D\"},\n\t\t},\n\t\t{\n\t\t\t\"remove node with two children\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove root node\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"C\",\n\t\t\t[]string{\"A\", \"B\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"remove non-existent key\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t\"F\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree, _, _, _ = tree.Remove(tt.removeKey)\n\n\t\t\tresult := make([]string, 0)\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTraverse(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"empty tree\",\n\t\t\t[]string{},\n\t\t\t[]string{},\n\t\t},\n\t\t{\n\t\t\t\"single node tree\",\n\t\t\t[]string{\"A\"},\n\t\t\t[]string{\"A\"},\n\t\t},\n\t\t{\n\t\t\t\"small tree\",\n\t\t\t[]string{\"C\", \"A\", \"B\", \"E\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"large tree\",\n\t\t\t[]string{\"H\", \"D\", \"L\", \"B\", \"F\", \"J\", \"N\", \"A\", \"C\", \"E\", \"G\", \"I\", \"K\", \"M\", \"O\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\tt.Run(\"iterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"ReverseIterate\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\ttree.ReverseIterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, len(tt.expected))\n\t\t\t\tcopy(expected, tt.expected)\n\t\t\t\tfor i, j := 0, len(expected)-1; i < j; i, j = i+1, j-1 {\n\t\t\t\t\texpected[i], expected[j] = expected[j], expected[i]\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"TraverseInRange\", func(t *testing.T) {\n\t\t\t\tvar result []string\n\t\t\t\tstart, end := \"C\", \"M\"\n\t\t\t\ttree.TraverseInRange(start, end, true, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t\texpected := make([]string, 0)\n\t\t\t\tfor _, key := range tt.expected {\n\t\t\t\t\tif key >= start && key < end {\n\t\t\t\t\t\texpected = append(expected, key)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !slicesEqual(expected, result) {\n\t\t\t\t\tt.Errorf(\"want %v got %v\", expected, result)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tt.Run(\"early termination\", func(t *testing.T) {\n\t\t\t\tif len(tt.input) == 0 {\n\t\t\t\t\treturn // Skip for empty tree\n\t\t\t\t}\n\n\t\t\t\tvar result []string\n\t\t\t\tvar count int\n\t\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\t\tcount++\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn true // Stop after first item\n\t\t\t\t})\n\n\t\t\t\tif count != 1 {\n\t\t\t\t\tt.Errorf(\"Expected callback to be called exactly once, got %d calls\", count)\n\t\t\t\t}\n\t\t\t\tif len(result) != 1 {\n\t\t\t\t\tt.Errorf(\"Expected exactly one result, got %d items\", len(result))\n\t\t\t\t}\n\t\t\t\tif len(result) > 0 && result[0] != tt.expected[0] {\n\t\t\t\t\tt.Errorf(\"Expected first item to be %v, got %v\", tt.expected[0], result[0])\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc TestRotateWhenHeightDiffers(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation when left subtree is higher\",\n\t\t\t[]string{\"E\", \"C\", \"A\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation when right subtree is higher\",\n\t\t\t[]string{\"A\", \"C\", \"E\", \"D\", \"F\"},\n\t\t\t[]string{\"A\", \"C\", \"D\", \"E\", \"F\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"E\", \"A\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"A\", \"E\", \"C\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\t// perform rotation or balance\n\t\t\ttree = tree.balance()\n\n\t\t\t// check tree structure\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRotateAndBalance(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tinput    []string\n\t\texpected []string\n\t}{\n\t\t{\n\t\t\t\"right rotation\",\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left rotation\",\n\t\t\t[]string{\"E\", \"D\", \"C\", \"B\", \"A\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"left-right rotation\",\n\t\t\t[]string{\"C\", \"A\", \"E\", \"B\", \"D\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t\t{\n\t\t\t\"right-left rotation\",\n\t\t\t[]string{\"C\", \"E\", \"A\", \"D\", \"B\"},\n\t\t\t[]string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.input {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree = tree.balance()\n\n\t\t\tvar result []string\n\t\t\ttree.Iterate(\"\", \"\", func(n *Node) bool {\n\t\t\t\tresult = append(result, n.Key())\n\t\t\t\treturn false\n\t\t\t})\n\n\t\t\tif !slicesEqual(tt.expected, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", tt.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRemoveFromEmptyTree(t *testing.T) {\n\tvar tree *Node\n\tnewTree, _, val, removed := tree.Remove(\"NonExistent\")\n\tif newTree != nil {\n\t\tt.Errorf(\"Removing from an empty tree should still be nil tree.\")\n\t}\n\tif val != nil || removed {\n\t\tt.Errorf(\"Expected no value and removed=false when removing from empty tree.\")\n\t}\n}\n\nfunc TestBalanceAfterRemoval(t *testing.T) {\n\ttests := []struct {\n\t\tname            string\n\t\tinsertKeys      []string\n\t\tremoveKey       string\n\t\texpectedBalance int\n\t}{\n\t\t{\n\t\t\tname:            \"balance after removing right node\",\n\t\t\tinsertKeys:      []string{\"B\", \"A\", \"D\", \"C\", \"E\"},\n\t\t\tremoveKey:       \",\tE\"\n\t\texpectedBalance: 0,\n\t\t},\n\t\t{\n\t\t\tname:            \"balance after removing left node\",\n\t\t\tinsertKeys:      []string{\"D\", \"B\", \"E\", \"A\", \"C\"},\n\t\t\tremoveKey:       \"A\",\n\t\t\texpectedBalance: 0,\n\t\t},\n\t\t{\n\t\t\tname:            \"ensure no lean after removal\",\n\t\t\tinsertKeys:      []string{\"C\", \"B\", \"E\", \"A\", \"D\", \"F\"},\n\t\t\tremoveKey:       \"F\",\n\t\t\texpectedBalance: -1,\n\t\t},\n\t\t{\n\t\t\tname:            \"descending order insert, remove middle node\",\n\t\t\tinsertKeys:      []string{\"E\", \"D\", \"C\", \"B\", \"A\"},\n\t\t\tremoveKey:       \"C\",\n\t\t\texpectedBalance: 0,\n\t\t},\n\t\t{\n\t\t\tname:            \"ascending order insert, remove middle node\",\n\t\t\tinsertKeys:      []string{\"A\", \"B\", \"C\", \"D\", \"E\"},\n\t\t\tremoveKey:       \"C\",\n\t\t\texpectedBalance: 0,\n\t\t},\n\t\t{\n\t\t\tname:            \"duplicate key insert, remove the duplicated key\",\n\t\t\tinsertKeys:      []string{\"C\", \"B\", \"C\", \"A\", \"D\"},\n\t\t\tremoveKey:       \"C\",\n\t\t\texpectedBalance: 1,\n\t\t},\n\t\t{\n\t\t\tname:            \"complex rotation case\",\n\t\t\tinsertKeys:      []string{\"H\", \"B\", \"A\", \"C\", \"E\", \"D\", \"F\", \"G\"},\n\t\t\tremoveKey:       \"B\",\n\t\t\texpectedBalance: 0,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tvar tree *Node\n\t\t\tfor _, key := range tt.insertKeys {\n\t\t\t\ttree, _ = tree.Set(key, nil)\n\t\t\t}\n\n\t\t\ttree, _, _, _ = tree.Remove(tt.removeKey)\n\n\t\t\tbalance := tree.calcBalance()\n\t\t\tif balance != tt.expectedBalance {\n\t\t\t\tt.Errorf(\"Expected balance factor %d, got %d\", tt.expectedBalance, balance)\n\t\t\t}\n\n\t\t\tif balance < -1 || balance > 1 {\n\t\t\t\tt.Errorf(\"Tree is unbalanced with factor %d\", balance)\n\t\t\t}\n\n\t\t\tif errMsg := checkSubtreeBalance(t, tree); errMsg != \"\" {\n\t\t\t\tt.Errorf(\"AVL property violation after removal: %s\", errMsg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBSTProperty(t *testing.T) {\n\tvar tree *Node\n\tkeys := []string{\"D\", \"B\", \"F\", \"A\", \"C\", \"E\", \"G\"}\n\tfor _, key := range keys {\n\t\ttree, _ = tree.Set(key, nil)\n\t}\n\n\tvar result []string\n\tinorderTraversal(t, tree, &result)\n\n\tfor i := 1; i < len(result); i++ {\n\t\tif result[i] < result[i-1] {\n\t\t\tt.Errorf(\"BST property violated: %s < %s (index %d)\",\n\t\t\t\tresult[i], result[i-1], i)\n\t\t}\n\t}\n}\n\n// inorderTraversal performs an inorder traversal of the tree and returns the keys in a list.\nfunc inorderTraversal(t *testing.T, node *Node, result *[]string) {\n\tt.Helper()\n\n\tif node == nil {\n\t\treturn\n\t}\n\t// leaf\n\tif node.height == 0 {\n\t\t*result = append(*result, node.key)\n\t\treturn\n\t}\n\tinorderTraversal(t, node.leftNode, result)\n\tinorderTraversal(t, node.rightNode, result)\n}\n\n// checkSubtreeBalance checks if all nodes under the given node satisfy the AVL tree conditions.\n// The balance factor of all nodes must be âˆˆ [-1, +1]\nfunc checkSubtreeBalance(t *testing.T, node *Node) string {\n\tt.Helper()\n\n\tif node == nil {\n\t\treturn \"\"\n\t}\n\n\tif node.IsLeaf() {\n\t\t// leaf node must be height=0, size=1\n\t\tif node.height != 0 {\n\t\t\treturn ufmt.Sprintf(\"Leaf node %s has height %d, expected 0\", node.Key(), node.height)\n\t\t}\n\t\tif node.size != 1 {\n\t\t\treturn ufmt.Sprintf(\"Leaf node %s has size %d, expected 1\", node.Key(), node.size)\n\t\t}\n\t\treturn \"\"\n\t}\n\n\t// check balance factor for current node\n\tbalanceFactor := node.calcBalance()\n\tif balanceFactor < -1 || balanceFactor > 1 {\n\t\treturn ufmt.Sprintf(\"Node %s is unbalanced: balanceFactor=%d\", node.Key(), balanceFactor)\n\t}\n\n\t// check height / size relationship for children\n\tleft, right := node.getLeftNode(), node.getRightNode()\n\texpectedHeight := maxInt8(left.height, right.height) + 1\n\tif node.height != expectedHeight {\n\t\treturn ufmt.Sprintf(\"Node %s has incorrect height %d, expected %d\", node.Key(), node.height, expectedHeight)\n\t}\n\texpectedSize := left.Size() + right.Size()\n\tif node.size != expectedSize {\n\t\treturn ufmt.Sprintf(\"Node %s has incorrect size %d, expected %d\", node.Key(), node.size, expectedSize)\n\t}\n\n\t// recursively check the left/right subtree\n\tif errMsg := checkSubtreeBalance(t, left); errMsg != \"\" {\n\t\treturn errMsg\n\t}\n\tif errMsg := checkSubtreeBalance(t, right); errMsg != \"\" {\n\t\treturn errMsg\n\t}\n\n\treturn \"\"\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i < len(w1); i++ {\n\t\tif w1[i] != w2[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i < len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n")
