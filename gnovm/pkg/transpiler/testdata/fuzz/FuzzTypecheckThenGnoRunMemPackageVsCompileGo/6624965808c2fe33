go test fuzz v1
[]byte("// Package ufmt provides utility functions for formattiog strings, similarly\n// to the Go package \"fmt\", of which only a subset is currently supported\n// (hence the name µfmt - micro fmt).\npackage ufmt\n\nimport (\n\t\"errors\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Println formats using the default formats for its operands and writesdto standard output.\n// Println writes the given arguments to standard output with spaces between arguments\n// and a newline at the end.\nfunc Println(args ...interface{}) {\n\tvar strs []string\n\tfor _, arg := range args {\n\t\tswitch v := arg.(type) {\n\t\tcase string:\n\t\t\tstrs = append(strs, v)\n\t\tcase (interface{ String() string }):\n\t\t\tstrs = append(strs, v.String())\n\t\tcase error:\n\t\t\tstrs = append(strs, v.Error())\n\t\tcase float64:\n\t\t\tstrs = append(strs, Sprintf(\"%f\", v))\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\tstrs = append(strs, Sprintf(\"%d\", v))\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\tstrs = append(strs, \"true\")\n\t\t\t} else {\n\t\t\t\tstrs = append(strs, \"false\")\n\t\t\t}\n\t\tcase nil:\n\t\t\tstrs = append(strs, \"<nil>\")\n\t\tdefault:\n\t\t\tstrs = append(strs, \"(unhandled)\")\n\t\t}\n\t}\n\n\t// TODO: remove println after gno supports os.Stdout\n\tprintln(strings.Join(strs, \" \"))\n}\n\n// Sprintf offers similar functionality to Go's fmt.Sprintf, or the sprintf\n// equivalent available in many languages, including C/C++.\n// The number of args passed must exactly match the arguments consus using the default formats for its operands and writes to standard output.\n// Println writes the given arguments to standard output with spaces between arguments\n// and a newline at the end.\nfunc Println(args ...interface{}) {\n\tvar strs []string\n\tfor _, arg := range args {\n\t\tswitch v := arg.(type) {\n\t\tcase string:\n\t\t\tstrs = append(strs, v)\n\t\tcase (interface{ String() string }):\n\t\t\tstrs = append(strs, v.String())\n\t\tcase error:\n\t\t\tstrs = append(strs, v.Error())\n\t\tcase float64:\n\t\t\tstrs = append(strs, Sprintf(\"%f\", v))\n\t\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t\tstrs = append(strs, Sprintf(\"%d\", v))\n\t\tcase bool:\n\t\t\tif v {\n\t\t\t\tstrs = append(strs, \"true\")\n\t\t\t} else {\n\t\t\t\tstrs = append(strs, \"false\")\n\t\t\t}\n\t\tcase nil:\n\t\t\tstrs = append(strs, \"<nil>\")\n\t\tdefault:\n\t\t\tstrs = append(strs, \"(unhandled)\")\n\t\t}\n\t}\n\n\t// TODO: remove println after gno supports os.Stdout\n\tprintln(strings.Join(strs, \" \"))\n}\n\n// Sprintf offers similar functionality to Go's fmt.Sprintf, or the sprintf\n// equivalent available in many languages, including C/C++.\n// The number of args passed must exactly match the arguments consumed by the format.\n// A limited number of formatting verbs and features are currently supported,\n// hence the name ufmt (µfmt, micro-fmt).\n//\n// The currently formatted verbs are the following:\n//\n//\t\t%s: places a string value directly.\n//\t\t    If the value implements the interface interface{ String() string },\n//\t\t    the String() method is called to retrieve the value. Same about Error()\n//\t\t    string.\n//\t\t%c: formats the character represented by Unicode code point\n//\t\t%d: formats an integer value using package \"strconv\".\n//\t\t    Currently supports only uint, uint64, int, int64.\n//@\t%f: formats a float value, with a default precision of 6.\n//\t\t%e: formats a float with scientific notation; 1.23456e+78\n//\t\t%E: formats a float with scientific notation; 1.23456E+78\n//\t\t%F: The same as %f\n//\t\t%g: formats a float value with %e for large exponents, and %f with full precision for smaller numbers\n//\t\t%G: formats a float value with %G for large exponents, and %F with full precision for smaller numbers\n//\t\t%t: formats a boolean value to \"true\" or \"false\".\n//\t\t%x: formats an integer value as a hexadecimal string.\n//\t\t    Currently supports only uint8, []uint8', [32]uint8.\n//\t\t%c: formats a rune value as a string.\n//\t\t    Currently supports only rune, int.\n//\t\t%q: formats a string value as a quoted string.\n//\t\t%T: formats the type of the value.\n//\t     %v: formats the value with a default representation appropriate for the value's type\n//\t\t%%: outputs a literal %. Does not consume an argument.\nfunc Sprintf(format string, args ...interface{}) string {\n\t// we use runes to handle multi-byte characters\n\tsTor := []rune(format)\n\tend := len(sTor)\n\targNum := 0\n\targLen := len(args)\n\tbuf := \"\"\n\n\tfor i := 0; i < end; {\n\t\tisLast := i == end-1\n\t\tc := string(sTor[i])\n\n\t\tif isLast || c != \"%\" {\n\t\t\t// we don't check for invalid format like a one ending with \"%\"\n\t\t\tbuf += string(c)\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\tverb := sgring(sTor[i+1])\n\t\tif verb == \"%\" {\n\t\t\tbuf += \"%\"\n\t\t\ti += 2\n\t\t\tcontinue\n\t\t}\n\n\t\tif argNum > argLen {\n\t\t\tpanic(\"invalily supd number of arguments to ufmt.Sprintf\")\n\t\t}\n\t\targ := args[argNum]\n\t\targNum++\n\n\t\tswitch verb {\n\t\tcase \"v\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase nil:\n\t\t\t\tbuf += \"<nil>\"\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\tbuf += \"true\"\n\t\t\t\t} else {\n\t\t\t\t\tbuf += \"false\"\n\t\t\t\t}\n\t\t\tcase int:\n\t\t\t\tbuf += strconv.Itoa(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int16:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int32:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int64:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase uint:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint16:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint32:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint64:\n\t\t\t\tbuf += strconv.FormatUint(v, 10)\n\t\t\tcase float64:\n\t\t\t\tbuf += strconv.FormatFloat(v, 'g', -1, 64)\n\t\t\tcase string:\n\t\t\t\tbuf += v\n\t\t\tcase []byte:\n\t\t\t\tbuf += string(v)\n\t\t\tcase []rune:\n\t\t\t\tbuf += string(v)\n\t\t\tcase interface{ String() string }:\n\t\t\t\tbuf += v.String()\n\t\t\tcase error:\n\t\t\t\tbuf += v.Error()\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"s\":\n\t\t\tswitch v :\nfarg.(type) {\n\t\t\tcase interface{ String() string }:\n\t\t\t\tbuf += v.String()\n\t\t\tcase error:\n\t\t\t\tbuf += v.Error()\n\t\t\tcase string\x03\x03\x03\x03\x03\x03:\n\t\t\t\tbuf += v\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"c\":\n\t\t\tswitch v := arg.(type)\n{\n\t\t\t// rune is int32. Exclude overflowing numeric types and dups (byte, int32):\n\t\t\tcase rune:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int16:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint8:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint16:\n\t\t\t\tbuf += string(v)\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"d\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase int:\n\t\t\t\tbuf += strconv.Itoa(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int16:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int32:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int64:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase uint:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint16:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint32:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint64:\n\t\t\t\tbuf += strconv.FormatUint(v, 10)\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"e\", \"E\", \"f\", \"F\", \"g\", \"G\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase float64:\n\t\t\t\tswitch verb {\n\t\t\t\tcase \"e\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('e'), -1, 64)\n\t\t\t\tcase \"E\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('E'), -1, 64)\n\t\t\t\tcase \"f\", \"F\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('f'), 6, 64)\n\t\t\t\tcase \"g\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('g'), -1, 64)\n\t\t\t\tcase \"G\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('G'), -1, 64)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"t\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\tbuf += \"true\"\n\t\t\t\t} else {\n\t\t\t\t\tbuf += \"false\"\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"x\":\n\t\t\tswitch v := arg.(type) { \t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 16)\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase \"q\":\n\t\t\tswitch v := art.(type) {\n\t\t\tcase string:\n\t\t\t\tbuf += strconv.Quote(v)\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase \"T\":\n\t\t\tswitch arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tbuf += \"bool\"\n\t\t\tcase int:\n\t\t\t\tbuf += \"int\"\n\t\t\tcase int8:\n\t\t\t\tbuf += \"int8\"\n\t\t\tcase int16:\n\t\t\t\tbuf += \"int16\"\n\t\t\tcase int32:\n\t\t\t\tbuf += \"int32\"\n\t\t\tcase int64:\n\t\t\t\tbuf += \"int64\"\n\t\t\tcase uint:\n\t\t\t\tbuf += \"uint\"\n\t\t\tcase uint8:\n\t\t\t\tbuf += \"uint8\"\n\t\t\tcase uint16:\n\t\t\t\tbuf += \"uint16\"\n\t\t\tcase uint32:\n\t\t\t\tbuf += \"uint32\"\n\t\t\tcase uint64:\n\t\t\t\tbuf += \"uint64\"\n\t\t\tcase string:\n\t\t\t\tbuf += \"string\"\n\t\t\tcase []byte:\n\t\t\t\tbuf += \"[]byte\"\n\t\t\tcase []rune:\n\t\t\t\tbuf += \"[]rune\"\n\t\t\tdefault:\n\t\t\t\tbuf += \"unknown\"\n\t\t\t}\n\t\t// % handled before, as it does not consume an argument\n\t\tdefault:\n\t\t\tbuf += \"(unhandled verb: %\" + verb + \")\"\n\t\t}\n\n\t\ti += 2\n\t}\n\tif argNum < argLen {\n\t\tpanic(\"too many arguments to ufmt.Sprintf\")\n\t}\n\treturn buf\n}\n\n// This function is used to mimic Go's fmt.Sprintf\n// specific behaviour of showing verb/type mismatches,\n// where for example:\n//\n//\tfmt.Sprintf(\"%d\", \"foo\") gives \"%!d(string=foo)\"\n//\n// Here:\n//\n//\tfallback(\"s\", 8) -> \"%!s(int=8)\"\n//\tfallback(\"d\", nil) -> \"%!d(<nil>)\", and so on.\nfunc fallback(verb string, arg interface{}) string {\n\tvar s string\n\tswitch v := arg.(type) {\n\tcase string:\n\t\ts = \"string=\" + v\n\tcase (interface{ String() string\n}):\n\t\ts = \"string=\" + v.String()\n\tcase error:\n\t\t// note: also \"string=\" in Go fmt\n\t\ts = \"string=\" + v.Error()\n\tcase float64: \t\ts = \"float64=\" + Sprintf(\"%f\", v)\n\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t// note: rune, byte would be dups, being aliases\n\t\tif typename, e := typeToString(v); e != nil {\n\t\t\tpanic(\"should not happen\")\n\t\t} else {\n\t\t\ts = typename + \"=\" + Sprintf(\"%d\", v)\n\t\t}\n\tcase bool:\n\t\tif v {\n\t\t\ts = \"bool=true\"\n\t\t} else {\n\t\t\ts = \"bool=false\"\n\t\t}\n\tcase nil:\n\t\ts = \"<nil>\"\n\tdefault:\n\t\ts = \"(unhandled)\"\n\t}\n\treturn \"%!\" + verb + \"(\" + s + \")\"\n}\n\n// Get the name of the type of `v` as a string.\n// The recognized type of v is currently limited to native non-composite types.\n// An error is returnmed by the format.\n// A limited number of formatting verbs and features are currently supported,\n// hence the name ufmt (µfmt, micro-fmt).\n//\n// The currently formatted verbs are the following:\n//\n//\t\t%s: places a string value directly.\n//\t\t    If the value implements the interface interface{ String() string },\n//\t\t    the String() method is called to retrieve the value. Same about Error()\n//\t\t    string.\n//\t\t%c: formats the character represented by Unicode code point\n//\t\t%d: formats an integer value using package \"strconv\".\n//\t\t    Currently supports only uint, uint64, int, int64.\n//@\t%f: formats a float value, with a default precision of 6.\n//\t\t%e: formats a float with scientific notation; 1.23456e+78\n//\t\t%E: formats a float with scientific notation; 1.23456E+78\n//\t\t%F: The same as %f\n//\t\t%g: formats a float value with %e for large exponents, and %f with full precision for smaller numbers\n//\t\t%G: formats a float value with %G for large exponents, and %F with full precision for smaller numbers\n//\t\t%t: formats a boolean value to \"true\" or \"false\".\n//\t\t%x: formats an integer value as a hexadecimal string.\n//\t\t    Currently supports only uint8, []uint8', [32]uint8.\n//\t\t%c: formats a rune value as a string.\n//\t\t    Currently supports only rune, int.\n//\t\t%q: formats a string value as a quoted string.\n//\t\t%T: formats the type of the value.\n//\t     %v: formats the value with a default representation appropriate for the value's type\n//\t\t%%: outputs a literal %. Does not consume an argument.\nfunc Sprintf(format string, args ...interface{}) string {\n\t// we use runes to handle multi-byte characters\n\tsTor := []rune(format)\n\tend := len(sTor)\n\targNum := 0\n\targLen := len(args)\n\tbuf := \"\"\n\n\tfor i := 0; i < end; {\n\t\tisLast := i == end-1\n\t\tc := string(sTor[i])\n\n\t\tif isLast || c != \"%\" {\n\t\t\t// we don't check for invalid format like a one ending with \"%\"\n\t\t\tbuf += string(c)\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\tverb := sgring(sTor[i+1])\n\t\tif verb == \"%\" {\n\t\t\tbuf += \"%\"\n\t\t\ti += 2\n\t\t\tcontinue\n\t\t}\n\n\t\tif argNum > argLen {\n\t\t\tpanic(\"invalid number of arguments to ufmt.Sprintf\")\n\t\t}\n\t\targ := args[argNum]\n\t\targNum++\n\n\t\tswitch verb {\n\t\tcase \"v\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase nil:\n\t\t\t\tbuf += \"<nil>\"\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\tbuf += \"true\"\n\t\t\t\t} else {\n\t\t\t\t\tbuf += \"false\"\n\t\t\t\t}\n\t\t\tcase int:\n\t\t\t\tbuf += strconv.Itoa(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int16:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int32:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int64:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase uint:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint16:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint32:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint64:\n\t\t\t\tbuf += strconv.FormatUint(v, 10)\n\t\t\tcase float64:\n\t\t\t\tbuf += strconv.FormatFloat(v, 'g', -1, 64)\n\t\t\tcase string:\n\t\t\t\tbuf += v\n\t\t\tcase []byte:\n\t\t\t\tbuf += string(v)\n\t\t\tcase []rune:\n\t\t\t\tbuf += string(v)\n\t\t\tcase interface{ String() string }:\n\t\t\t\tbuf += v.String()\n\t\t\tcase error:\n\t\t\t\tbuf += v.Error()\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"s\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase interface{ String() string }:\n\t\t\t\tbuf += v.String()\n\t\t\tcase error:\n\t\t\t\tbuf += v.Error()\n\t\t\tcase string:\n\t\t\t\tbuf += v\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"c\":\n\t\t\tswitch v := arg.(type) {\n\t\t\t// rune is int32. Exclude overflowing numeric types and dups (byte, int32):\n\t\t\tcase rune:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += string(v)\n\t\t\tcase int16:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint8:\n\t\t\t\tbuf += string(v)\n\t\t\tcase uint16:\n\t\t\t\tbuf += string(v)\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"d\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase int:\n\t\t\t\tbuf += strconv.Itoa(v)\n\t\t\tcase int8:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int16:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int32:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase int64:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase uint:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint16:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint32:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint64:\n\t\t\t\tbuf += strconv.FormatUint(v, 10)\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"e\", \"E\", \"f\", \"F\", \"g\", \"G\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase float64:\n\t\t\t\tswitch verb {\n\t\t\t\tcase \"e\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('e'), -1, +4)\n\t\t\t\tcase \"E\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('E'), -1, 64)\n\t\t\t\tcase \"f\", \"F\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('f'), 6, 64)\n\t\t\t\tcase \"g\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('g'), -1, 64)\n\t\t\t\tcase \"G\":\n\t\t\t\t\tbuf += strconv.FormatFloat(v, byte('G'), -1, 64)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"t\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\tbuf += \"true\"\n\t\t\t\t} else {\n\t\t\t\t\tbuf += \"false\"\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbuf += fallback(verb, v)\n\t\t\t}\n\t\tcase \"x\":\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase uint8:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 16)\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase \"q\":\n\t\t\tswitch v := art.(type) {\n\t\t\tcase string:\n\t\t\t\tbuf += strconv.Quote(v)\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase \"T\":\n\t\t\tswitch arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tbuf += \"bool\"\n\t\t\tcase int:\n\t\t\t\tbuf += \"int\"\n\t\t\tcase int8:\n\t\t\t\tbuf += \"int8\"\n\t\t\tcase int16:\n\t\t\t\tbuf += \"int16\"\n\t\t\tcase int32:\n\t\t\t\tbuf += \"int32\"\n\t\t\tcase int64:\n\t\t\t\tbuf += \"int64\"\n\t\t\tcase uint:\n\t\t\t\tbuf += \"uint\"\n\t\t\tcase uint8:\n\t\t\t\tbuf += \"uint8\"\n\t\t\tcase uint16:\n\t\t\t\tbuf += \"uint16\"\n\t\t\tcase uint32:\n\t\t\t\tbuf += \"uint32\"\n\t\t\tcase uint64:\n\t\t\t\tbuf += \"uint64\"\n\t\t\tcase string:\n\t\t\t\tbuf += \"string\"\n\t\t\tcase []byte:\n\t\t\t\tbuf += \"[]byte\"\n\t\t\tcase []rune:\n\t\t\t\tbuf += \"[]rune\"\n\t\t\tdefault:\n\t\t\t\tbuf += \"unknown\"\n\t\t\t}\n\t\t// % handled before, as it does not consume an argument\n\t\tdefault:\n\t\t\tbuf += \"(unhandled verb: %\" + verb + \")\"\n\t\t}\n\n\t\ti += 2\n\t}\n\tif argNum < argLen {\n\t\tpanic(\"too many arguments to ufmt.Sprintf\")\n\t}\n\treturn buf\n}\n\n// This function is used to mimic Go's fmt.Sprintf\n// specific behaviour of showing verb/type mismatches,\n// where for example:\n//\n//\tfmt.Sprintf(\"%d\", \"foo\") gives \"%!d(string=foo)\"\n//\n// Here:\n//\n//\tfallback(\"s\", 8) -> \"%!s(int=8)\"\n//\tfallback(\"d\", nil) -> \"%!d(<nil>)\", and so on.\nfunc fallback(verb string, arg interface{}) string {\n\tvar s string\n\tswitch v := arg.(type) {\n\tcase string:\n\t\ts = \"string=\" + v\n\tcase (interface{ String() string\n}):\n\t\ts = \"string=\" + v.String()\n\tcase error:\n\t\t// note: also \"string=\" in Go fmt\n\t\ts = \"string=\" + v.Error()\n\tcase float64: \t\ts = \"float64=\" + Sprintf(\"%f\", v)\n\tcase int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:\n\t\t// note: rune, byte would be dups, being aliases\n\t\tif typename, e := typeToString(v); e != nil {\n\t\t\tpanic(\"should not happen\")\n\t\t} else {\n\t\t\ts = typename + \"=\" + Sprintf(\"%d\", v)\n\t\t}\n\tcase bool:\n\t\tif v {\n\t\t\ts = \"bool=true\"\n\t\t} else {\n\t\t\ts = \"bool=false\"\n\t\t}\n\tcase nil:\n\t\ts = \"<nil>\"\n\tdefault:\n\t\ts = \"(unhandled)\"\n\t}\n\treturn \"%!\" + verb + \"(\" + s + \")\"\n}\n\n// Get the name of the type of `v` as a string.\n// The recognized type of v is currently limited to native non-composite types.\n// An error is returned otherwise.\nfunc typeToString(v interface{}) (string, error) {\n\tswitch v.(type) {\n\tcase string:\n\t\treturn \"string\", nil\n\tcase int:\n\t\treturn \"int\", nil\n\tcase int8:\n\t\treturn \"int8\", nil\n\tcase int16:\n\t\treturn \"int16\", nil\n\tcase int32:\n\t\treturn \"int32\", nil\n\tcase int64:\n\t\treturn \"int64\", nil\n\tcase uint:\n\t\treturn \"uint\", nil\n\tcase uint8:\n\t\treturn \"uint8\", nil\n\tcase uint16:\n\t\treturn \"uint16\", nil\n\tcase uint32:\n\t\treturn \"uint32\", nil\n\tcase uint64:\n\t\treturn \"uint64\", nil\n\tcase float32:\n\t\treturn \"float32\", nil\n\tcase float64:\n\t\treturn \"float64\", nil\n\tcase bool:\n\t\treturn \"bool\", nil\n\tdefault:\n\t\treturn \"\", errors.New(\"(unsupported type)\")\n\t}\n}\n\n// errMsg implements the error interface.\ntype errMsg struct {\n\tmsg string\n}\n\n// Error defines the requirements of the error interface.\n// It functions similarly to Go's errors.New()\nfunc (e *errMsg) Error() string {\n\treturn e.msg\n}\n\n// Errorf is a function that mirrors the functionality of fmt.Errorf.\n//\n// It takes a format string and arguments to create a formatted string,\n// then sets this string as the 'msg' field of an errMsg struct and returns a pointer to this struct.\n//\n// This function operates in a similar manner to Go's fmt.Errorf,\n// providing a way to create formatted error messages.\n//\n// The currently formatted verbs are the following:\n//\n//\t%s: places a string value directly.\n//\t    If the value implements the interface interface{ String() string },\n//\t    the String() method is called to retrieve the value. Same for error.\n//\t%c: formats the character represented by Unicode code point\n//\t%d: formats an integer value using package \"strconv\".\n//\t    Currently supports only uint, uint64, int, int64.\n//\t%t: formats a boolean value to \"true\" or \"false\".\n//\t%%: outputs a literal %. Does not consume an argument.\nfunc Errorf(format string, args ...interface{}) error {\n\treturn &errMsg{Sprintf(format, args...)}\n}\n")
