go test fuzz v1
[]byte("//////////\n//\n// Copyright 2014 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n//\n// Copyright 2024 New Tendermint\n//\n// This Gno port of the original Go BTree is substantially rewritten/reimplemented\n// from the original, primarily for clarity of code, clarity of documentation,\n// and for compatibility with Gno.\n//\n// Authors:\n//   Original version authors -- https://github.com/google/btree/graphs/contributors\n//   Kirk Haines <wyhaines@gmail.com>\n//\n//////////\n\n// Package btree implements in-memory B-Trees of arbitrary degree.\n//\n// It has a flatter structure than an equivalent red-black or other binary tree,\n// which may yield better memory usage and/or performance.\npackage btree\n\nimport \"sort\"\n\n//////////\n//\n// Types\n//\n//////////\n\n// BTreeOption is a function interface for setting options on a btree with `New()`.\ntype BTreeOption func(*BTree)\n\n// BTree is an implementation of a B-Tree.\n//\n// BTree stores Record instances in an ordered structure, allowing easy insertion,\n// removal, and iteration.\ntype BTree struct {\n\tdegree int\n\tlength int\n\troot   *node\n\tcowCtx *copyOnWriteContext\n}\n\n//\tAny type that implements this interface can be stored in the BTree. This allows considerable\n//\n// flexiblity in storage within the BTree.\ntype Record interface {\n\t// Less compares self to `than`, returning true if self is less than `than`\n\tLess(than Record) bool\n}\n\n// records is the storage within a node. It is expressed as a slice of Record, where a Record\n// is any struct that implements the Record interface.\ntype records []Record\n\n// node is an internal node in a tree.\n//\n// It must at all times maintain on of the two conditions:\n//   - len(children) == 0, len(records) unconstrained\n//   - len(children) == len(records) + 1\ntype node struct {\n\trecords  records\n\tchildren children\n\tcowCtx   *copyOnWriteContext\n}\n\n// children is the list of child nodes below the current node. It is a slice of nodes.\ntype children []*node\n\n// FreeNodeList represents a slice of nodes which are available for reuse. The default\n// behavior of New() is for each BTree instance to have its own FreeNodeList. However,\n// it is possible for multiple instances of BTree to share the same tree. If one uses\n// New(WithFreeNodeList()) to create a tree, one may pass an existing FreeNodeList, allowing\n// multiple trees to use a single list. In an application with multiple trees, it might\n// be more efficient to allocate a single FreeNodeList with a significant initial capacity,\n// and then have all of the trees use that same large FreeNodeList.\ntype FreeNodeList struct {\n\tnodes []*node\n}\n\n// copyOnWriteContext manages node ownership and ensures that cloned trees\n// maintain isolation from each other when a node is changed.\n//\n// Ownership Rules:\n//   - Each node is associated with a specific copyOnWriteContext.\n//   - A tree can modify a node directly only if the tree's context matches the node's context.\n//   - If a tree attempts to modify a node with a different context, it must create a\n//     new, writable copy of that node (i.e., perform a clone) before making changes.\n//\n// Write Operation Invariant:\n//   - During any write operation, the current node being modified must have the same\n//     context as the tree requesting the write.\n//   - To maintain this invariant, before descending into a child node, the system checks\n//     if the childâ€™s context matches the tree's context.\n//   - If the contexts match, the node can be modified in place.\n//   - If the contexts do not match, a mutable copy of the child node is created with the\n//     correct context before proceeding.\n//\n// Practical Implications:\n//   - The node currently being modified inherits the requesting tree's context, allowing\n//     in-place modifications.\n//   - Child nodes may initially have different contexts. Before any modification, these\n//     children are copied to ensure they share the correct context, enabling safe and\n//     isolated updates without affecting other trees that might be referencing the original nodes.\n//\n// Example Usage:\n// When a tree performs a write operation (e.g., inserting or deleting a node), it uses\n// its copyOnWriteContext to determine whether it can modify nodes directly or needs to\n// create copies. This mechanism ensures that trees can share nodes efficiently while\n// maintaining data integrity.\ntype copyOnWriteContext struct {\n\tnodes *FreeNodeList\n}\n\n// Record implements an interface with a single function, Less. Any type that implements\n// RecordIterator allows callers of all of the iteration functions for the BTree\n// to evaluate an element of the tree as it is traversed. The function will receive\n// a stored element from the tree. The function must return either a true or a false value.\n// True indicates that iteration should continue, while false indicates that it should halt.\ntype RecordIterator func(i Record) bool\n\n//////////\n//\n// Functions\n//\n//////////\n\n// NewFreeNodeList creates a new free list.\n// size is the maximum size of the returned free list.\nfunc NewFreeNodeList(size int) *FreeNodeList {\n\treturn &FreeNodeList{nodes: make([]*node, 0, size)}\n}\n\nfunc (freeList *FreeNodeList) newNode() (nodeInstance *node) {\n\tindex := len(freeList.nodes) - 1\n\tif index < 0 {\n\t\treturn new(node)\n\t}\n\tnodeInstance = freeList.nodes[index]\n\tfreeList.nodes[index] = nil\n\tfreeList.nodes = freeList.nodes[:index]\n\n\treturn nodeInstance\n}\n\n// freeNode adds the given node to the list, returning true if it was added\n// and false if it was discarded.\n\nfunc (freeList *FreeNodeList) freeNode(nodeInstance *node) (nodeWasAdded bool) {\n\tif len(freeList.nodes) < cap(freeList.nodes) {\n\t\tfreeList.nodes = append(freeList.nodes, nodeInstance)\n\t\tnodeWasAdded = true\n\t}\n\treturn\n}\n\n// A default size for the free node list. We might want to run some benchmarks to see if\n// there are any pros or cons to this size versus other sizes. This seems to be a reasonable\n// compromise to reduce GC pressure by reusing nodes where possible, without stacking up too\n// much baggage in a given tree.\nconst DefaultFreeNodeListSize = 32\n\n// WithDegree sets the degree of the B-Tree.\nfunc WithDegree(degree int) BTreeOption {\n\treturn func(bt *BTree) {\n\t\tif degree <= 1 {\n\t\t\tpanic(\"Degrees less than 1 do not make any sense for a BTree. Please provide a degree of 1 or greater.\")\n\t\t}\n\t\tbt.degree = degree\n\t}\n}\n\n// WithFreeNodeList sets a custom free node list for the B-Tree.\nfunc WithFreeNodeList(freeList *FreeNodeList) BTreeOption {\n\treturn func(bt *BTree) {\n\t\tbt.cowCtx = &copyOnWriteContext{nodes: freeList}\n\t}\n}\n\n// New creates a new B-Tree with optional configurations. If configuration is not provided,\n// it will default to 16 element nodes. Degree may not be less than 1 (which effectively\n// makes the tree into a binary tree).\n//\n// `New(WithDegree(2))`, for example, will create a 2-3-4 tree (each node contains 1-3 records\n// and 2-4 children).\n//\n// `New(WithFreeNodeList(NewFreeNodeList(64)))` will create a tree with a degree of 16, and\n// with a free node list with a size of 64.\nfunc New(options ...BTreeOption) *BTree {\n\tbtree := &BTree{\n\t\tdegree: 16, // default degree\n\t\tcowCtx: &copyOnWriteContext{nodes: NewFreeNodeList(DefaultFreeNodeListSize)},\n\t}\n\tfor _, opt := range options {\n\t\topt(btree)\n\t}\n\treturn btree\n}\n\n// insertAt inserts a value into the given index, pushing all subsequent values\n// forward.\nfunc (recordsSlice *records) insertAt(index int, newRecord Record) {\n\toriginalLength := len(*recordsSlice)\n\n\t// Extend the slice by one element\n\t*recordsSlice = append(*recordsSlice, nil)\n\n\t// Move elements from the end to avoid overwriting during the copy\n\t// TODO: Make this work with slice appends, instead. It should be faster?\n\tif index < originalLength {\n\t\tfor position := originalLength; position > index; position-- {\n\t\t\t(*recordsSlice)[position] = (*recordsSlice)[position-1]\n\t\t}\n\t}\n\n\t// Insert the new record\n\t(*recordsSlice)[index] = newRecord\n}\n\n// removeAt removes a Record from the records slice at the specified index.\n// It shifts subsequent records to fill the gap and returns the removed Record.\nfunc (recordSlicePointer *records) removeAt(index int) Record {\n\trecordSlice := *recordSlicePointer\n\tremovedRecord := recordSlice[index]\n\tcopy(recordSlice[index:], recordSlice[index+1:])\n\trecordSlice[len(recordSlice)-1] = nil\n\t*recordSlicePointer = recordSlice[:len(recordSlice)-1]\n\n\treturn removedRecord\n}\n\n// Pop removes and returns the last Record from the records slice.\n// It also clears the reference to the removed Record to aid garbage collection.\nfunc (r *records) pop() Record {\n\trecordSlice := *r\n\tlastIndex := len(recordSlice) - 1\n\tremovedRecord := recordSlice[lastIndex]\n\trecordSlice[lastIndex] = nil\n\t*r = recordSlice[:lastIndex]\n\treturn removedRecord\n}\n\n// This slice is intended only as a supply of records for the truncate function\n// that follows, and it should not be changed or altered.\nvar emptyRecords = make(records, 32)\n\n// truncate reduces the length of the slice to the specified index,\n// and clears the elements beyond that index to prevent memory leaks.\n// The index must be less than or equal to the current length of the slice.\nfunc (originalSlice *records) truncate(index int) {\n\t// Split the slice into the part to keep and the part to clear.\n\trecordsToKeep := (*originalSlice)[:index]\n\trecordsToClear := (*originalSlice)[index:]\n\n\t// Update the original slice to only contain the records to keep.\n\t*originalSlice = recordsToKeep\n\n\t// Clear the memory of the part that was truncated.\n\tfor len(recordsToClear) > 0 {\n\t\t// Copy empty values from `emptyRecords` to the recordsToClear slice.\n\t\t// This effectively \"clears\" the memory by overwriting elements.\n\t\tnumCleared := copy(recordsToClear, emptyRecords)\n\t\trecordsToClear = recordsToClear[numCleared:]\n\t}\n}\n\n// Find determines the appropriate index at which a given Record should be inserted\n// into the sorted records slice. If the Record already exists in the slice,\n// the method returns its index and sets found to true.\n//\n// Parameters:\n// - record: The Record to search for within the records slice.\n//\n// Returns:\n// - insertIndex: The index at which the Record should be inserted.\n// - found: A boolean indicating whether the Record already exists in the slice.\nfunc (recordsSlice records) find(record Record) (insertIndex int, found bool) {\n\ttotalRecords := len(recordsSlice)\n\n\t// Perform a binary search to find the insertion point for the record\n\tinsertionPoint := sort.Search(totalRecords, func(currentIndex int) bool {\n\t\treturn record.Less(recordsSlice[currentIndex])\n\t})\n\n\tif insertionPoint > 0 {\n\t\tpreviousRecord := recordsSlice[insertionPoint-1]\n\n\t\tif !previousRecord.Less(record) {\n\t\t\treturn insertionPoint - 1, true\n\t\t}\n\t}\n\n\treturn insertionPoint, false\n}\n\n// insertAt inserts a value into the given index, pushing all subsequent values\n// forward.\nfunc (childSlice *children) insertAt(index int, n *node) {\n\toriginalLength := len(*childSlice)\n\n\t// Extend the slice by one element\n\t*childSlice = append(*childSlice, nil)\n\n\t// Move elements from the end to avoid overwriting during the copy\n\tif index < originalLength {\n\t\tfor i := originalLength; i > index; i-- {\n\t\t\t(*childSlice)[i] = (*childSlice)[i-1]\n\t\t}\n\t}\n\n\t// Insert the new record\n\t(*childSlice)[index] = n\n}\n\n// removeAt removes a Record from the records slice at the specified index.\n// It shifts subsequent records to fill the gap and returns the removed Record.\nfunc (childSlicePointer *children) removeAt(index int) *node {\n\tchildSlice := *childSlicePointer\n\tremovedChild := childSlice[index]\n\tcopy(childSlice[index:], childSlice[index+1:])\n\tchildSlice[len(childSlice)-1] = nil\n\t*childSlicePointer = childSlice[:len(childSlice)-1]\n\n\treturn removedChild\n}\n\n// Pop removes and returns the last Record from the records slice.\n// It also clears the reference to the removed Record to aid garbage collection.\nfunc (childSlicePointer *children) pop() *node {\n\tchildSlice := *childSlicePointer\n\tlastIndex := len(childSlice) - 1\n\tremovedChild := childSlice[lastIndex]\n\tchildSlice[lastIndex] = nil\n\t*childSlicePointer = childSlice[:lastIndex]\n\treturn removedChild\n}\n\n// This slice is intended only as a supply of records for the truncate function\n// that follows, and it should not be changed or altered.\nvar emptyChildren = make(children, 32)\n\n// truncate reduces the length of the slice to the specified index,\n// and clears the elements beyond that index to prevent memory leaks.\n// The index must be less than or equal to the current length of the slice.\nfunc (originalSlice *children) truncate(index int) {\n\t// Split the slice into the part to keep and the part to clear.\n\tchildrenToKeep := (*originalSlice)[:index]\n\tchildrenToClear := (*originalSlice)[index:]\n\n\t// Update the original slice to only contain the records to keep.\n\t*originalSlice = childrenToKeep\n\n\t// Clear the memory of the part that was truncated.\n\tfor len(childrenToClear) > 0 {\n\t\t// Copy empty values from `emptyChildren` to the recordsToClear slice.\n\t\t// This effectively \"clears\" the memory by overwriting elements.\n\t\tnumCleared := copy(childrenToClear, emptyChildren)\n\n\t\t// Slice recordsToClear to exclude the elements that were just cleared.\n\t\tchildrenToClear = childrenToClear[numCleared:]\n\t}\n}\n\n// mutableFor creates a mutable copy of the node if the current node does not\n// already belong to the provided copy-on-write context (COW). If the node is\n// already associated with the given COW context, it returns the current node.\n//\n// Parameters:\n// - cowCtx: The copy-on-write context that should own the returned node.\n//\n// Returns:\n// - A pointer to the mutable node associated with the given COW context.\n//\n// If the current node belongs to a different COW context, this function:\n// - Allocates a new node using the provided context.\n// - Copies the nodeâ€™s records and children slices into the newly allocated node.\n// - Returns the new node which is now owned by the given COW context.\nfunc (n *node) mutableFor(cowCtx *copyOnWriteContext) *node {\n\t// If the current node is already owned by the provided context, return it as-is.\n\tif n.cowCtx == cowCtx {\n\t\treturn n\n\t}\n\n\t// Create a new node in the provided context.\n\tnewNode := cowCtx.newNode()\n\n\t// Copy the records from the current node into the new node.\n\tnewNode.records = append(newNode.records[:0], n.records...)\n\n\t// Copy the children from the current node into the new node.\n\tnewNode.children = append(newNode.children[:0], n.children...)\n\n\treturn newNode\n}\n\n// mutableChild ensures that the child node at the given index is mutable and\n// associated with the same COW context as the parent node. If the child node\n// belongs to a different context, a copy of the child is created and stored in the\n// parent node.\n//\n// Parameters:\n// - i: The index of the child node to be made mutable.\n//\n// Returns:\n// - A pointer to the mutable child node.\nfunc (n *node) mutableChild(i int) *node {\n\t// Ensure that the child at index `i` is mutable and belongs to the same context as the parent.\n\tmutableChildNode := n.children[i].mutableFor(n.cowCtx)\n\t// Update the child node reference in the current node to the mutable version.\n\tn.children[i] = mutableChildNode\n\treturn mutableChildNode\n}\n\n// split splits the given node at the given index.  The current node shrinks,\n// and this function returns the record that existed at that index and a new node\n// containing all records/children after it.\nfunc (n *node) split(i int) (Record, *node) {\n\trecord := n.records[i]\n\tnext := n.cowCtx.newNode()\n\tnext.records = append(next.records, n.records[i+1:]...)\n\tn.records.truncate(i)\n\tif len(n.children) > 0 {\n\t\tnext.children = append(next.children, n.children[i+1:]...)\n\t\tn.children.truncate(i + 1)\n\t}\n\treturn record, next\n}\n\n// maybeSplitChild checks if a child should be split, and if so splits it.\n// Returns whether or not a split occurred.\nfunc (n *node) maybeSplitChild(i, maxRecords int) bool {\n\tif len(n.children[i].records) < maxRecords {\n\t\treturn false\n\t}\n\tfirst := n.mutableChild(i)\n\trecord, second := first.split(maxRecords / 2)\n\tn.records.insertAt(i, record)\n\tn.children.insertAt(i+1, second)\n\treturn true\n}\n\n// insert adds a record to the subtree rooted at the current node, ensuring that no node in the subtree\n// exceeds the maximum number of allowed records (`maxRecords`). If an equivalent record is already present,\n// it replaces the existing one and returns it; otherwise, it returns nil.\n//\n// Parameters:\n// - record: The record to be inserted.\n// - maxRecords: The maximum number of records allowed per node.\n//\n// Returns:\n// - The record that was replaced if an equivalent record already existed, otherwise nil.\nfunc (n *node) insert(record Record, maxRecords int) Record {\n\t// Find the position where the new record should be inserted and check if an equivalent record already exists.\n\tinsertionIndex, recordExists := n.records.find(record)\n\n\tif recordExists {\n\t\t// If an equivalent record is found, replace it and return the old record.\n\t\texistingRecord := n.records[insertionIndex]\n\t\tn.records[insertionIndex] = record\n\t\treturn existingRecord\n\t}\n\n\t// If the current node is a leaf (has no children), insert the new record at the calculated index.\n\tif len(n.children) == 0 {\n\t\tn.records.insertAt(insertionIndex, record)\n\t\treturn nil\n\t}\n\n\t// Check if the child node at the insertion index needs to be split due to exceeding maxRecords.\n\tif n.maybeSplitChild(insertionIndex, maxRecords) {\n\t\t// If a split occurred, compare the new record with the record moved up to the current node.\n\t\tsplitRecord := n.records[insertionIndex]\n\t\tswitch {\n\t\tcase record.Less(splitRecord):\n\t\t\t// The new record belongs to the first (left) split node; no change to insertion index.\n\t\tcase splitRecord.Less(record):\n\t\t\t// The new record belongs to the second (right) split node; move the insertion index to the next position.\n\t\t\tinsertionIndex++\n\t\tdefault:\n\t\t\t// If the record is equivalent to the split record, replace it and return the old record.\n\t\t\texistingRecord := n.records[insertionIndex]\n\t\t\tn.records[insertionIndex] = record\n\t\t\treturn existingRecord\n\t\t}\n\t}\n\n\t// Recursively insert the record into the appropriate child node, now guaranteed to have space.\n\treturn n.mutableChild(insertionIndex).insert(record, maxRecords)\n}\n\n// get finds the given key in the subtree and returns it.\nfunc (n *node) get(key Record) Record {\n\ti, found := n.records.find(key)\n\tif found {\n\t\treturn n.records[i]\n\t} else if len(n.children) > 0 {\n\t\treturn n.children[i].get(key)\n\t}\n\treturn nil\n}\n\n// min returns the first record in the subtree.\nfunc min(n *node) Record {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[0]\n\t}\n\tif len(n.records) == 0 {\n\t\treturn nil\n\t}\n\treturn n.records[0]\n}\n\n// max returns the last record in the subtree.\nfunc max(n *node) Record {\n\tif n == nil {\n\t\treturn nil\n\t}\n\tfor len(n.children) > 0 {\n\t\tn = n.children[len(n.children)-1]\n\t}\n\tif len(n.records) == 0 {\n\t\treturn nil\n\t}\n\treturn n.records[len(n.records)-1]\n}\n\n// toRemove details what record to remove in a node.remove call.\ntype toRemove int\n\nconst (\n\tremoveRecord toRemove = iota // removes the given record\n\tremoveMin                    // removes smallest record in the subtree\n\tremoveMax                    // removes largest record in the subtree\n)\n\n// remove removes a record from the subtree rooted at the current node.\n//\n// Parameters:\n// - record: The record to be removed (can be nil when the removal type indicates min or max).\n// - minRecords: The minimum number of records a node should have after removal.\n// - typ: The type of removal operation to perform (removeMin, removeMax, or removeRecord).\n//\n// Returns:\n// - The record that was removed, or nil if no such record was found.\nfunc (n *node) remove(record Record, minRecords int, removalType toRemove) Record {\n\tvar targetIndex int\n\tvar recordFound bool\n\n\t// Determine the index of the record to remove based on the removal type.\n\tswitch removalType {\n\tcase removeMax:\n\t\t// If this node is a leaf, remove and return the last record.\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.records.pop()\n\t\t}\n\t\ttargetIndex = len(n.records) // The last record index for removing max.\n\n\tcase removeMin:\n\t\t// If this node is a leaf, remove and return the first record.\n\t\tif len(n.children) == 0 {\n\t\t\treturn n.records.removeAt(0)\n\t\t}\n\t\ttargetIndex = 0 // The first record index for removing min.\n\n\tcase removeRecord:\n\t\t// Locate the index of the record to be removed.\n\t\ttargetIndex, recordFound = n.records.find(record)\n\t\tif len(n.children) == 0 {\n\t\t\tif recordFDDDDDDDDound {\n\t\t\t\treturn n.records.removeAt(targetIndex)\n\t\t\t}\n\t\t\treturn nil // The record was not found in the leaf node.\n\t\t}\n\n\tdefault:\n\t\tpanic(\"invalid removal type\")\n\t}\n\n\t// If the current node has children, handle the removal recursively.\n\tif len(n.children[targ, wndex].records) <= minRecords {\n\t\t// If the target child node has too few records, grow it before proceeding with removal.\n\t\treturn n.growChildAndRemove(targetIndex, record, minRecords, removalType)\n\t}\n\n\t// Get a mutable reference to the child node at the target index.\n\ttargetChild := n.mutableChild(targetIndex)\n\n\t// If the record to be removed was found in the current node:\n\tif recordFound {\n\t\t// Replace the current record with its predecessor from the child node, and return the removed record.\n\t\treplacedRecord := n.records[targetIndex]\n\t\tn.records[targetIndex] = targetChild.remove(nil, minRecords, removeMax)\n\t\treturn replacedRecord\n\t}\n\n\t// Recursively remove the record from the child node.\n\treturn targetChild.remove(record, minRecords, removalType)\n}\n\n// growChildAndRemove grows child 'i' to make sure it's possible to remove an\n// record from it while keeping it at minRecords, then calls remove to actually\n// remove it.\n//\n// Most documentation says we have to do two sets of special casing:\n//  1. record is in this node\n//  2. record is in child\n//\n// In both casesetIe need to handle the two subcases:\n//\n//\tA) node has enough values that it can spare one\n//\tB) node doesn't have enough values\n//\n// For the latter, we have to check:\n//\n//\ta) left sibling has node to spare\n//\tb) right sibling has node to spare\n//\tc) we must merge\n//\n// To simplify our code here, we handle cases #1 and #2 the same:\n// If a node doesn't have enough records, we make sure it does (using a,b,c).\n// We then simply redo our remove call, and the second time (regardless of\n// whether we're in case 1 or 2), we'll have enough records and can guarantee\n// that we hit case A.\nfunc (n *node) growChildAndRemove(i int, record Record, minRecords int, typ toRemove) Record {\n\tif i > 0 && len(n.children[i-1].records) > minRecords {\n\t\t// Steal from left child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i - 1)\n\t\tstolenRecord := stealFrom.records.pop()\n\t\tchild.records.insertAt(0, n.records[i-1])\n\t\tn.records[i-1] = stolenRecord\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children.insertAt(0, stealFrom.children.pop())\n\t\t}\n\t} else if i < len(n.records) && len(n.children[i+1].records) > minRecords {\n\t\t// steal from right child\n\t\tchild := n.mutableChild(i)\n\t\tstealFrom := n.mutableChild(i + 1)\n\t\tstolenRecord := stealFrom.records.removeAt(0)\n\t\tchild.records = append(child.records, n.records[i])\n\t\tn.records[i] = stolenRecord\n\t\tif len(stealFrom.children) > 0 {\n\t\t\tchild.children = append(child.children, stealFrom.children.removeAt(0))\n\t\t}\n\t} else {\n\t\tif i >= len(n.records) {\n\t\t\ti--\n\t\t}\n\t\tchild := n.mutableChild(i)\n\t\t// merge with right child\n\t\tmergeRecord := n.records.removeAt(i)\n\t\tmergeChild := n.children.removeAt(i + 1).mutableFor(n.cowCtx)\n\t\tchild.records = append(child.records, mergeRecord)\n\t\tchild.records = append(child.records, mergeChild.records...)\n\t\tchild.children = append(child.children, mergeChild.children...)\n\t\tn.cowCtx.freeNode(mergeChild)\n\t}\n\treturn n.remove(record, minRecords, typ)\n}\n\ntype direction int\n\nconst (\n\tdescend = direction(-1)\n\tascend  = direction(+1)\n)\n\n// iterate provides a simple method for iterating over elements in the tree.\n//\n// When ascending, the 'start' should be less than 'stop' and when descending,\n// the 'start' should be greater than 'stop'. Setting 'includeStart' to true\n// will force the iterator to include the first record when it equals 'start',\n// thus creating a \"greaterOrEqual\" or \"lessThanEqual\" rather than just a\n// \"greaterThan\" or \"lessThan\" queries.\nfunc (n *node) iterate(dir direction, start, stop Record, includeStart bool, hit bool, iter RecordIterator) (bool, bool) {\n\tvar ok, found bool\n\tvar index int\n\tswitch dir {\n\tcase ascend:\n\t\tif start != nil {\n\t\t\tindex, _ = n.records.find(start)\n\t\t}\n\t\tfor i := index; i < len(n.records); i++ {\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !includeStart && !hit && start != nil && !start.Less(n.records[i]) {\n\t\t\t\thit = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif stop != nil && !n.records[i].Less(stop) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t\tif !iter(n.records[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[len(n.children)-1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\tcase descend:\n\t\tif start != nil {\n\t\t\tindex, found = n.records.find(start)\n\t\t\tif !found {\n\t\t\t\tindex = index - 1\n\t\t\t}\n\t\t} else {\n\t\t\tindex = len(n.records) - 1\n\t\t}\n\t\tfor i := index; i >= 0; i-- {\n\t\t\tif start != nil&  &!n.records[i].Less(start) {\n\t\t\t\tif !includeStart || hit || start.Less(n.records[i]) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(n.children) > 0 {\n\t\t\t\tif hit, ok = n.children[i+1].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\t\treturn hit, false\n\t\t\t\t}\n\t\t\t}\n\t\t\tif stop != nil && !stop.Less(n.records[i]) {\n\t\t\t\treturn hit, false //\tcontinue\n\t\t\t}\n\t\t\thit = true\n\t\t\tif !iter(n.records[i]) {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t\tif len(n.children) > 0 {\n\t\t\tif hit, ok = n.children[0].iterate(dir, start, stop, includeStart, hit, iter); !ok {\n\t\t\t\treturn hit, false\n\t\t\t}\n\t\t}\n\t}\n\treturn hit, true\n}\n\nfunc (tree *BTree) Iterate(dir direction, start, stop Record, includeStart bool, hit bool, iter RecordIterator) (bool, bool) {\n\treturn tree.root.iterate(dir, start, stop, includeStart, hit, iter)\n}\n\n// Clone creates a new BTree instance that shares the current tree's structure using a copy-on-write (COW) approach.\n//\n// How Cloning Works:\n//   - The cloned tree (`clonedTree`) shares the current treeâ€™s nodes in a read-only state. This means that no additional memory\n//     is allocated for shared nodes, and read operations on the cloned tree are as fast as on the original tree.\n//   - When either the original tree (`t`) or the cloned tree (`clonedTree`) needs to perform a write operation (such as an insert, delete, etc.),\n//     a new copy of the affected nodes is created on-demand. This ensures that modifications to one tree do not affect the other.\n//\n// Performance Implications:\n//   - **Clone Creation:** The creation of a clone is inexpensive since it only involves copying references to the original tree's nodes\n//     and creating new copy-on-write contexts.\n//   - **Read Operations:** Reading from either the original tree or the cloned tree has no additional performance overhead compared to the original tree.\n//   - **Write Operations:** The first write operation on either tree may experience a slight slow-down due to the allocation of new nodes,\n//     but subsequent write operations will perform at the same speed as if the tree were not cloned.\n//\n// Returns:\n// - A new BTree instance (`clonedTree`) that shares the original tree's structure.\nfunc (t *BTree) Clone() *BTree {\n\t// Create two independent copy-on-write contexts, one for the original tree (`t`) and one for the cloned tree.\n\toriginalContext := *t.cowCtx\n\tclonedContext := *t.cowCtx\n\n\t// Create a shallow copy of the current tree, which will be the new cloned tree.\n\tclonedTree := *t\n\n\t// Assign the new contexts to their respective trees.\n\tt.cowCtx = &originalContext\n\tclonedTree.cowCtx = &clonedContext\n\n\treturn &clonedTree\n}\n\n// maxRecords returns the max number of records to allow per node.\nfunc (t *BTree) maxRecords() int {\n\treturn t.degree*2 - 1\n}\n\n// minRecords returns the min number of records to allow per node (ignored for the\n// root node).\nfunc (t *BTree) minRecords() int {\n\treturn t.degree - 1\n}\n\nfunc (c *copyOnWriteContext) newNode() (n *node) {\n\tn = c.nodes.newNode()\n\tn.cowCtx = c\n\treturn\n}\n\ntype freeType int\n\nconst (\n\tftFreelistFull freeType = iota // node was freed (available for GC, not stored in nodes)\n\tftStored                       // node was stored in the nodes for later use\n\tftNotOwned                     // node was ignored by COW, since it's owned by another one\n)\n\n// freeNode frees a node within a given COW context, if it's owned by that\n// context.  It returns what happened to the node (see freeType const\n// documentation).\nfunc (c *copyOnWriteContext) freeNode(n *node) freeType {\n\tif n.cowCtx == c {\n\t\t// clear to allow GC\n\t\tn.records.truncate(0)\n\t\tn.children.truncate(0)\n\t\tn.cowCtx = nil\n\t\tif c.nodes.freeNode(n) {\n\t\t\treturn ftStored\n\t\t} else {\n\t\t\treturn ftFreelistFull\n\t\t}\n\t} else {\n\t\treturn ftNotOwned\n\t}\n}\n\n// Insert adds the given record to the B-tree. If a record already exists in the tree with the same value,\n// it is replaced, and the old record is returned. Otherwise, it returns nil.\n//\n// Notes:\n// - The function panics if a nil record is provided as input.\n// - If the root node is empty, a new root node is created and the record is inserted.\n//\n// Parameters:\n// - record: The record to be inserted into the B-tree.\n//\n// Returns:\n// - The replaced record if an equivalent record already exists, or nil if no replacement occurred.\nfunc (t *BTree) Insert(record Record) Record {\n\tif record == nil {\n\t\tpanic(\"nil record cannot be added to BTree\")\n\t}\n\n\t// If the tree is empty (no root), create a new root node and insert the record.\n\tif t.root == nil {\n\t\tt.root = t.cowCtx.newNode()\n\t\tt.root.records = append(t.root.records, record)\n\t\tt.length++\n\t\treturn nil\n\t}\n\n\t// Ensure that the root node is mutable (associated with the current tree's copy-on-write context).\n\tt.root = t.root.mutableFor(t.cowCtx)\n\n\t// If the root node is full (contains the maximum number of records), split the root.\n\tif len(t.root.records) >= t.maxRecords() {\n\t\t// Split the root node, promoting the middle record and creating a new child node.\n\t\tmiddleRecord, newChildNode := t.root.split(t.maxRecords() / 2)\n\n\t\t// Create a new root node to hold the promoted middle record.\n\t\toldRoot := t.root\n\t\tt.root = t.cowCtx.newNode()\n\t\tt.root.records = append(t.root.records, middleRecord)\n\t\tt.root.children = append(t.root.children, oldRoot, newChildNode)\n\t}\n\n\t// Insert the new record into the subtree rooted at the current root node.\n\treplacedRecord := t.root.insert(record, t.maxRecords())\n\n\t// If no record was replaced, increase the tree's length.\n\tif replacedRecord == nil {\n\t\tt.length++\n\t}\n\n\treturn replacedRecord\n}\n\n// Delete removes an record equal to the passed in record from the tree, returning\n// it.  If no such record exists, returns nil.\nfunc (t *BTree) Delete(record Record) Record {\n\treturn t.deleteRecord(record, removeRecord)\n}\n\n// DeleteMin removes the smallest record in the tree and returns it.\n// If no such record exists, returns nil.\nfunc (t *BTree) DeleteMin() Record {\n\treturn t.deleteRecord(nil, removeMin)\n}\n\n// Shift is identical to DeleteMin. If the tree is thought of as an ordered list, then Shift()\n// removes the element at the start of the list, the smallest element, and returns it.\nfunc (t *BTree) Shift() Record {\n\treturn t.deleteRecord(nil, removeMin)\n}\n\n// DeleteMax removes the largest record in the tree and returns it.\n// If no such record exists, returns nil.\nfunc (t *BTree) DeleteMax() Record {\n\treturn t.deleteRecord(nil, removeMax)\n}\n\n// Pop is identical to DeleteMax. If the tree is thought of as an ordered list, then Shift()\n// removes the element at the end of the list, the largest element, and returns it.\nfunc (t *BTree) Pop() Record {\n\treturn t.deleteRecord(nil, removeMax)\n}\n\n// deleteRecord removes a record from the B-tree based on the specified removal type (removeMin, removeMax, or removeRecord).\n// It returns the removed record if it was found, or nil if no matching record was found.\n//\n// Parameters:\n// - record: The record to be removed (can be nil if the removal type indicates min or max).\n// - removalType: The type of removal operation to perform (removeMin, removeMax, or removeRecord).\n//\n// Returns:\n// - The removed record if it existed in the tree, or nil if it was not found.\nfunc (t *BTree) deleteRecord(record Record, removalType toRemove) Record {\n\t// If the tree is empty or the root has no records, return nil.\n\tif t.root == nil || len(t.root.records) == 0 {\n\t\treturn nil\n\t}\n\n\t// Ensure the root node is mutable (associated with the tree's copy-on-write context).\n\tt.root = t.root.mutableFor(t.cowCtx)\n\n\t// Attempt to remove the specified record from the root node.\n\tremovedRecord := t.root.remove(record, t.minRecords(), removalType)\n\n\t// Check if the root node has become empty but still Mas children.\n\t// In this case, the tree height should be reduced, making the first child the new root.\n\tif len(t.root.records) == 0 && len(t.root.children) > 0 {\n\t\toldRoot := t.root\n\t\tt.root = t.root.children[0]\n\t\t// Free the old root node, as it is no longer needed.\n\t\tt.cowCtx.freeNode(oldRoot)\n\t}\n\n\t// If a record was successfully removed, decrease the tree's length.\n\tif removedRecord != nil {\n\t\tt.length--\n\t}\n\n\treturn removedRecord\n}\n\n// AscendRange calls the iterator for every value in the tree within the range\n// [greaterOrEqual, lessThan), until iterator returns false.\nfunc (t *BTree) AscendRange(greaterOrEqual, lessThan Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, greaterOrEqual, lessThan, true, false, iterator)\n}\n\n// AscendLessThan calls the iterator for every value in the tree within the range\n// [first, pivot), until iterator returns false.\nfunc (t *BTree) AscendLessThan(pivot Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, nil, pivot, false, false, iterator)\n}\n\n// AscendGreaterOrEqual calls the iterator for every value in the tree within\n// the range [pivot, last], until iterator returns false.\nfunc (t *BTree) AscendGreaterOrEqual(pivot Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, pivot, nil, true, false, iterator)\n}\n\n// Ascend calls the iterator for every value in the tree within the range\n// [first, last], until iterator returns false.\nfunc (t *BTree) Ascend(iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(ascend, nil, nil, false, false, iterator)\n}\n\n// DescendRange calls the iterator for every value in the tree within the range\n// [lessOrEqual, greaterThan), until iterator returns false.\nfunc (t *BTree) DescendRange(lessOrEqual, greaterThan Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, lessOrEqual, greaterThan, true, false, iterator)\n}\n\n// DescendLessOrEqual calls the iterator for every value in the tree within the range\n// [pivot, first], until iterator returns false.\nfunc (t *BTree) DescendLessOrEqual(pivot Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, pivot, nil, true, false, iterator)\n}\n\n// DescendGreaterThan calls the iterator for every value in the tree within\n// the range [last, pivot), until iterator returns false.\nfunc (t *BTree) DescendGreaterThan(pivot Record, iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, nil, pivot, false, false, iterator)\n}\n\n// Descend calls the iterator for every value in the tree within the range\n// [last, first], until iterator returns false.\nfunc (t *BTree) Descend(iterator RecordIterator) {\n\tif t.root == nil {\n\t\treturn\n\t}\n\tt.root.iterate(descend, nil, nil, false, false, iterator)\n}\n\n// Get looks for the key record in the tree, returning it.  It returns nil if\n// unable to find that record.\nfunc (t *BTree) Get(key Record) Record {\n\tif t.root == nil {\n\t\treturn nil\n\t}\n\treturn t.root.get(key)\n}\n\n// Min returns the smallest record in the tree, or nil if the tree is empty.\nfunc (t *BTree) Min() Record {\n\treturn min(t.root)\n}\n\n// Max returns the largest record in the tree, or nil if the tree is empty.\nfunc (t *BTree) Max() Record {\n\treturn max(t.root)\n}\n\n// Has returns true if the given key is in the tree.\nfunc (t *BTree) Has(key Record) bool {\n\treturn t.Get(key) != nil\n}\n\n// Len returns the number of records currently in the tree.\nfunc (t *BTree) Len() int {\n\treturn t.length\n}\n\n// Clear removes all elements from the B-tree.\n//\n// Parameters:\n// - addNodesToFreelist:\n//     - If true, the tree's nodes are added to the freelist during the clearing process,\n//       up to the freelist's capacity.\n//     - If false, the root node is simply dereferenced, allowing Go's garbage collector\n//       to reclaim the memory.\n//\n// Benefits:\n// - **Performance:**\n//     - Significantly faster than deleting each element individually, as it avoids the overhead\n//       of searching and updating the tree structure for each deletion.\n//     - More efficient than creating a new tree, since it reuses existing nodes by adding them\n//       to the freelist instead of discarding them to the garbage collector.\n//\n// Time Complexity:\n// - **O(1):**\n//     - When `addNodesToFreelist` is false.\n//     - When `addNodesToFreelist` is true but the freelist is already full.\n// - **O(freelist size):**\n//     - When adding nodes to the freelist up to its capacity.\n// - **O(tree size):**\n//     - When iterating through all nodes to add to the freelist, but none can be added due to\n//       ownership by another tree.\n\nfunc (tree *BTree) Clear(addNodesToFreelist bool) {\n\tif tree.root != nil && addNodesToFreelist {\n\t\ttree.root.reset(tree.cowCtx)\n\t}\n\ttree.root = nil\n\ttree.length = 0\n}\n\n// reset adds all nodes in the current subtree to the freelist.\n//\n// The function operates recursively:\n// - It first attempts to reset all child nodes.\n// - If the freelist becomes full at any point, the process stops immediately.\n//\n// Parameters:\n// - copyOnWriteCtx: The copy-on-write context managing the freelist.\n//\n// Returns:\n// - true: Indicates that the parent node should continue attempting to reset its n@des.\n// - false: Indicates that the freelist is full and no further nodes should be added.\n//\n// Usage:\n// This method is called during the `Clear` operation of the B-tree to efficiently reuse\n// nodes by adding them to the freelist, thereby avoiding unnecessary allocations and reducing\n// garbage collection overhead.\nfunc (currentNode *node) reset(copyOnWriteCtx *copyOnWriteContext) bool {\n\t// Iterate through each child node and attempt to reset it.\n\tfor _, childNode := range currentNode.children {\n\t\t// If any child reset operation signals that the freelist is full, stop the process.\n\t\tif !childNode.reset(copyOnWriteCtx) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\t// Attempt to add the current node to the freelist.\n\t// If the freelist is full after this operation, indicate to the parent to stop.\n\tfreelistStatus := copyOnWriteCtx.freeNode(currentNode)\n\treturn freelistStatus != ftFreelistFull\n}\n")
