# Test AVL001: comprehensive test for unbounded AVL iteration detection
# Tests: detection, bounded (no detection), and nolint suppression

# Test 1: Unbounded iteration should trigger AVL001
gno lint ./unbounded

stderr 'AVL001'
stderr 'unbounded'

# Test 2: Bounded iteration should NOT trigger AVL001
gno lint ./bounded

! stderr 'AVL001'

# Test 3: Nolint should suppress AVL001
gno lint ./nolint

! stderr 'AVL001'

-- gnowork.toml --

-- p/nt/avl/gnomod.toml --
module = "gno.land/p/nt/avl"
gno = "0.9"

-- p/nt/avl/avl.gno --
package avl

type IterCbFn func(key string, value any) bool

type Tree struct{}

func NewTree() *Tree {
	return &Tree{}
}

func (tree *Tree) Iterate(start, end string, cb IterCbFn) bool {
	return false
}

func (tree *Tree) ReverseIterate(start, end string, cb IterCbFn) bool {
	return false
}

-- unbounded/main.gno --
package main

import "gno.land/p/nt/avl"

var tree = avl.NewTree()

func Render(path string) string {
	result := ""
	tree.Iterate("", "", func(k string, v interface{}) bool {
		result += k
		return false
	})
	return result
}

-- unbounded/gnomod.toml --
module = "gno.land/r/test/avl001/unbounded"
gno = "0.9"

-- bounded/main.gno --
package main

import "gno.land/p/nt/avl"

var tree = avl.NewTree()

func Render(path string) string {
	result := ""
	tree.Iterate("a", "z", func(k string, v interface{}) bool {
		result += k
		return false
	})
	return result
}

-- bounded/gnomod.toml --
module = "gno.land/r/test/avl001/bounded"
gno = "0.9"

-- nolint/main.gno --
package main

import "gno.land/p/nt/avl"

var tree = avl.NewTree()

func Render(path string) string {
	result := ""
	//nolint:AVL001
	tree.Iterate("", "", func(k string, v interface{}) bool {
		result += k
		return false
	})
	return result
}

-- nolint/gnomod.toml --
module = "gno.land/r/test/avl001/nolint"
gno = "0.9"
