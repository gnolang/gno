// Code generated by the genstd tool (@/misc/genstd); DO NOT EDIT.
// To regenerate it, run `go generate` from this directory.

package stdlibs

import (
	"reflect"

	gno "github.com/gnolang/gno/gnovm/pkg/gnolang"
	libs_chain "github.com/gnolang/gno/gnovm/stdlibs/chain"
	libs_chain_banker "github.com/gnolang/gno/gnovm/stdlibs/chain/banker"
	libs_chain_params "github.com/gnolang/gno/gnovm/stdlibs/chain/params"
	libs_chain_runtime "github.com/gnolang/gno/gnovm/stdlibs/chain/runtime"
	libs_crypto_ed25519 "github.com/gnolang/gno/gnovm/stdlibs/crypto/ed25519"
	libs_crypto_sha256 "github.com/gnolang/gno/gnovm/stdlibs/crypto/sha256"
	libs_math "github.com/gnolang/gno/gnovm/stdlibs/math"
	libs_runtime "github.com/gnolang/gno/gnovm/stdlibs/runtime"
	libs_sys_params "github.com/gnolang/gno/gnovm/stdlibs/sys/params"
	libs_time "github.com/gnolang/gno/gnovm/stdlibs/time"
)

// NativeFunc represents a function in the standard library which has a native
// (go-based) implementation, commonly referred to as a "native binding".
type NativeFunc struct {
	gnoPkg     string
	gnoFunc    gno.Name
	params     []gno.FieldTypeExpr
	results    []gno.FieldTypeExpr
	hasMachine bool
	f          func(m *gno.Machine)
}

// HasMachineParam returns whether the given native binding has a machine parameter.
// This means that the Go version of this function expects a *gno.Machine
// as its first parameter.
func (n *NativeFunc) HasMachineParam() bool {
	return n.hasMachine
}

var nativeFuncs = [...]NativeFunc{
	{
		"chain",
		"packageAddress",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_chain.X_packageAddress(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain",
		"deriveStorageDepositAddr",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_chain.X_deriveStorageDepositAddr(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain",
		"emit",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]string")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []string
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain.X_emit(
				m,
				p0, p1)
		},
	},
	{
		"chain/banker",
		"bankerGetCoins",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("[]int64")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0, r1 := libs_chain_banker.X_bankerGetCoins(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"chain/banker",
		"bankerSendCoins",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("uint8")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p4"), Type: gno.X("[]int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  uint8
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  []string
				rp3 = reflect.ValueOf(&p3).Elem()
				p4  []int64
				rp4 = reflect.ValueOf(&p4).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)
			tv4 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 4, "")).TV
			tv4.DeepFill(m.Store)
			gno.Gno2GoValue(tv4, rp4)

			libs_chain_banker.X_bankerSendCoins(
				m,
				p0, p1, p2, p3, p4)
		},
	},
	{
		"chain/banker",
		"bankerTotalCoin",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("int64")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_chain_banker.X_bankerTotalCoin(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain/banker",
		"bankerIssueCoin",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  int64
				rp2 = reflect.ValueOf(&p2).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)

			libs_chain_banker.X_bankerIssueCoin(
				m,
				p0, p1, p2)
		},
	},
	{
		"chain/banker",
		"bankerRemoveCoin",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  int64
				rp2 = reflect.ValueOf(&p2).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)

			libs_chain_banker.X_bankerRemoveCoin(
				m,
				p0, p1, p2)
		},
	},
	{
		"chain/banker",
		"assertCallerIsRealm",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			libs_chain_banker.X_assertCallerIsRealm(
				m,
			)
		},
	},
	{
		"chain/banker",
		"originSend",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("[]int64")},
		},
		true,
		func(m *gno.Machine) {
			r0, r1 := libs_chain_banker.X_originSend(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"chain/params",
		"SetString",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetString(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"SetBool",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("bool")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  bool
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetBool(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"SetInt64",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  int64
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetInt64(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"SetUint64",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("uint64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  uint64
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetUint64(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"SetBytes",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]byte")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []byte
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetBytes(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"SetStrings",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]string")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []string
				rp1 = reflect.ValueOf(&p1).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)

			libs_chain_params.SetStrings(
				m,
				p0, p1)
		},
	},
	{
		"chain/params",
		"UpdateParamStrings",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("bool")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  bool
				rp2 = reflect.ValueOf(&p2).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)

			libs_chain_params.UpdateParamStrings(
				m,
				p0, p1, p2)
		},
	},
	{
		"chain/runtime",
		"AssertOriginCall",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			libs_chain_runtime.AssertOriginCall(
				m,
			)
		},
	},
	{
		"chain/runtime",
		"ChainID",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			r0 := libs_chain_runtime.ChainID(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain/runtime",
		"ChainDomain",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			r0 := libs_chain_runtime.ChainDomain(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain/runtime",
		"ChainHeight",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("int64")},
		},
		true,
		func(m *gno.Machine) {
			r0 := libs_chain_runtime.ChainHeight(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain/runtime",
		"originCaller",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			r0 := libs_chain_runtime.X_originCaller(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"chain/runtime",
		"getRealm",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("int")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  int
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0, r1 := libs_chain_runtime.X_getRealm(
				m,
				p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
	{
		"crypto/ed25519",
		"verify",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("[]byte")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("[]byte")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("[]byte")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  []byte
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  []byte
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  []byte
				rp2 = reflect.ValueOf(&p2).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)

			r0 := libs_crypto_ed25519.X_verify(p0, p1, p2)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"crypto/sha256",
		"sum256",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("[]byte")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[32]byte")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  []byte
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_crypto_sha256.X_sum256(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"math",
		"Float32bits",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("float32")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("uint32")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  float32
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_math.Float32bits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"math",
		"Float32frombits",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("uint32")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("float32")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  uint32
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_math.Float32frombits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"math",
		"Float64bits",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("float64")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("uint64")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  float64
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_math.Float64bits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"math",
		"Float64frombits",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("uint64")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("float64")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  uint64
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0 := libs_math.Float64frombits(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"runtime",
		"GC",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			libs_runtime.GC(
				m,
			)
		},
	},
	{
		"runtime",
		"MemStats",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("string")},
		},
		true,
		func(m *gno.Machine) {
			r0 := libs_runtime.MemStats(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
		},
	},
	{
		"sys/params",
		"setSysParamString",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  string
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamString(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"setSysParamBool",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("bool")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  bool
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamBool(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"setSysParamInt64",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("int64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  int64
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamInt64(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"setSysParamUint64",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("uint64")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  uint64
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamUint64(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"setSysParamBytes",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("[]byte")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  []byte
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamBytes(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"setSysParamStrings",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("[]string")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  []string
				rp3 = reflect.ValueOf(&p3).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)

			libs_sys_params.X_setSysParamStrings(
				m,
				p0, p1, p2, p3)
		},
	},
	{
		"sys/params",
		"updateSysParamStrings",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p1"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p2"), Type: gno.X("string")},
			{NameExpr: *gno.Nx("p3"), Type: gno.X("[]string")},
			{NameExpr: *gno.Nx("p4"), Type: gno.X("bool")},
		},
		[]gno.FieldTypeExpr{},
		true,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
				p1  string
				rp1 = reflect.ValueOf(&p1).Elem()
				p2  string
				rp2 = reflect.ValueOf(&p2).Elem()
				p3  []string
				rp3 = reflect.ValueOf(&p3).Elem()
				p4  bool
				rp4 = reflect.ValueOf(&p4).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)
			tv1 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 1, "")).TV
			tv1.DeepFill(m.Store)
			gno.Gno2GoValue(tv1, rp1)
			tv2 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 2, "")).TV
			tv2.DeepFill(m.Store)
			gno.Gno2GoValue(tv2, rp2)
			tv3 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 3, "")).TV
			tv3.DeepFill(m.Store)
			gno.Gno2GoValue(tv3, rp3)
			tv4 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 4, "")).TV
			tv4.DeepFill(m.Store)
			gno.Gno2GoValue(tv4, rp4)

			libs_sys_params.X_updateSysParamStrings(
				m,
				p0, p1, p2, p3, p4)
		},
	},
	{
		"time",
		"now",
		[]gno.FieldTypeExpr{},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("int64")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("int32")},
			{NameExpr: *gno.Nx("r2"), Type: gno.X("int64")},
		},
		true,
		func(m *gno.Machine) {
			r0, r1, r2 := libs_time.X_now(
				m,
			)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r2).Elem(),
			))
		},
	},
	{
		"time",
		"loadFromEmbeddedTZData",
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("p0"), Type: gno.X("string")},
		},
		[]gno.FieldTypeExpr{
			{NameExpr: *gno.Nx("r0"), Type: gno.X("[]byte")},
			{NameExpr: *gno.Nx("r1"), Type: gno.X("bool")},
		},
		false,
		func(m *gno.Machine) {
			b := m.LastBlock()
			var (
				p0  string
				rp0 = reflect.ValueOf(&p0).Elem()
			)

			tv0 := b.GetPointerTo(nil, gno.NewValuePathBlock(1, 0, "")).TV
			tv0.DeepFill(m.Store)
			gno.Gno2GoValue(tv0, rp0)

			r0, r1 := libs_time.X_loadFromEmbeddedTZData(p0)

			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r0).Elem(),
			))
			m.PushValue(gno.Go2GnoValue(
				m.Alloc,
				m.Store,
				reflect.ValueOf(&r1).Elem(),
			))
		},
	},
}

var initOrder = [...]string{
	"errors",
	"internal/bytealg",
	"io",
	"unicode",
	"unicode/utf8",
	"bytes",
	"strings",
	"bufio",
	"math/overflow",
	"sort",
	"math/bits",
	"math",
	"strconv",
	"chain",
	"chain/runtime",
	"chain/banker",
	"chain/params",
	"crypto/bech32",
	"encoding/binary",
	"crypto/chacha20/chacha",
	"crypto/cipher",
	"crypto/chacha20",
	"crypto/chacha20/rand",
	"crypto/ed25519",
	"crypto/sha256",
	"crypto/subtle",
	"encoding",
	"encoding/base32",
	"encoding/base64",
	"encoding/csv",
	"encoding/hex",
	"hash",
	"hash/adler32",
	"html",
	"math/rand",
	"path",
	"net/url",
	"regexp/syntax",
	"regexp",
	"runtime",
	"sys/params",
	"time",
	"unicode/utf16",
}

// InitOrder returns the initialization order of the standard libraries.
// This is calculated starting from the list of all standard libraries and
// iterating through each: if a package depends on an unitialized package, that
// is processed first, and so on recursively; matching the behaviour of Go's
// [program initialization].
//
// [program initialization]: https://go.dev/ref/spec#Program_initialization
func InitOrder() []string {
	return initOrder[:]
}
