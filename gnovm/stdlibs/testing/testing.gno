// Shim for Go's "testing" package to support minimal testing types.
package testing

import (
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
)

//----------------------------------------
// Top level functions

// skipErr is the type of the panic created by SkipNow
// and FailNow. Having it as a simple string means that it can be fmt.Printf'd
// easily (and doesn't get "corrupted" through gno2go).
type skipErr string

func (s skipErr) Error() string {
	return string(s)
}

// Recover functions like recover(), but it ensures that the recovered error is
// not an internal error of the testing package.
//
// Due to a lack of goroutines and thus runtime.Goexit, gno's testing system resorts
// to panics to abort testing with FailNow (and Fatal* functions) or SkipNow
// (and Skip* functions).
//
// NOTE: Recover() is likely to be removed.
func Recover(result Setter) {
	r := recover()
	if _, ok := r.(skipErr); !ok {
		result.Set(r)
		return
	}

	panic(r)
}

type Setter interface {
	Set(v interface{})
}

func Short() bool {
	return true // TODO configure somehow.
}

func Verbose() bool {
	return true // TODO configure somehow.
}

// Like AllocsPerRun() but returns an integer.
// TODO: actually compute allocations; for now return 0.
func AllocsPerRun2(runs int, f func()) (total int) {
	for i := 0; i < runs; i++ {
		f()
	}
	return 0
}

//----------------------------------------
// T

type T struct {
	name      string
	failed    bool
	skipped   bool
	subs      []*T
	parent    *T
	output    []byte // Output generated by test
	verbose   bool
	runFilter filterMatch
	dur       string
}

func NewT(name string) *T {
	return &T{name: name}
}

type testingFunc func(*T)

// Not yet implemented:
// func (t *T) Cleanup(f func()) {
// func (t *T) Deadline() (deadline time.Time, ok bool)
func (t *T) Error(args ...interface{}) {
	t.Log(args...)
	t.Fail()
}

func (t *T) Errorf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.Fail()
}

func (t *T) Fail() {
	t.failed = true
}

func (t *T) FailNow() {
	t.Fail()
	panic(skipErr("testing: you have recovered a panic attempting to interrupt a test, as a consequence of FailNow. " +
		"Use testing.Recover to recover panics within tests"))
}

func (t *T) Failed() bool {
	if t.failed {
		return true
	}
	for _, sub := range t.subs {
		if sub.Failed() {
			return true
		}
	}
	return false
}

// only called when verbose == false
func (t *T) printFailure() {
	fmt.Fprintf(os.Stderr, "--- FAIL: %s (%s)\n", t.name, t.dur)
	if t.failed {
		fmt.Fprint(os.Stderr, string(t.output))
	}
	for _, sub := range t.subs {
		if sub.Failed() {
			sub.printFailure()
		}
	}
}

func (t *T) Fatal(args ...interface{}) {
	t.Log(args...)
	t.FailNow()
}

func (t *T) Fatalf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.FailNow()
}

func (t *T) Log(args ...interface{}) {
	t.log(fmt.Sprintln(args...))
}

func (t *T) Logf(format string, args ...interface{}) {
	t.log(fmt.Sprintf(format, args...))
	t.log(fmt.Sprintln())
}

func (t *T) Name() string {
	return t.name
}

func (t *T) Parallel() {
	// does nothing.
}

func (t *T) Run(name string, f testingFunc) bool {
	fullName := t.name + "/" + rewrite(name)

	subT := &T{
		parent:    t,
		name:      fullName,
		verbose:   t.verbose,
		runFilter: t.runFilter,
	}

	t.subs = append(t.subs, subT)

	tRunner(subT, f, t.verbose)
	return true
}

func (t *T) Setenv(key, value string) {
	panic("not yet implemented")
}

func (t *T) Skip(args ...interface{}) {
	t.Log(args...)
	t.SkipNow()
}

func (t *T) SkipNow() {
	t.skipped = true
	panic(skipErr("testing: you have recovered a panic attempting to interrupt a test, as a consequence of SkipNow. " +
		"Use testing.Recover to recover panics within tests"))
}

func (t *T) Skipped() bool {
	return t.skipped
}

func (t *T) Skipf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.SkipNow()
}

func (t *T) TempDir() string {
	panic("not yet implemented")
}

func (t *T) Helper() {
}

func (t *T) log(s string) {
	if t.verbose {
		// verbose, print immediately
		fmt.Fprint(os.Stderr, s)
	} else {
		// defer printing only if test is failed
		t.output = append(t.output, s...)
	}
}

type Report struct {
	Failed  bool
	Skipped bool
}

func (t *T) report() Report {
	return Report{
		Failed:  t.Failed(),
		Skipped: t.skipped,
	}
}

//----------------------------------------
// B
// TODO: actually implement

type B struct {
	N int
}

func (b *B) Cleanup(f func())                          { panic("not yet implemented") }
func (b *B) Error(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Errorf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Fail()                                     { panic("not yet implemented") }
func (b *B) FailNow()                                  { panic("not yet implemented") }
func (b *B) Failed() bool                              { panic("not yet implemented") }
func (b *B) Fatal(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Fatalf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Helper()                                   { panic("not yet implemented") }
func (b *B) Log(args ...interface{})                   { panic("not yet implemented") }
func (b *B) Logf(format string, args ...interface{})   { panic("not yet implemented") }
func (b *B) Name() string                              { panic("not yet implemented") }
func (b *B) ReportAllocs()                             { panic("not yet implemented") }
func (b *B) ReportMetric(n float64, unit string)       { panic("not yet implemented") }
func (b *B) ResetTimer()                               { panic("not yet implemented") }
func (b *B) Run(name string, f func(b *B)) bool        { panic("not yet implemented") }
func (b *B) RunParallel(body func(*PB))                { panic("not yet implemented") }
func (b *B) SetBytes(n int64)                          { panic("not yet implemented") }
func (b *B) SetParallelism(p int)                      { panic("not yet implemented") }
func (b *B) Setenv(key, value string)                  { panic("not yet implemented") }
func (b *B) Skip(args ...interface{})                  { panic("not yet implemented") }
func (b *B) SkipNow()                                  { panic("not yet implemented") }
func (b *B) Skipf(format string, args ...interface{})  { panic("not yet implemented") }
func (b *B) Skipped() bool                             { panic("not yet implemented") }
func (b *B) StartTimer()                               { panic("not yet implemented") }
func (b *B) StopTimer()                                { panic("not yet implemented") }
func (b *B) TempDir() string                           { panic("not yet implemented") }

//----------------------------------------
// PB
// TODO: actually implement

type PB struct{}

func (pb *PB) Next() bool { panic("not yet implemented") }

type InternalTest struct {
	Name string
	F    testingFunc
}

func (t *T) shouldRun(name string) bool {
	if t.runFilter == nil {
		return true
	}

	elem := strings.Split(name, "/")
	ok, partial := t.runFilter.matches(elem, matchString)
	_ = partial // we don't care right now
	return ok
}

func RunTest(runFlag string, verbose bool, test InternalTest) (ret string) {
	t := &T{
		name:    test.Name,
		verbose: verbose,
	}

	if runFlag != "" {
		t.runFilter = splitRegexp(runFlag)
	}

	tRunner(t, test.F, verbose)
	if !t.verbose && t.Failed() {
		// use printFailure to print output log of this
		// and/or any subtests that may have failed.
		t.printFailure()
	}

	report := t.report()
	out, _ := json.Marshal(report)
	return string(out)
}

func formatDur(dur int64) string {
	// XXX switch to FormatFloat after it's been added
	// 1 sec = 1e9 nsec
	// this gets us the "centiseconds" which is what we show in tests.
	dstr := strconv.Itoa(int(dur / 1e7))
	if len(dstr) < 3 {
		const pad = "000"
		dstr = pad[:3-len(dstr)] + dstr
	}
	return dstr[:len(dstr)-2] + "." + dstr[len(dstr)-2:] + "s"
}

// used to calculate execution times; only present in testing stdlibs
func unixNano() int64

func tRunner(t *T, fn testingFunc, verbose bool) {
	if !t.shouldRun(t.name) {
		return
	}

	start := unixNano()

	defer func() {
		err := recover()
		switch err.(type) {
		case nil:
		case skipErr:
		default:
			t.Fail()
			fmt.Fprintf(os.Stderr, "panic: %v\n", err)
		}

		dur := unixNano() - start
		t.dur = formatDur(dur)

		if t.verbose {
			switch {
			case t.Failed():
				fmt.Fprintf(os.Stderr, "--- FAIL: %s (%s)\n", t.name, t.dur)
			case t.skipped:
				fmt.Fprintf(os.Stderr, "--- SKIP: %s (%s)\n", t.name, t.dur)
			case t.verbose:
				fmt.Fprintf(os.Stderr, "--- PASS: %s (%s)\n", t.name, t.dur)
			}
		}
	}()

	if verbose {
		fmt.Fprintf(os.Stderr, "=== RUN   %s\n", t.name)
	}

	fn(t)
}
