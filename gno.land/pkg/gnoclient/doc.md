<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# gnoclient

```go
import "github.com/gnolang/gno/gno.land/pkg/gnoclient"
```

<details><summary>Example (Read Only)</summary>
<p>

Example\_readOnly demonstrates how to initialize a read\-only gnoclient, which can only query.

```go
package main

import (
	"fmt"

	"github.com/gnolang/gno/gno.land/pkg/gnoclient"
	rpcclient "github.com/gnolang/gno/tm2/pkg/bft/rpc/client"
)

func main() {
	remote := "127.0.0.1:26657"
	rpcClient := rpcclient.NewHTTP(remote, "/websocket")

	client := gnoclient.Client{
		RPCClient: rpcClient,
	}
	_ = client
	fmt.Println("Hello")
}
```

#### Output

```
Hello
```

</p>
</details>

<details><summary>Example (With Disk)</summary>
<p>

Example\_withDisk demonstrates how to initialize a gnoclient with a keybase sourced from a directory.

```go
package main

import (
	"github.com/gnolang/gno/gno.land/pkg/gnoclient"
	rpcclient "github.com/gnolang/gno/tm2/pkg/bft/rpc/client"
	"github.com/gnolang/gno/tm2/pkg/crypto/keys"
)

func main() {
	kb, _ := keys.NewKeyBaseFromDir("/path/to/dir")
	signer := gnoclient.SignerFromKeybase{
		Keybase:  kb,
		Account:  "mykey",
		Password: "secure",
	}

	remote := "127.0.0.1:26657"
	rpcClient := rpcclient.NewHTTP(remote, "/websocket")

	client := gnoclient.Client{
		Signer:    signer,
		RPCClient: rpcClient,
	}
	_ = client
}
```

</p>
</details>

<details><summary>Example (With In Mem Crypto)</summary>
<p>

Example\_withInMemCrypto demonstrates how to initialize a gnoclient with an in\-memory keybase using BIP39 mnemonics.

```go
package main

import (
	"fmt"

	"github.com/gnolang/gno/gno.land/pkg/gnoclient"
	rpcclient "github.com/gnolang/gno/tm2/pkg/bft/rpc/client"
)

func main() {
	mnemo := "index brass unknown lecture autumn provide royal shrimp elegant wink now zebra discover swarm act ill you bullet entire outdoor tilt usage gap multiply"
	bip39Passphrase := ""
	account := uint32(0)
	index := uint32(0)
	chainID := "dev"
	signer, _ := gnoclient.SignerFromBip39(mnemo, chainID, bip39Passphrase, account, index)

	remote := "127.0.0.1:26657"
	rpcClient := rpcclient.NewHTTP(remote, "/websocket")

	client := gnoclient.Client{
		Signer:    signer,
		RPCClient: rpcClient,
	}
	_ = client
	fmt.Println("Hello")
}
```

#### Output

```
Hello
```

</p>
</details>

## Index

- [Variables](<#variables>)
- [type BaseTxCfg](<#BaseTxCfg>)
- [type Client](<#Client>)
  - [func \(c \*Client\) Call\(cfg BaseTxCfg, msgs ...MsgCall\) \(\*ctypes.ResultBroadcastTxCommit, error\)](<#Client.Call>)
  - [func \(c Client\) QEval\(pkgPath string, expression string\) \(string, \*ctypes.ResultABCIQuery, error\)](<#Client.QEval>)
  - [func \(c Client\) Query\(cfg QueryCfg\) \(\*ctypes.ResultABCIQuery, error\)](<#Client.Query>)
  - [func \(c Client\) QueryAccount\(addr crypto.Address\) \(\*std.BaseAccount, \*ctypes.ResultABCIQuery, error\)](<#Client.QueryAccount>)
  - [func \(c Client\) QueryAppVersion\(\) \(string, \*ctypes.ResultABCIQuery, error\)](<#Client.QueryAppVersion>)
  - [func \(c Client\) Render\(pkgPath string, args string\) \(string, \*ctypes.ResultABCIQuery, error\)](<#Client.Render>)
  - [func \(c \*Client\) Run\(cfg BaseTxCfg, msgs ...MsgRun\) \(\*ctypes.ResultBroadcastTxCommit, error\)](<#Client.Run>)
  - [func \(c \*Client\) Send\(cfg BaseTxCfg, msgs ...MsgSend\) \(\*ctypes.ResultBroadcastTxCommit, error\)](<#Client.Send>)
- [type MsgCall](<#MsgCall>)
- [type MsgRun](<#MsgRun>)
- [type MsgSend](<#MsgSend>)
- [type QueryCfg](<#QueryCfg>)
- [type SignCfg](<#SignCfg>)
- [type Signer](<#Signer>)
  - [func SignerFromBip39\(mnemonic string, chainID string, passphrase string, account uint32, index uint32\) \(Signer, error\)](<#SignerFromBip39>)
- [type SignerFromKeybase](<#SignerFromKeybase>)
  - [func \(s SignerFromKeybase\) Info\(\) keys.Info](<#SignerFromKeybase.Info>)
  - [func \(s SignerFromKeybase\) Sign\(cfg SignCfg\) \(\*std.Tx, error\)](<#SignerFromKeybase.Sign>)
  - [func \(s SignerFromKeybase\) Validate\(\) error](<#SignerFromKeybase.Validate>)


## Variables

<a name="ErrEmptyPackage"></a>

```go
var (
    ErrEmptyPackage      = errors.New("empty package to run")
    ErrEmptyPkgPath      = errors.New("empty pkg path")
    ErrEmptyFuncName     = errors.New("empty function name")
    ErrInvalidGasWanted  = errors.New("invalid gas wanted")
    ErrInvalidGasFee     = errors.New("invalid gas fee")
    ErrMissingSigner     = errors.New("missing Signer")
    ErrMissingRPCClient  = errors.New("missing RPCClient")
    ErrInvalidToAddress  = errors.New("invalid send to address")
    ErrInvalidSendAmount = errors.New("invalid send amount")
)
```

<a name="BaseTxCfg"></a>
## type [BaseTxCfg](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L26-L32>)



```go
type BaseTxCfg struct {
    GasFee         string // Gas fee
    GasWanted      int64  // Gas wanted
    AccountNumber  uint64 // Account number
    SequenceNumber uint64 // Sequence number
    Memo           string // Memo
}
```

<a name="Client"></a>
## type [Client](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client.go#L8-L11>)

Client provides an interface for interacting with the blockchain.

```go
type Client struct {
    Signer    Signer           // Signer for transaction authentication
    RPCClient rpcclient.Client // RPC client for blockchain communication
}
```

<a name="Client.Call"></a>
### func \(\*Client\) [Call](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L55>)

```go
func (c *Client) Call(cfg BaseTxCfg, msgs ...MsgCall) (*ctypes.ResultBroadcastTxCommit, error)
```

Call executes a one or more MsgCall calls on the blockchain.

<a name="Client.QEval"></a>
### func \(Client\) [QEval](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L107>)

```go
func (c Client) QEval(pkgPath string, expression string) (string, *ctypes.ResultABCIQuery, error)
```

QEval evaluates the given expression with the realm code at pkgPath. The pkgPath should include the prefix like "gno.land/". The expression is usually a function call like "GetBoardIDFromName\(\\"testboard\\"\)". The return value is a typed expression like "\(1 gno.land/r/demo/boards.BoardID\)\\n\(true bool\)".

<a name="Client.Query"></a>
### func \(Client\) [Query](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L22>)

```go
func (c Client) Query(cfg QueryCfg) (*ctypes.ResultABCIQuery, error)
```

Query performs a generic query on the blockchain.

<a name="Client.QueryAccount"></a>
### func \(Client\) [QueryAccount](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L39>)

```go
func (c Client) QueryAccount(addr crypto.Address) (*std.BaseAccount, *ctypes.ResultABCIQuery, error)
```

QueryAccount retrieves account information for a given address.

<a name="Client.QueryAppVersion"></a>
### func \(Client\) [QueryAppVersion](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L64>)

```go
func (c Client) QueryAppVersion() (string, *ctypes.ResultABCIQuery, error)
```



<a name="Client.Render"></a>
### func \(Client\) [Render](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L84>)

```go
func (c Client) Render(pkgPath string, args string) (string, *ctypes.ResultABCIQuery, error)
```

Render calls the Render function for pkgPath with optional args. The pkgPath should include the prefix like "gno.land/". This is similar to using a browser URL \<testnet\>/\<pkgPath\>:\<args\> where \<pkgPath\> doesn't have the prefix like "gno.land/".

<a name="Client.Run"></a>
### func \(\*Client\) [Run](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L111>)

```go
func (c *Client) Run(cfg BaseTxCfg, msgs ...MsgRun) (*ctypes.ResultBroadcastTxCommit, error)
```

Run executes a one or more MsgRun calls on the blockchain.

<a name="Client.Send"></a>
### func \(\*Client\) [Send](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L175>)

```go
func (c *Client) Send(cfg BaseTxCfg, msgs ...MsgSend) (*ctypes.ResultBroadcastTxCommit, error)
```

Send currency to an account on the blockchain.

<a name="MsgCall"></a>
## type [MsgCall](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L35-L40>)

MsgCall \- syntax sugar for vm.MsgCall

```go
type MsgCall struct {
    PkgPath  string   // Package path
    FuncName string   // Function name
    Args     []string // Function arguments
    Send     string   // Send amount
}
```

<a name="MsgRun"></a>
## type [MsgRun](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L49-L52>)

MsgRun \- syntax sugar for vm.MsgRun

```go
type MsgRun struct {
    Package *std.MemPackage // Package to run
    Send    string          // Send amount
}
```

<a name="MsgSend"></a>
## type [MsgSend](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_txs.go#L43-L46>)

MsgSend \- syntax sugar for bank.MsgSend minus fields in BaseTxCfg

```go
type MsgSend struct {
    ToAddress crypto.Address // Send to address
    Send      string         // Send amount
}
```

<a name="QueryCfg"></a>
## type [QueryCfg](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/client_queries.go#L15-L19>)

QueryCfg contains configuration options for performing queries.

```go
type QueryCfg struct {
    Path                       string // Query path
    Data                       []byte // Query data
    rpcclient.ABCIQueryOptions        // ABCI query options
}
```

<a name="SignCfg"></a>
## type [SignCfg](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L64-L68>)



```go
type SignCfg struct {
    UnsignedTX     std.Tx
    SequenceNumber uint64
    AccountNumber  uint64
}
```

<a name="Signer"></a>
## type [Signer](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L13-L17>)

Signer provides an interface for signing transactions.

```go
type Signer interface {
    Sign(SignCfg) (*std.Tx, error) // Signs a transaction and returns a signed tx ready for broadcasting.
    Info() keys.Info               // Returns key information, including the address.
    Validate() error               // Checks whether the signer is properly configured.
}
```

<a name="SignerFromBip39"></a>
### func [SignerFromBip39](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L129>)

```go
func SignerFromBip39(mnemonic string, chainID string, passphrase string, account uint32, index uint32) (Signer, error)
```

SignerFromBip39 creates an in\-memory keybase with a single default account. This can be useful in scenarios where storing private keys in the filesystem isn't feasible.

Warning: Using keys.NewKeyBaseFromDir is recommended where possible, as it is more secure.

<a name="SignerFromKeybase"></a>
## type [SignerFromKeybase](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L20-L25>)

SignerFromKeybase represents a signer created from a Keybase.

```go
type SignerFromKeybase struct {
    Keybase  keys.Keybase // Stores keys in memory or on disk
    Account  string       // Account name or bech32 format
    Password string       // Password for encryption
    ChainID  string       // Chain ID for transaction signing
}
```

<a name="SignerFromKeybase.Info"></a>
### func \(SignerFromKeybase\) [Info](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L56>)

```go
func (s SignerFromKeybase) Info() keys.Info
```

Info gets keypair information.

<a name="SignerFromKeybase.Sign"></a>
### func \(SignerFromKeybase\) [Sign](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L71>)

```go
func (s SignerFromKeybase) Sign(cfg SignCfg) (*std.Tx, error)
```

Sign implements the Signer interface for SignerFromKeybase.

<a name="SignerFromKeybase.Validate"></a>
### func \(SignerFromKeybase\) [Validate](<https://github.com/leohhhn/gno/blob/master/gno.land/pkg/gnoclient/signer.go#L28>)

```go
func (s SignerFromKeybase) Validate() error
```

Validate checks if the signer is properly configured.

Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
