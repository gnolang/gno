# Test for https://github.com/gnolang/gno/issues/2283
# This is an earlier variant of the txtar which likely shares the same cause;
# but instead of causing an index out of range, it causes a "should not happen"
# panic from the store.

# These are not necessary, but they "alleviate" add_feeds.tx from the
# responsibility of loading standard libraries, thus not making it exceed
# the --gas-wanted.
loadpkg gno.land/p/demo/avl
loadpkg gno.land/p/demo/avl/pager
loadpkg gno.land/p/demo/avlhelpers
loadpkg gno.land/p/moul/txlink

loadpkg gno.land/p/demo/users $WORK/pusers
loadpkg gno.land/r/demo/users $WORK/users
loadpkg gno.land/r/demo/boards $WORK/boards

gnoland start

! gnokey broadcast $WORK/add_feeds.tx

gnokey maketx addpkg -pkgdir $WORK/bye -pkgpath gno.land/r/demo/bye -gas-fee 1000000ugnot -gas-wanted 10_000_000 -broadcast -chainid=tendermint_test test1
stdout OK!

-- add_feeds.tx --
{
  "msg": [
    {
      "@type": "/vm.m_addpkg",
      "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
      "package": {
        "Name": "social_feeds",
        "Path": "gno.land/r/demo/teritori/social_feeds",
        "Files": [
          {
            "Name": "binutils_extra.gno",
            "Body": "package social_feeds\n\nimport (\n\t\"encoding/binary\"\n)\n\nfunc EncodeLengthPrefixedStringUint32BE(s string) []byte {\n\tb := make([]byte, 4+len(s))\n\tbinary.BigEndian.PutUint32(b, uint32(len(s)))\n\tcopy(b[4:], s)\n\treturn b\n}\n"
          },
          {
            "Name": "feed.gno",
            "Body": "package social_feeds\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/teritori/flags_index\"\n\tujson \"gno.land/p/demo/teritori/ujson\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype FeedID uint64\n\nfunc (fid FeedID) String() string {\n\treturn strconv.Itoa(int(fid))\n}\n\nfunc (fid *FeedID) FromJSON(ast *ujson.JSONASTNode) {\n\tval, err := strconv.Atoi(ast.Value)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t*fid = FeedID(val)\n}\n\nfunc (fid FeedID) ToJSON() string {\n\treturn strconv.Itoa(int(fid))\n}\n\ntype Feed struct {\n\tid        FeedID\n\turl       string\n\tname      string\n\tcreator   std.Address\n\towner     std.Address\n\tposts     avl.Tree // pidkey -> *Post\n\tcreatedAt int64\n\n\tflags             *flags_index.FlagsIndex\n\thiddenPostsByUser avl.Tree // std.Address => *avl.Tree (postID => bool)\n\n\tpostsCtr uint64\n}\n\nfunc newFeed(fid FeedID, url string, name string, creator std.Address) *Feed {\n\tif !reName.MatchString(name) {\n\t\tpanic(\"invalid feed name: \" + name)\n\t}\n\n\tif gFeedsByName.Has(name) {\n\t\tpanic(\"feed already exists: \" + name)\n\t}\n\n\treturn &Feed{\n\t\tid:        fid,\n\t\turl:       url,\n\t\tname:      name,\n\t\tcreator:   creator,\n\t\towner:     creator,\n\t\tposts:     avl.Tree{},\n\t\tcreatedAt: time.Now().Unix(),\n\t\tflags:     flags_index.NewFlagsIndex(),\n\t\tpostsCtr:  0,\n\t}\n}\n\nfunc (feed *Feed) incGetPostID() PostID {\n\tfeed.postsCtr++\n\treturn PostID(feed.postsCtr)\n}\n\nfunc (feed *Feed) GetPost(pid PostID) *Post {\n\tpidkey := postIDKey(pid)\n\tpost_, exists := feed.posts.Get(pidkey)\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn post_.(*Post)\n}\n\nfunc (feed *Feed) MustGetPost(pid PostID) *Post {\n\tpost := feed.GetPost(pid)\n\tif post == nil {\n\t\tpanic(\"post does not exist\")\n\t}\n\treturn post\n}\n\nfunc (feed *Feed) AddPost(creator std.Address, parentID PostID, category uint64, metadata string) *Post {\n\tpid := feed.incGetPostID()\n\tpidkey := postIDKey(pid)\n\n\tpost := newPost(feed, pid, creator, parentID, category, metadata)\n\tfeed.posts.Set(pidkey, post)\n\n\t// If post is a comment then increase the comment count on parent\n\tif uint64(parentID) != 0 {\n\t\tparent := feed.MustGetPost(parentID)\n\t\tparent.commentsCount += 1\n\t}\n\n\treturn post\n}\n\nfunc (feed *Feed) FlagPost(flagBy std.Address, pid PostID) {\n\tflagID := getFlagID(feed.id, pid)\n\n\tif feed.flags.HasFlagged(flagID, flagBy.String()) {\n\t\tpanic(\"already flagged\")\n\t}\n\n\tfeed.flags.Flag(flagID, flagBy.String())\n}\n\nfunc (feed *Feed) BanPost(pid PostID) {\n\tpidkey := postIDKey(pid)\n\t_, removed := feed.posts.Remove(pidkey)\n\tif !removed {\n\t\tpanic(\"post does not exist with id \" + pid.String())\n\t}\n}\n\nfunc (feed *Feed) HidePostForUser(caller std.Address, pid PostID) {\n\tuserAddr := caller.String()\n\n\tvalue, exists := feed.hiddenPostsByUser.Get(userAddr)\n\tvar hiddenPosts *avl.Tree\n\tif exists {\n\t\thiddenPosts = value.(*avl.Tree)\n\t} else {\n\t\thiddenPosts = avl.NewTree()\n\t\tfeed.hiddenPostsByUser.Set(userAddr, hiddenPosts)\n\t}\n\n\tif hiddenPosts.Has(pid.String()) {\n\t\tpanic(\"PostID is already hidden: \" + pid.String())\n\t}\n\n\thiddenPosts.Set(pid.String(), true)\n}\n\nfunc (feed *Feed) UnHidePostForUser(userAddress std.Address, pid PostID) {\n\tvalue, exists := feed.hiddenPostsByUser.Get(userAddress.String())\n\tvar hiddenPosts *avl.Tree\n\tif exists {\n\t\thiddenPosts = value.(*avl.Tree)\n\t\t_, removed := hiddenPosts.Remove(pid.String())\n\t\tif !removed {\n\t\t\tpanic(\"Post is not hidden: \" + pid.String())\n\t\t}\n\t} else {\n\t\tpanic(\"User has not hidden post: \" + pid.String())\n\t}\n}\n\nfunc (feed *Feed) Render() string {\n\tpkgpath := std.CurrentRealmPath()
