{
  "genesis_time": "2023-06-14T15:33:43.577077836Z",
  "chain_id": "dev",
  "consensus_params": {
    "Block": {
      "MaxTxBytes": "1000000",
      "MaxDataBytes": "2000000",
      "MaxBlockBytes": "0",
      "MaxGas": "10000000",
      "TimeIotaMS": "100"
    },
    "Validator": null
  },
  "validators": [
    {
      "address": "g19weu6z70cm24zl7d4qm3az2vkh3k4lsnern20p",
      "pub_key": {
        "@type": "/tm.PubKeyEd25519",
        "value": "fEtVd93WpKkmEFhK/tbDo3hWWttL29TbWSIqzb4nC5U="
      },
      "power": "10",
      "name": "testvalidator"
    }
  ],
  "app_hash": null,
  "app_state": {
    "@type": "/gno.GenesisState",
    "balances": [
      "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5=10000000000000ugnot",
      "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj=10000000000000ugnot",
      "g1f4v282mwyhu29afke4vq5r2xzcm6z3ftnugcnv=1000000000000ugnot",
      "g127jydsh6cms3lrtdenydxsckh23a8d6emqcvfa=1000000000000ugnot",
      "g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq=10000000000ugnot",
      "g14da4n9hcynyzz83q607uu8keuh9hwlv42ra6fa=10000000000ugnot",
      "g15gdm49ktawvkrl88jadqpucng37yxutucuwaef=10000000000ugnot",
      "g1589c8cekvmjfmy0qrd4f3z52r7fn7rgk02667s=10000000000ugnot",
      "g13sm84nuqed3fuank8huh7x9mupgw22uft3lcl8=10000000000ugnot",
      "g1m6732pkrngu9vrt0g7056lvr9kcqc4mv83xl5q=10000000000ugnot",
      "g1wg88rhzlwxjd2z4j5de5v5xq30dcf6rjq3dhsj=10000000000ugnot",
      "g18pmaskasz7mxj6rmgrl3al58xu45a7w0l5nmc0=10000000000ugnot",
      "g19wwhkmqlns70604ksp6rkuuu42qhtvyh05lffz=10000000000ugnot",
      "g187982000zsc493znqt828s90cmp6hcp2erhu6m=10000000000ugnot",
      "g1ndpsnrspdnauckytvkfv8s823t3gmpqmtky8pl=10000000000ugnot",
      "g16ja66d65emkr0zxd2tu7xjvm7utthyhpej0037=10000000000ugnot",
      "g1ds24jj9kqjcskd0gzu24r9e4n62ggye230zuv5=10000000000ugnot",
      "g1trkzq75ntamsnw9xnrav2v7gy2lt5g6p29yhdr=10000000000ugnot",
      "g1rrf8s5mrmu00sx04fzfsvc399fklpeg2x0a7mz=10000000000ugnot",
      "g19p5ntfvpt4lwq4jqsmnxsnelhf3tff9scy3w8w=10000000000ugnot",
      "g1tue8l73d6rq4vhqdsp2sr3zhuzpure3k2rnwpz=10000000000ugnot",
      "g14hhsss4ngx5kq77je5g0tl4vftg8qp45ceadk3=10000000000ugnot",
      "g1768hvkh7anhd40ch4h7jdh6j3mpcs7hrat4gl0=10000000000ugnot",
      "g15fa8kyjhu88t9dr8zzua8fwdvkngv5n8yqsm0n=10000000000ugnot",
      "g1xhccdjcscuhgmt3quww6qdy3j3czqt3urc2eac=10000000000ugnot",
      "g1z629z04f85k4t5gnkk5egpxw9tqxeec435esap=10000000000ugnot",
      "g1pfldkplz9puq0v82lu9vqcve9nwrxuq9qe5ttv=10000000000ugnot",
      "g152pn0g5qfgxr7yx8zlwjq48hytkafd8x7egsfv=10000000000ugnot",
      "g1cf2ye686ke38vjyqakreprljum4xu6rwf5jskq=10000000000ugnot",
      "g1c5shztyaj4gjrc5zlwmh9xhex5w7l4asffs2w6=10000000000ugnot",
      "g1lhpx2ktk0ha3qw42raxq4m24a4c4xqxyrgv54q=10000000000ugnot",
      "g1026p54q0j902059sm2zsv37krf0ghcl7gmhyv7=10000000000ugnot",
      "g1n4yvwnv77frq2ccuw27dmtjkd7u4p4jg0pgm7k=10000000000ugnot",
      "g13m7f2e6r3lh3ykxupacdt9sem2tlvmaamwjhll=10000000000ugnot",
      "g19uxluuecjlsqvwmwu8sp6pxaaqfhk972q975xd=10000000000ugnot",
      "g1j80fpcsumfkxypvydvtwtz3j4sdwr8c2u0lr64=10000000000ugnot",
      "g1tjdpptuk9eysq6z38nscqyycr998xjyx3w8jvw=10000000000ugnot",
      "g19t3n89slfemgd3mwuat4lajwcp0yxrkadgeg7a=10000000000ugnot",
      "g1yqndt8xx92l9h494jfruz2w79swzjes3n4wqjc=10000000000ugnot",
      "g13278z0a5ufeg80ffqxpda9dlp599t7ekregcy6=10000000000ugnot",
      "g1ht236wjd83x96uqwh9rh3fq6pylyn78mtwq9v6=10000000000ugnot",
      "g1fj9jccm3zjnqspq7lp2g7lj4czyfq0s35600g9=10000000000ugnot",
      "g1wwppuzdns5u6c6jqpkzua24zh6ppsus6399cea=10000000000ugnot",
      "g1k8pjnguyu36pkc8hy0ufzgpzfmj2jl78la7ek3=10000000000ugnot",
      "g1e8umkzumtxgs8399lw0us4rclea3xl5gxy9spp=10000000000ugnot",
      "g14qekdkj2nmmwea4ufg9n002a3pud23y8k7ugs5=10000000000ugnot",
      "g19w2488ntfgpduzqq3sk4j5x387zynwknqdvjqf=10000000000ugnot",
      "g1495y3z7zrej4rendysnw5kaeu4g3d7x7w0734g=10000000000ugnot",
      "g1hygx8ga9qakhkczyrzs9drm8j8tu4qds9y5e3r=10000000000ugnot",
      "g1f977l6wxdh3qu60kzl75vx2wmzswu68l03r8su=10000000000ugnot",
      "g1644qje5rx6jsdqfkzmgnfcegx4dxkjh6rwqd69=10000000000ugnot",
      "g1mzjajymvmtksdwh3wkrndwj6zls2awl9q83dh6=10000000000ugnot",
      "g1qpymzwx4l4cy6cerdyajp9ksvjsf20rk5y9rtt=10000000000ugnot"
    ],
    "txs": [
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "ufmt",
              "Path": "gno.land/p/demo/ufmt",
              "Files": [
                {
                  "Name": "ufmt.gno",
                  "Body": "package ufmt\n\nimport \"strconv\"\n\nfunc Sprintf(format string, args ...interface{}) string {\n\tend := len(format)\n\targNum := 0\n\targLen := len(args)\n\tbuf := \"\"\n\n\tfor i := 0; i \u003c end; {\n\t\tisLast := i == end-1\n\t\tc := format[i]\n\n\t\tif isLast || c != '%' {\n\t\t\t// we don't check for invalid format like a one ending with \"%\"\n\t\t\tbuf += string(c)\n\t\t\ti++\n\t\t\tcontinue\n\t\t}\n\n\t\tverb := format[i+1]\n\t\tif verb == '%' {\n\t\t\tbuf += \"%\"\n\t\t\ti += 2\n\t\t\tcontinue\n\t\t}\n\n\t\tif argNum \u003e argLen {\n\t\t\tpanic(\"invalid number of arguments to ufmt.Sprintf\")\n\t\t}\n\t\targ := args[argNum]\n\t\targNum++\n\n\t\tswitch verb {\n\t\tcase 's':\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase interface{ String() string }:\n\t\t\t\tbuf += v.String()\n\t\t\tcase string:\n\t\t\t\tbuf += v\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase 'd':\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase int:\n\t\t\t\tbuf += strconv.Itoa(v)\n\t\t\tcase int64:\n\t\t\t\tbuf += strconv.Itoa(int(v))\n\t\t\tcase uint:\n\t\t\t\tbuf += strconv.FormatUint(uint64(v), 10)\n\t\t\tcase uint64:\n\t\t\t\tbuf += strconv.FormatUint(v, 10)\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase 't':\n\t\t\tswitch v := arg.(type) {\n\t\t\tcase bool:\n\t\t\t\tif v {\n\t\t\t\t\tbuf += \"true\"\n\t\t\t\t} else {\n\t\t\t\t\tbuf += \"false\"\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tbuf += \"(unhandled)\"\n\t\t\t}\n\t\tcase '%':\n\t\t\tbuf += \"%\"\n\t\tdefault:\n\t\t\tbuf += \"(unhandled)\"\n\t\t}\n\n\t\ti += 2\n\t}\n\tif argNum \u003c argLen {\n\t\tpanic(\"too many arguments to ufmt.Sprintf\")\n\t}\n\treturn buf\n}\n"
                },
                {
                  "Name": "ufmt_test.gno",
                  "Body": "package ufmt\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\ntype stringer struct{}\n\nfunc (stringer) String() string {\n\treturn \"I'm a stringer\"\n}\n\nfunc TestSprintf(t *testing.T) {\n\tcases := []struct {\n\t\tformat         string\n\t\tvalues         []interface{}\n\t\texpectedOutput string\n\t}{\n\t\t{\"hello %s!\", []interface{}{\"planet\"}, \"hello planet!\"},\n\t\t{\"hi %%%s!\", []interface{}{\"worl%d\"}, \"hi %worl%d!\"},\n\t\t{\"string [%s]\", []interface{}{\"foo\"}, \"string [foo]\"},\n\t\t{\"int [%d]\", []interface{}{int(42)}, \"int [42]\"},\n\t\t{\"uint [%d]\", []interface{}{uint(42)}, \"uint [42]\"},\n\t\t{\"int64 [%d]\", []interface{}{int64(42)}, \"int64 [42]\"},\n\t\t{\"uint64 [%d]\", []interface{}{uint64(42)}, \"uint64 [42]\"},\n\t\t{\"bool [%t]\", []interface{}{true}, \"bool [true]\"},\n\t\t{\"bool [%t]\", []interface{}{false}, \"bool [false]\"},\n\t\t{\"invalid bool [%t]\", []interface{}{\"invalid\"}, \"invalid bool [(unhandled)]\"},\n\t\t{\"invalid integer [%d]\", []interface{}{\"invalid\"}, \"invalid integer [(unhandled)]\"},\n\t\t{\"invalid string [%s]\", []interface{}{1}, \"invalid string [(unhandled)]\"},\n\t\t{\"no args\", nil, \"no args\"},\n\t\t{\"finish with %\", nil, \"finish with %\"},\n\t\t{\"stringer [%s]\", []interface{}{stringer{}}, \"stringer [I'm a stringer]\"},\n\t}\n\n\tfor _, tc := range cases {\n\t\tname := fmt.Sprintf(tc.format, tc.values...)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tgot := Sprintf(tc.format, tc.values...)\n\t\t\tif got != tc.expectedOutput {\n\t\t\t\tt.Errorf(\"got %q, want %q.\", got, tc.expectedOutput)\n\t\t\t}\n\t\t})\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "avl",
              "Path": "gno.land/p/demo/avl",
              "Files": [
                {
                  "Name": "node.gno",
                  "Body": "package avl\n\n// Node\n\ntype Node struct {\n\tkey       string\n\tvalue     interface{}\n\theight    int8\n\tsize      int\n\tleftNode  *Node\n\trightNode *Node\n}\n\nfunc NewNode(key string, value interface{}) *Node {\n\treturn \u0026Node{\n\t\tkey:    key,\n\t\tvalue:  value,\n\t\theight: 0,\n\t\tsize:   1,\n\t}\n}\n\nfunc (node *Node) Size() int {\n\tif node == nil {\n\t\treturn 0\n\t}\n\treturn node.size\n}\n\nfunc (node *Node) IsLeaf() bool {\n\treturn node.height == 0\n}\n\nfunc (node *Node) Key() string {\n\treturn node.key\n}\n\nfunc (node *Node) Value() interface{} {\n\treturn node.value\n}\n\nfunc (node *Node) _copy() *Node {\n\tif node.height == 0 {\n\t\tpanic(\"Why are you copying a value node?\")\n\t}\n\treturn \u0026Node{\n\t\tkey:       node.key,\n\t\theight:    node.height,\n\t\tsize:      node.size,\n\t\tleftNode:  node.leftNode,\n\t\trightNode: node.rightNode,\n\t}\n}\n\nfunc (node *Node) Has(key string) (has bool) {\n\tif node == nil {\n\t\treturn false\n\t}\n\tif node.key == key {\n\t\treturn true\n\t}\n\tif node.height == 0 {\n\t\treturn false\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Has(key)\n\t\t} else {\n\t\t\treturn node.getRightNode().Has(key)\n\t\t}\n\t}\n}\n\nfunc (node *Node) Get(key string) (index int, value interface{}, exists bool) {\n\tif node == nil {\n\t\treturn 0, nil, false\n\t}\n\tif node.height == 0 {\n\t\tif node.key == key {\n\t\t\treturn 0, node.value, true\n\t\t} else if node.key \u003c key {\n\t\t\treturn 1, nil, false\n\t\t} else {\n\t\t\treturn 0, nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\treturn node.getLeftNode().Get(key)\n\t\t} else {\n\t\t\trightNode := node.getRightNode()\n\t\t\tindex, value, exists = rightNode.Get(key)\n\t\t\tindex += node.size - rightNode.size\n\t\t\treturn index, value, exists\n\t\t}\n\t}\n}\n\nfunc (node *Node) GetByIndex(index int) (key string, value interface{}) {\n\tif node.height == 0 {\n\t\tif index == 0 {\n\t\t\treturn node.key, node.value\n\t\t} else {\n\t\t\tpanic(\"GetByIndex asked for invalid index\")\n\t\t\treturn \"\", nil\n\t\t}\n\t} else {\n\t\t// TODO: could improve this by storing the sizes\n\t\tleftNode := node.getLeftNode()\n\t\tif index \u003c leftNode.size {\n\t\t\treturn leftNode.GetByIndex(index)\n\t\t} else {\n\t\t\treturn node.getRightNode().GetByIndex(index - leftNode.size)\n\t\t}\n\t}\n}\n\n// XXX consider a better way to do this... perhaps split Node from Node.\nfunc (node *Node) Set(key string, value interface{}) (newSelf *Node, updated bool) {\n\tif node == nil {\n\t\treturn NewNode(key, value), false\n\t}\n\tif node.height == 0 {\n\t\tif key \u003c node.key {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       node.key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  NewNode(key, value),\n\t\t\t\trightNode: node,\n\t\t\t}, false\n\t\t} else if key == node.key {\n\t\t\treturn NewNode(key, value), true\n\t\t} else {\n\t\t\treturn \u0026Node{\n\t\t\t\tkey:       key,\n\t\t\t\theight:    1,\n\t\t\t\tsize:      2,\n\t\t\t\tleftNode:  node,\n\t\t\t\trightNode: NewNode(key, value),\n\t\t\t}, false\n\t\t}\n\t} else {\n\t\tnode = node._copy()\n\t\tif key \u003c node.key {\n\t\t\tnode.leftNode, updated = node.getLeftNode().Set(key, value)\n\t\t} else {\n\t\t\tnode.rightNode, updated = node.getRightNode().Set(key, value)\n\t\t}\n\t\tif updated {\n\t\t\treturn node, updated\n\t\t} else {\n\t\t\tnode.calcHeightAndSize()\n\t\t\treturn node.balance(), updated\n\t\t}\n\t}\n}\n\n// newNode: The new node to replace node after remove.\n// newKey: new leftmost leaf key for node after successfully removing 'key' if changed.\n// value: removed value.\nfunc (node *Node) Remove(key string) (\n\tnewNode *Node, newKey string, value interface{}, removed bool,\n) {\n\tif node == nil {\n\t\treturn nil, \"\", nil, false\n\t}\n\tif node.height == 0 {\n\t\tif key == node.key {\n\t\t\treturn nil, \"\", node.value, true\n\t\t} else {\n\t\t\treturn node, \"\", nil, false\n\t\t}\n\t} else {\n\t\tif key \u003c node.key {\n\t\t\tvar newLeftNode *Node\n\t\t\tnewLeftNode, newKey, value, removed = node.getLeftNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newLeftNode == nil { // left node held value, was removed\n\t\t\t\treturn node.rightNode, node.key, value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.leftNode = newLeftNode\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, newKey, value, true\n\t\t} else {\n\t\t\tvar newRightNode *Node\n\t\t\tnewRightNode, newKey, value, removed = node.getRightNode().Remove(key)\n\t\t\tif !removed {\n\t\t\t\treturn node, \"\", value, false\n\t\t\t} else if newRightNode == nil { // right node held value, was removed\n\t\t\t\treturn node.leftNode, \"\", value, true\n\t\t\t}\n\t\t\tnode = node._copy()\n\t\t\tnode.rightNode = newRightNode\n\t\t\tif newKey != \"\" {\n\t\t\t\tnode.key = newKey\n\t\t\t}\n\t\t\tnode.calcHeightAndSize()\n\t\t\tnode = node.balance()\n\t\t\treturn node, \"\", value, true\n\t\t}\n\t}\n}\n\nfunc (node *Node) getLeftNode() *Node {\n\treturn node.leftNode\n}\n\nfunc (node *Node) getRightNode() *Node {\n\treturn node.rightNode\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateRight() *Node {\n\tnode = node._copy()\n\tl := node.getLeftNode()\n\t_l := l._copy()\n\n\t_lrCached := _l.rightNode\n\t_l.rightNode = node\n\tnode.leftNode = _lrCached\n\n\tnode.calcHeightAndSize()\n\t_l.calcHeightAndSize()\n\n\treturn _l\n}\n\n// NOTE: overwrites node\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) rotateLeft() *Node {\n\tnode = node._copy()\n\tr := node.getRightNode()\n\t_r := r._copy()\n\n\t_rlCached := _r.leftNode\n\t_r.leftNode = node\n\tnode.rightNode = _rlCached\n\n\tnode.calcHeightAndSize()\n\t_r.calcHeightAndSize()\n\n\treturn _r\n}\n\n// NOTE: mutates height and size\nfunc (node *Node) calcHeightAndSize() {\n\tnode.height = maxInt8(node.getLeftNode().height, node.getRightNode().height) + 1\n\tnode.size = node.getLeftNode().size + node.getRightNode().size\n}\n\nfunc (node *Node) calcBalance() int {\n\treturn int(node.getLeftNode().height) - int(node.getRightNode().height)\n}\n\n// NOTE: assumes that node can be modified\n// TODO: optimize balance \u0026 rotate\nfunc (node *Node) balance() (newSelf *Node) {\n\tbalance := node.calcBalance()\n\tif balance \u003e 1 {\n\t\tif node.getLeftNode().calcBalance() \u003e= 0 {\n\t\t\t// Left Left Case\n\t\t\treturn node.rotateRight()\n\t\t} else {\n\t\t\t// Left Right Case\n\t\t\t// node = node._copy()\n\t\t\tleft := node.getLeftNode()\n\t\t\tnode.leftNode = left.rotateLeft()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateRight()\n\t\t}\n\t}\n\tif balance \u003c -1 {\n\t\tif node.getRightNode().calcBalance() \u003c= 0 {\n\t\t\t// Right Right Case\n\t\t\treturn node.rotateLeft()\n\t\t} else {\n\t\t\t// Right Left Case\n\t\t\t// node = node._copy()\n\t\t\tright := node.getRightNode()\n\t\t\tnode.rightNode = right.rotateRight()\n\t\t\t// node.calcHeightAndSize()\n\t\t\treturn node.rotateLeft()\n\t\t}\n\t}\n\t// Nothing changed\n\treturn node\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (node *Node) IterateReverse(start, end string, cb func(*Node) bool) bool {\n\treturn node.TraverseInRange(start, end, false, true, cb)\n}\n\n// TraverseInRange traverses all nodes, including inner nodes.\n// Start is inclusive and end is exclusive when ascending,\n// Start and end are inclusive when descending.\n// Empty start and empty end denote no start and no end.\n// If leavesOnly is true, only visit leaf nodes.\n// NOTE: To simulate an exclusive reverse traversal,\n// just append 0x00 to start.\nfunc (node *Node) TraverseInRange(start, end string, ascending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\tafterStart := (start == \"\" || start \u003c node.key)\n\tstartOrAfter := (start == \"\" || start \u003c= node.key)\n\tbeforeEnd := false\n\tif ascending {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c end)\n\t} else {\n\t\tbeforeEnd = (end == \"\" || node.key \u003c= end)\n\t}\n\n\t// Run callback per inner/leaf node.\n\tstop := false\n\tif (!node.IsLeaf() \u0026\u0026 !leavesOnly) ||\n\t\t(node.IsLeaf() \u0026\u0026 startOrAfter \u0026\u0026 beforeEnd) {\n\t\tstop = cb(node)\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t}\n\tif node.IsLeaf() {\n\t\treturn stop\n\t}\n\n\tif ascending {\n\t\t// check lower nodes, then higher\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t} else {\n\t\t// check the higher nodes first\n\t\tif beforeEnd {\n\t\t\tstop = node.getRightNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t\tif stop {\n\t\t\treturn stop\n\t\t}\n\t\tif afterStart {\n\t\t\tstop = node.getLeftNode().TraverseInRange(start, end, ascending, leavesOnly, cb)\n\t\t}\n\t}\n\n\treturn stop\n}\n\n// TraverseByOffset traverses all nodes, including inner nodes.\n// A limit of math.MaxInt means no limit.\nfunc (node *Node) TraverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\tif node == nil {\n\t\treturn false\n\t}\n\n\t// fast paths. these happen only if TraverseByOffset is called directly on a leaf.\n\tif limit \u003c= 0 || offset \u003e= node.size {\n\t\treturn false\n\t}\n\tif node.IsLeaf() {\n\t\tif offset \u003e 0 {\n\t\t\treturn false\n\t\t}\n\t\treturn cb(node)\n\t}\n\n\t// go to the actual recursive function.\n\treturn node.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\nfunc (node *Node) traverseByOffset(offset, limit int, descending bool, leavesOnly bool, cb func(*Node) bool) bool {\n\t// caller guarantees: offset \u003c node.size; limit \u003e 0.\n\n\tif !leavesOnly {\n\t\tif cb(node) {\n\t\t\treturn true\n\t\t}\n\t}\n\tfirst, second := node.getLeftNode(), node.getRightNode()\n\tif descending {\n\t\tfirst, second = second, first\n\t}\n\tif first.IsLeaf() {\n\t\t// either run or skip, based on offset\n\t\tif offset \u003e 0 {\n\t\t\toffset--\n\t\t} else {\n\t\t\tcb(first)\n\t\t\tlimit--\n\t\t\tif limit \u003c= 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// possible cases:\n\t\t// 1 the offset given skips the first node entirely\n\t\t// 2 the offset skips none or part of the first node, but the limit requires some of the second node.\n\t\t// 3 the offset skips none or part of the first node, and the limit stops our search on the first node.\n\t\tif offset \u003e= first.size {\n\t\t\toffset -= first.size // 1\n\t\t} else {\n\t\t\tif first.traverseByOffset(offset, limit, descending, leavesOnly, cb) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// number of leaves which could actually be called from inside\n\t\t\tdelta := first.size - offset\n\t\t\toffset = 0\n\t\t\tif delta \u003e= limit {\n\t\t\t\treturn true // 3\n\t\t\t}\n\t\t\tlimit -= delta // 2\n\t\t}\n\t}\n\n\t// because of the caller guarantees and the way we handle the first node,\n\t// at this point we know that limit \u003e 0 and there must be some values in\n\t// this second node that we include.\n\n\t// =\u003e if the second node is a leaf, it has to be included.\n\tif second.IsLeaf() {\n\t\treturn cb(second)\n\t}\n\t// =\u003e if it is not a leaf, it will still be enough to recursively call this\n\t// function with the updated offset and limit\n\treturn second.traverseByOffset(offset, limit, descending, leavesOnly, cb)\n}\n\n// Only used in testing...\nfunc (node *Node) lmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getLeftNode().lmd()\n}\n\n// Only used in testing...\nfunc (node *Node) rmd() *Node {\n\tif node.height == 0 {\n\t\treturn node\n\t}\n\treturn node.getRightNode().rmd()\n}\n\nfunc maxInt8(a, b int8) int8 {\n\tif a \u003e b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
                },
                {
                  "Name": "node_test.gno",
                  "Body": "package avl\n\nimport (\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestTraverseByOffset(t *testing.T) {\n\tconst testStrings = `Alfa\nAlfred\nAlpha\nAlphabet\nBeta\nBeth\nBook\nBrowser`\n\ttt := []struct {\n\t\tname string\n\t\tdesc bool\n\t}{\n\t\t{\"ascending\", false},\n\t\t{\"descending\", true},\n\t}\n\n\tfor _, tc := range tt {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsl := strings.Split(testStrings, \"\\n\")\n\n\t\t\t// sort a first time in the order opposite to how we'll be traversing\n\t\t\t// the tree, to ensure that we are not just iterating through with\n\t\t\t// insertion order.\n\t\t\tsort.Sort(sort.StringSlice(sl))\n\t\t\tif !tc.desc {\n\t\t\t\treverseSlice(sl)\n\t\t\t}\n\n\t\t\tr := NewNode(sl[0], nil)\n\t\t\tfor _, v := range sl[1:] {\n\t\t\t\tr, _ = r.Set(v, nil)\n\t\t\t}\n\n\t\t\t// then sort sl in the order we'll be traversing it, so that we can\n\t\t\t// compare the result with sl.\n\t\t\treverseSlice(sl)\n\n\t\t\tvar result []string\n\t\t\tfor i := 0; i \u003c len(sl); i++ {\n\t\t\t\tr.TraverseByOffset(i, 1, tc.desc, true, func(n *Node) bool {\n\t\t\t\t\tresult = append(result, n.Key())\n\t\t\t\t\treturn false\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif !slicesEqual(sl, result) {\n\t\t\t\tt.Errorf(\"want %v got %v\", sl, result)\n\t\t\t}\n\n\t\t\tfor l := 2; l \u003c= len(sl); l++ {\n\t\t\t\t// \"slices\"\n\t\t\t\tfor i := 0; i \u003c= len(sl); i++ {\n\t\t\t\t\tmax := i + l\n\t\t\t\t\tif max \u003e len(sl) {\n\t\t\t\t\t\tmax = len(sl)\n\t\t\t\t\t}\n\t\t\t\t\texp := sl[i:max]\n\t\t\t\t\tactual := []string{}\n\n\t\t\t\t\tr.TraverseByOffset(i, l, tc.desc, true, func(tr *Node) bool {\n\t\t\t\t\t\tactual = append(actual, tr.Key())\n\t\t\t\t\t\treturn false\n\t\t\t\t\t})\n\t\t\t\t\t// t.Log(exp, actual)\n\t\t\t\t\tif !slicesEqual(exp, actual) {\n\t\t\t\t\t\tt.Errorf(\"want %v got %v\", exp, actual)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc slicesEqual(w1, w2 []string) bool {\n\tif len(w1) != len(w2) {\n\t\treturn false\n\t}\n\tfor i := 0; i \u003c len(w1); i++ {\n\t\tif w1[0] != w2[0] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc reverseSlice(ss []string) {\n\tfor i := 0; i \u003c len(ss)/2; i++ {\n\t\tj := len(ss) - 1 - i\n\t\tss[i], ss[j] = ss[j], ss[i]\n\t}\n}\n"
                },
                {
                  "Name": "tree.gno",
                  "Body": "package avl\n\n// Tree\n\n// The zero struct can be used as an empty tree.\ntype Tree struct {\n\tnode *Node\n}\n\nfunc NewTree() *Tree {\n\treturn \u0026Tree{\n\t\tnode: nil,\n\t}\n}\n\nfunc (tree *Tree) Size() int {\n\treturn tree.node.Size()\n}\n\nfunc (tree *Tree) Has(key string) (has bool) {\n\treturn tree.node.Has(key)\n}\n\nfunc (tree *Tree) Get(key string) (value interface{}, exists bool) {\n\t_, value, exists = tree.node.Get(key)\n\treturn\n}\n\nfunc (tree *Tree) GetByIndex(index int) (key string, value interface{}) {\n\treturn tree.node.GetByIndex(index)\n}\n\nfunc (tree *Tree) Set(key string, value interface{}) (updated bool) {\n\tnewnode, updated := tree.node.Set(key, value)\n\ttree.node = newnode\n\treturn updated\n}\n\nfunc (tree *Tree) Remove(key string) (value interface{}, removed bool) {\n\tnewnode, _, value, removed := tree.node.Remove(key)\n\ttree.node = newnode\n\treturn value, removed\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) Iterate(start, end string, cb func(*Node) bool) bool {\n\treturn tree.node.TraverseInRange(start, end, true, true, cb)\n}\n\n// Shortcut for TraverseInRange.\nfunc (tree *Tree) IterateReverse(start, end string, cb func(*Node) bool) bool {\n\treturn tree.node.TraverseInRange(start, end, false, true, cb)\n}\n"
                },
                {
                  "Name": "z_0_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\t// node, _ = node.Set(\"key0\", \"value0\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key1\", \"value1\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 2\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value0\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"5\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:6]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value1\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"091729e38bda8724bce4c314f9624b91af679459\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"0b5493aa4ea42087780bdfcaebab2c3eec351c15\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"4\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"6c9948281d4c60b2d95233b76388d54d8b1a2fad\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n"
                },
                {
                  "Name": "z_1_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar node *avl.Node\n\nfunc init() {\n\tnode = avl.NewNode(\"key0\", \"value0\")\n\tnode, _ = node.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tnode, updated = node.Set(\"key2\", \"value2\")\n\t// println(node, updated)\n\tprintln(updated, node.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"7a8a63e17a567d7b0891ac89d5cd90072a73787d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ab5a297f4eb033d88bdf1677f4dc151ccb9fde9f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:7]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"627e8e517e7ae5db0f3b753e2a32b607989198b6\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:5\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"fe8afd501233fb95375016199f0443b3c6ab1fbc\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:2]={\n//     \"Blank\": {},\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"6\",\n//         \"RefCount\": \"2\"\n//     },\n//     \"Parent\": null,\n//     \"Source\": {\n//         \"@type\": \"/gno.RefNode\",\n//         \"BlockNode\": null,\n//         \"Location\": {\n//             \"File\": \"\",\n//             \"Line\": \"0\",\n//             \"Nonce\": \"0\",\n//             \"PkgPath\": \"gno.land/r/test\"\n//         }\n//     },\n//     \"Values\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"init.0\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"10\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.FuncType\",\n//                 \"Params\": [],\n//                 \"Results\": []\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.FuncValue\",\n//                 \"Closure\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:3\"\n//                 },\n//                 \"FileName\": \"main.gno\",\n//                 \"IsMethod\": false,\n//                 \"Name\": \"main\",\n//                 \"PkgPath\": \"gno.land/r/test\",\n//                 \"Source\": {\n//                     \"@type\": \"/gno.RefNode\",\n//                     \"BlockNode\": null,\n//                     \"Location\": {\n//                         \"File\": \"main.gno\",\n//                         \"Line\": \"15\",\n//                         \"Nonce\": \"0\",\n//                         \"PkgPath\": \"gno.land/r/test\"\n//                     }\n//                 },\n//                 \"Type\": {\n//                     \"@type\": \"/gno.FuncType\",\n//                     \"Params\": [],\n//                     \"Results\": []\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"c5eefc40ed065461b4a920c1349ed734ffdead8f\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         }\n//     ]\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]\n"
                },
                {
                  "Name": "z_2_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/test\npackage test\n\nimport (\n\t\"gno.land/p/demo/avl\"\n)\n\nvar tree avl.Tree\n\nfunc init() {\n\ttree.Set(\"key0\", \"value0\")\n\ttree.Set(\"key1\", \"value1\")\n}\n\nfunc main() {\n\tvar updated bool\n\tupdated = tree.Set(\"key2\", \"value2\")\n\tprintln(updated, tree.Size())\n}\n\n// Output:\n// false 3\n\n// Realm:\n// switchrealm[\"gno.land/r/test\"]\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:10]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"value2\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:9]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key2\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"213baed7e3326f2403b5f30e5d4397510ba4f37d\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:7\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"be751422ef4c2bc068a456f9467d2daca27db8ca\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:10\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[a8ada09dee16d791fd406d629fe29bb0ed084a30:8]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"key1\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AwAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"af4d0b158681d85eb2a7f6888b39a05ca7b790ee\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:6\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"ef853d70e334fd2c807d6c2c751da1fcd1e5ad58\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:9\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[a8ada09dee16d791fd406d629fe29bb0ed084a30:4]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"3a5af0895c2c45b8a5e894644bcd689f1fdc4785\",\n//                         \"ObjectID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:8\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:4\",\n//         \"ModTime\": \"7\",\n//         \"OwnerID\": \"a8ada09dee16d791fd406d629fe29bb0ed084a30:2\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// d[a8ada09dee16d791fd406d629fe29bb0ed084a30:5]\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "exts",
              "Path": "gno.land/p/demo/grc/exts",
              "Files": [
                {
                  "Name": "token_metadata.gno",
                  "Body": "package exts\n\ntype TokenMetadata interface {\n\t// Returns the name of the token.\n\tGetName() string\n\n\t// Returns the symbol of the token, usually a shorter version of the\n\t// name.\n\tGetSymbol() string\n\n\t// Returns the decimals places of the token.\n\tGetDecimals() uint\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "grc20",
              "Path": "gno.land/p/demo/grc/grc20",
              "Files": [
                {
                  "Name": "admin_token.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// AdminToken implements a token factory with admin helpers.\n//\n// Warning: you should not expose this struct to enduser directly.\n//\n// It allows token administrators to call privileged helpers\n// like Mint, Burn, or any Transfer helpers by passing custom owners.\n//\n// You should initialize your token, then call AdminToken.SafeGRC20() to\n// expose a safe instance to the endusers.\ntype AdminToken struct {\n\tname        string\n\tsymbol      string\n\tdecimals    uint\n\ttotalSupply uint64\n\tbalances    avl.Tree // std.Address(owner) -\u003e uint64\n\tallowances  avl.Tree // string(owner+\":\"+spender) -\u003e uint64\n}\n\n// safeToken implements the IGRC20 interface.\n//\n// It is generated by AdminToken.SafeGRC20().\n// It can safely be explosed publicly.\ntype safeToken struct {\n\tIGRC20 // implements the GRC20 interface.\n\n\tfactory *AdminToken\n}\n\nfunc NewAdminToken(name, symbol string, decimals uint) *AdminToken {\n\t// FIXME: check for limits\n\n\treturn \u0026AdminToken{\n\t\tname:     name,\n\t\tsymbol:   symbol,\n\t\tdecimals: decimals,\n\n\t\tbalances:   avl.Tree{},\n\t\tallowances: avl.Tree{},\n\t}\n}\n\nfunc (t *AdminToken) GetName() string     { return t.name }\nfunc (t *AdminToken) GetSymbol() string   { return t.symbol }\nfunc (t *AdminToken) GetDecimals() uint   { return t.decimals }\nfunc (t *AdminToken) TotalSupply() uint64 { return t.totalSupply }\n\nfunc (t *AdminToken) BalanceOf(owner std.Address) (uint64, error) {\n\treturn t.balanceOf(owner)\n}\n\nfunc (t *AdminToken) Transfer(owner, to std.Address, amount uint64) error {\n\treturn t.transfer(owner, to, amount)\n}\n\nfunc (t *AdminToken) Allowance(owner, spender std.Address) (uint64, error) {\n\treturn t.allowance(owner, spender)\n}\n\nfunc (t *AdminToken) Approve(owner, spender std.Address, amount uint64) error {\n\treturn t.approve(owner, spender, amount)\n}\n\nfunc (t *AdminToken) TransferFrom(spender, from, to std.Address, amount uint64) error {\n\tif err := t.spendAllowance(from, spender, amount); err != nil {\n\t\treturn err\n\t}\n\treturn t.transfer(from, to, amount)\n}\n\n// Administration helpers implementation.\n//\n\nfunc (t *AdminToken) Mint(to std.Address, amount uint64) error {\n\treturn t.mint(to, amount)\n}\n\nfunc (t *AdminToken) Burn(from std.Address, amount uint64) error {\n\treturn t.burn(from, amount)\n}\n\n// private helpers\n//\n\nfunc (t *AdminToken) mint(address std.Address, amount uint64) error {\n\tif err := checkIsValidAddress(address); err != nil {\n\t\treturn err\n\t}\n\n\t// TODO: check for overflow\n\n\tt.totalSupply += amount\n\tcurrentBalance, err := t.balanceOf(address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tnewBalance := currentBalance + amount\n\n\tt.balances.Set(string(address), newBalance)\n\n\tevent := TransferEvent{zeroAddress, address, amount}\n\temit(\u0026event)\n\n\treturn nil\n}\n\nfunc (t *AdminToken) burn(address std.Address, amount uint64) error {\n\tif err := checkIsValidAddress(address); err != nil {\n\t\treturn err\n\t}\n\t// TODO: check for overflow\n\n\tcurrentBalance, err := t.balanceOf(address)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif currentBalance \u003c amount {\n\t\treturn ErrInsufficientBalance\n\t}\n\n\tt.totalSupply -= amount\n\tnewBalance := currentBalance - amount\n\n\tt.balances.Set(string(address), newBalance)\n\n\tevent := TransferEvent{address, zeroAddress, amount}\n\temit(\u0026event)\n\n\treturn nil\n}\n\nfunc (t *AdminToken) balanceOf(address std.Address) (uint64, error) {\n\tif err := checkIsValidAddress(address); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := t.balances.Get(address.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\treturn balance.(uint64), nil\n}\n\nfunc (t *AdminToken) spendAllowance(owner, spender std.Address, amount uint64) error {\n\tif err := checkIsValidAddress(owner); err != nil {\n\t\treturn err\n\t}\n\tif err := checkIsValidAddress(spender); err != nil {\n\t\treturn err\n\t}\n\n\tcurrentAllowance, err := t.allowance(owner, spender)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif currentAllowance \u003c amount {\n\t\treturn ErrInsufficientAllowance\n\t}\n\n\tkey := allowanceKey(owner, spender)\n\tif currentAllowance \u003e amount {\n\t\tt.allowances.Set(key, currentAllowance-amount)\n\t} else {\n\t\tt.allowances.Remove(key)\n\t}\n\n\treturn nil\n}\n\nfunc (t *AdminToken) transfer(from, to std.Address, amount uint64) error {\n\tif err := checkIsValidAddress(from); err != nil {\n\t\treturn err\n\t}\n\tif err := checkIsValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\ttoBalance, err := t.balanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance, err := t.balanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// debug.\n\t// println(\"from\", from, \"to\", to, \"amount\", amount, \"fromBalance\", fromBalance, \"toBalance\", toBalance)\n\n\tif fromBalance \u003c amount {\n\t\treturn ErrInsufficientBalance\n\t}\n\n\tnewToBalance := toBalance + amount\n\tnewFromBalance := fromBalance - amount\n\n\tt.balances.Set(string(to), newToBalance)\n\tt.balances.Set(string(from), newFromBalance)\n\n\tevent := TransferEvent{from, to, amount}\n\temit(\u0026event)\n\n\treturn nil\n}\n\nfunc (t *AdminToken) allowance(owner, spender std.Address) (uint64, error) {\n\tif err := checkIsValidAddress(owner); err != nil {\n\t\treturn 0, err\n\t}\n\tif err := checkIsValidAddress(spender); err != nil {\n\t\treturn 0, err\n\t}\n\n\tallowance, found := t.allowances.Get(allowanceKey(owner, spender))\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn allowance.(uint64), nil\n}\n\nfunc (t *AdminToken) approve(owner, spender std.Address, amount uint64) error {\n\tif err := checkIsValidAddress(owner); err != nil {\n\t\treturn err\n\t}\n\tif err := checkIsValidAddress(spender); err != nil {\n\t\treturn err\n\t}\n\n\tt.allowances.Set(allowanceKey(owner, spender), amount)\n\n\tevent := ApprovalEvent{owner, spender, amount}\n\temit(\u0026event)\n\n\treturn nil\n}\n\nfunc allowanceKey(owner, spender std.Address) string {\n\treturn owner.String() + \":\" + spender.String()\n}\n\nfunc (t *AdminToken) RenderHome() string {\n\tstr := \"\"\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", t.name, t.symbol)\n\tstr += ufmt.Sprintf(\"* **Decimals**: %d\\n\", t.decimals)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", t.totalSupply)\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", t.balances.Size())\n\treturn str\n}\n\n// GRC20 returns an instance that can be exposed to the end user.\nfunc (t *AdminToken) GRC20() IGRC20 {\n\treturn \u0026userToken{admin: t}\n}\n"
                },
                {
                  "Name": "admin_token_test.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\t\"testing\"\n)\n\nfunc TestAdminTokenImpl(t *testing.T) {\n\tdummy := NewAdminToken(\"Dummy\", \"DUMMY\", 4)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n}\n\nfunc TestAllowance(t *testing.T) {\n\towner := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\tspender := std.Address(\"g1us8428u2a5satrlxzagsqa5m6vmuze027sxc8x\")\n\tdest := std.Address(\"g1us8428m6a5satrlxzagsqa5m6vmuze02tyelwj\")\n\n\ttoken := NewAdminToken(\"Dummy\", \"DUMMY\", 6)\n\tassertE(t, token.Mint(owner, 100000000))\n\tassertE(t, token.Approve(owner, spender, 5000000))\n\n\terr := token.TransferFrom(spender, owner, dest, 10000000)\n\tassert(t, err != nil, \"should not be able to transfer more than approved\")\n\n\ttests := []struct {\n\t\tspend uint64\n\t\texp   uint64\n\t}{\n\t\t{3, 4999997},\n\t\t{999997, 4000000},\n\t\t{4000000, 0},\n\t}\n\n\tfor _, tt := range tests {\n\t\tb0, _ := token.BalanceOf(dest)\n\t\tassertE(t, token.TransferFrom(spender, owner, dest, tt.spend))\n\t\ta, _ := token.Allowance(owner, spender)\n\t\tassert(t, a == tt.exp, \"allowance exp: %d, got %d\", tt.exp, a)\n\n\t\tb, _ := token.BalanceOf(dest)\n\t\texpB := b0 + tt.spend\n\t\tassert(t, b == expB, \"balance exp: %d, got %d\", expB, b)\n\t}\n\n\terr = token.TransferFrom(spender, owner, dest, 1)\n\tassert(t, err != nil, \"no allowance\")\n\n\tkey := allowanceKey(owner, spender)\n\tassert(t, !token.allowances.Has(key), \"allowance should be removed\")\n}\n\nfunc assertE(t *testing.T, err error) {\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error: %s\", err.Error())\n\t}\n}\n\nfunc assert(t *testing.T, cond bool, format string, args ...interface{}) {\n\tif !cond {\n\t\tt.Fatalf(format, args...)\n\t}\n}\n"
                },
                {
                  "Name": "dummy_test.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\t\"testing\"\n)\n\n// TODO: test implementing an IMustGRC20 interface.\n// TODO: test implementing a custom method that hides its usage of the IGRC20 interface.\n\ntype dummyImpl struct{}\n\n// FIXME: this should fail.\nvar _ IGRC20 = (*dummyImpl)(nil)\n\nfunc TestInterface(t *testing.T) {\n\tvar dummy IGRC20 = \u0026dummyImpl{}\n}\n\nfunc (impl *dummyImpl) GetName() string                               { panic(\"not implemented\") }\nfunc (impl *dummyImpl) GetSymbol() string                             { panic(\"not implemented\") }\nfunc (impl *dummyImpl) GetDecimals() uint                             { panic(\"not implemented\") }\nfunc (impl *dummyImpl) TotalSupply() uint64                           { panic(\"not implemented\") }\nfunc (impl *dummyImpl) BalanceOf(account std.Address) (uint64, error) { panic(\"not implemented\") }\nfunc (impl *dummyImpl) Transfer(to std.Address, amount uint64) error  { panic(\"not implemented\") }\nfunc (impl *dummyImpl) Allowance(owner, spender std.Address) (uint64, error) {\n\tpanic(\"not implemented\")\n}\nfunc (impl *dummyImpl) Approve(spender std.Address, amount uint64) error { panic(\"not implemented\") }\nfunc (impl *dummyImpl) TransferFrom(from, to std.Address, amount uint64) error {\n\tpanic(\"not implemented\")\n}\n"
                },
                {
                  "Name": "errors.gno",
                  "Body": "package grc20\n\nimport \"errors\"\n\nvar (\n\tErrInsufficientBalance   = errors.New(\"insufficient balance\")\n\tErrInsufficientAllowance = errors.New(\"insufficient allowance\")\n\tErrInvalidAddress        = errors.New(\"invalid address\")\n\tErrCannotTransferToSelf  = errors.New(\"cannot send transfer to self\")\n)\n"
                },
                {
                  "Name": "igrc20.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/exts\"\n)\n\ntype IGRC20 interface {\n\texts.TokenMetadata\n\n\t// Returns the amount of tokens in existence.\n\tTotalSupply() uint64\n\n\t// Returns the amount of tokens owned by `account`.\n\tBalanceOf(account std.Address) (uint64, error)\n\n\t// Moves `amount` tokens from the caller's account to `to`.\n\t//\n\t// Returns an error if the operation failed.\n\tTransfer(to std.Address, amount uint64) error\n\n\t// Returns the remaining number of tokens that `spender` will be\n\t// allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t// zero by default.\n\t//\n\t// This value changes when {approve} or {transferFrom} are called.\n\tAllowance(owner, spender std.Address) (uint64, error)\n\n\t// Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t//\n\t// Returns an error if the operation failed.\n\t//\n\t// IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t// that someone may use both the old and the new allowance by unfortunate\n\t// transaction ordering. One possible solution to mitigate this race\n\t// condition is to first reduce the spender's allowance to 0 and set the\n\t// desired value afterwards:\n\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\tApprove(spender std.Address, amount uint64) error\n\n\t// Moves `amount` tokens from `from` to `to` using the\n\t// allowance mechanism. `amount` is then deducted from the caller's\n\t// allowance.\n\t//\n\t// Returns an error if the operation failed.\n\tTransferFrom(from, to std.Address, amount uint64) error\n}\n\n// Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n//\n// Note that `value` may be zero.\ntype TransferEvent struct {\n\tFrom  std.Address\n\tTo    std.Address\n\tValue uint64\n}\n\n// Emitted when the allowance of a `spender` for an `owner` is set by\n// a call to {approve}. `value` is the new allowance.\ntype ApprovalEvent struct {\n\tOwner   std.Address\n\tSpender std.Address\n\tValue   uint64\n}\n"
                },
                {
                  "Name": "imustgrc20.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/exts\"\n)\n\n// IMustGRC20 is like IGRC20 but without returned errors.\n//\n// It will either panic or silently ignore invalid usages,\n// depending on the method.\ntype IMustGRC20 interface {\n\texts.TokenMetadata\n\tTotalSupply() uint64\n\tBalanceOf(account std.Address) uint64\n\tTransfer(to std.Address, amount uint64)\n\tAllowance(owner, spender std.Address) uint64\n\tApprove(spender std.Address, amount uint64)\n\tTransferFrom(from, to std.Address, amount uint64)\n}\n"
                },
                {
                  "Name": "mustgrc20.gno",
                  "Body": "package grc20\n\nimport \"std\"\n\nfunc Mustify(original IGRC20) IMustGRC20 {\n\treturn \u0026mustGRC20{original: original}\n}\n\ntype mustGRC20 struct {\n\toriginal IGRC20\n}\n\nfunc (t *mustGRC20) GetName() string     { return t.original.GetName() }\nfunc (t *mustGRC20) GetSymbol() string   { return t.original.GetSymbol() }\nfunc (t *mustGRC20) GetDecimals() uint   { return t.original.GetDecimals() }\nfunc (t *mustGRC20) TotalSupply() uint64 { return t.original.TotalSupply() }\n\nfunc (t *mustGRC20) BalanceOf(owner std.Address) uint64 {\n\tbalance, err := t.original.BalanceOf(owner)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn balance\n}\n\nfunc (t *mustGRC20) Transfer(to std.Address, amount uint64) {\n\terr := t.original.Transfer(to, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (t *mustGRC20) Allowance(owner, spender std.Address) uint64 {\n\tallowance, err := t.original.Allowance(owner, spender)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn allowance\n}\n\nfunc (t *mustGRC20) Approve(spender std.Address, amount uint64) {\n\terr := t.original.Approve(spender, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (t *mustGRC20) TransferFrom(from, to std.Address, amount uint64) {\n\terr := t.original.TransferFrom(from, to, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
                },
                {
                  "Name": "mustgrc20_test.gno",
                  "Body": "package grc20\n\n// TODO: unit tests against MustGRC20 interfaces and helpers.\n"
                },
                {
                  "Name": "user_token.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n)\n\n// userToken implements the IGRC20 interface.\n//\n// It is generated by userToken.GRC20().\n// It can safely be explosed publicly.\ntype userToken struct {\n\tIGRC20 // implements the GRC20 interface.\n\n\tadmin *AdminToken\n}\n\n// IGRC20 implementation.\n//\n\nfunc (t *userToken) GetName() string     { return t.admin.name }\nfunc (t *userToken) GetSymbol() string   { return t.admin.symbol }\nfunc (t *userToken) GetDecimals() uint   { return t.admin.decimals }\nfunc (t *userToken) TotalSupply() uint64 { return t.admin.totalSupply }\n\nfunc (t *userToken) BalanceOf(owner std.Address) (uint64, error) {\n\treturn t.admin.balanceOf(owner)\n}\n\nfunc (t *userToken) Transfer(to std.Address, amount uint64) error {\n\towner := std.GetOrigCaller()\n\treturn t.admin.transfer(owner, to, amount)\n}\n\nfunc (t *userToken) Allowance(owner, spender std.Address) (uint64, error) {\n\treturn t.admin.allowance(owner, spender)\n}\n\nfunc (t *userToken) Approve(spender std.Address, amount uint64) error {\n\towner := std.GetOrigCaller()\n\treturn t.admin.approve(owner, spender, amount)\n}\n\nfunc (t *userToken) TransferFrom(from, to std.Address, amount uint64) error {\n\tspender := std.GetOrigCaller()\n\tif err := t.admin.spendAllowance(from, spender, amount); err != nil {\n\t\treturn err\n\t}\n\treturn t.admin.transfer(from, to, amount)\n}\n"
                },
                {
                  "Name": "user_token_test.gno",
                  "Body": "package grc20\n\nimport (\n\t\"std\"\n\t\"testing\"\n)\n\nfunc TestUserTokenImpl(t *testing.T) {\n\tdummyAdmin := NewAdminToken(\"Dummy\", \"DUMMY\", 4)\n\tdummyUser := dummyAdmin.GRC20()\n\t_ = dummyUser\n}\n\nfunc TestUserApprove(t *testing.T) {\n\towner := std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\tspender := std.Address(\"g1us8428u2a5satrlxzagsqa5m6vmuze027sxc8x\")\n\tdest := std.Address(\"g1us8428m6a5satrlxzagsqa5m6vmuze02tyelwj\")\n\n\tdummyAdmin := NewAdminToken(\"Dummy\", \"DUMMY\", 6)\n\n\t// Set owner as the original caller\n\tstd.TestSetOrigCaller(owner)\n\t// Mint 100000000 tokens for owner\n\tassertE(t, dummyAdmin.Mint(owner, 100000000))\n\n\tdummyUser := dummyAdmin.GRC20()\n\t// Approve spender to spend 5000000 tokens\n\tassertE(t, dummyUser.Approve(spender, 5000000))\n\n\t// Set spender as the original caller\n\tstd.TestSetOrigCaller(spender)\n\t// Try to transfer 10000000 tokens from owner to dest, should fail because it exceeds allowance\n\terr := dummyUser.TransferFrom(owner, dest, 10000000)\n\tassert(t, err != nil, \"should not be able to transfer more than approved\")\n\n\t// Define a set of test data with spend amount and expected remaining allowance\n\ttests := []struct {\n\t\tspend uint64 // Spend amount\n\t\texp   uint64 // Remaining allowance\n\t}{\n\t\t{3, 4999997},\n\t\t{999997, 4000000},\n\t\t{4000000, 0},\n\t}\n\n\t// perform transfer operation,and check if allowance and balance are correct\n\tfor _, tt := range tests {\n\t\tb0, _ := dummyUser.BalanceOf(dest)\n\t\t// Perform transfer from owner to dest\n\t\tassertE(t, dummyUser.TransferFrom(owner, dest, tt.spend))\n\t\ta, _ := dummyUser.Allowance(owner, spender)\n\t\t// Check if allowance equals expected value\n\t\tassert(t, a == tt.exp, \"allowance exp: %d,got %d\", tt.exp, a)\n\n\t\t// Get dest current balance\n\t\tb, _ := dummyUser.BalanceOf(dest)\n\t\t// Calculate expected balance ,should be initial balance plus transfer amount\n\t\texpB := b0 + tt.spend\n\t\t// Check if balance equals expected value\n\t\tassert(t, b == expB, \"balance exp: %d,got %d\", expB, b)\n\t}\n\n\t// Try to transfer one token from owner to dest ,should fail because no allowance left\n\terr = dummyUser.TransferFrom(owner, dest, 1)\n\tassert(t, err != nil, \"no allowance\")\n}\n"
                },
                {
                  "Name": "util.gno",
                  "Body": "package grc20\n\nimport \"std\"\n\nconst zeroAddress = std.Address(\"\")\n\nfunc checkIsValidAddress(addr std.Address) error {\n\tif addr.String() == \"\" {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "grc721",
              "Path": "gno.land/p/demo/grc/grc721",
              "Files": [
                {
                  "Name": "basic_nft.gno",
                  "Body": "package grc721\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicNFT struct {\n\tname              string\n\tsymbol            string\n\towners            avl.Tree // tokenId -\u003e OwnerAddress\n\tbalances          avl.Tree // OwnerAddress -\u003e TokenCount\n\ttokenApprovals    avl.Tree // TokenId -\u003e ApprovedAddress\n\ttokenURIs         avl.Tree // TokenId -\u003e URIs\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\n// Returns new basic NFT\nfunc NewBasicNFT(name string, symbol string) *basicNFT {\n\treturn \u0026basicNFT{\n\t\tname:   name,\n\t\tsymbol: symbol,\n\n\t\towners:            avl.Tree{},\n\t\tbalances:          avl.Tree{},\n\t\ttokenApprovals:    avl.Tree{},\n\t\ttokenURIs:         avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicNFT) Name() string       { return s.name }\nfunc (s *basicNFT) Symbol() string     { return s.symbol }\nfunc (s *basicNFT) TokenCount() uint64 { return uint64(s.owners.Size()) }\n\n// BalanceOf returns balance of input address\nfunc (s *basicNFT) BalanceOf(addr std.Address) (uint64, error) {\n\tif err := isValidAddress(addr); err != nil {\n\t\treturn 0, err\n\t}\n\n\tbalance, found := s.balances.Get(addr.String())\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// OwnerOf returns owner of input token id\nfunc (s *basicNFT) OwnerOf(tid TokenID) (std.Address, error) {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn owner.(std.Address), nil\n}\n\n// TokenURI returns the URI of input token id\nfunc (s *basicNFT) TokenURI(tid TokenID) (string, error) {\n\turi, found := s.tokenURIs.Get(string(tid))\n\tif !found {\n\t\treturn \"\", ErrInvalidTokenId\n\t}\n\n\treturn uri.(string), nil\n}\n\n// IsApprovedForAll returns true if operator is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicNFT) IsApprovedForAll(owner, operator std.Address) bool {\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Approve approves the input address for particular token\nfunc (s *basicNFT) Approve(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner == to {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tcaller := std.GetOrigCaller()\n\tif caller != owner \u0026\u0026 !s.IsApprovedForAll(owner, caller) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\ts.tokenApprovals.Set(string(tid), to.String())\n\tevent := ApprovalEvent{owner, to, tid}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// GetApproved return the approved address for token\nfunc (s *basicNFT) GetApproved(tid TokenID) (std.Address, error) {\n\taddr, found := s.tokenApprovals.Get(string(tid))\n\tif !found {\n\t\treturn zeroAddress, ErrTokenIdNotHasApproved\n\t}\n\n\treturn std.Address(addr.(string)), nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicNFT) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif err := isValidAddress(operator); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.GetOrigCaller()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC721 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicNFT) SafeTransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.GetOrigCaller()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(from, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\n// Transfers `tokenId` token from `from` to `to`.\nfunc (s *basicNFT) TransferFrom(from, to std.Address, tid TokenID) error {\n\tcaller := std.GetOrigCaller()\n\tif !s.isApprovedOrOwner(caller, tid) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.transfer(from, to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Mints `tokenId` and transfers it to `to`.\nfunc (s *basicNFT) Mint(to std.Address, tid TokenID) error {\n\treturn s.mint(to, tid)\n}\n\n// Mints `tokenId` and transfers it to `to`. Also checks that\n// contract recipients are using GRC721 protocol\nfunc (s *basicNFT) SafeMint(to std.Address, tid TokenID) error {\n\terr := s.mint(to, tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.checkOnGRC721Received(zeroAddress, to, tid) {\n\t\treturn ErrTransferToNonGRC721Receiver\n\t}\n\n\treturn nil\n}\n\nfunc (s *basicNFT) Burn(tid TokenID) error {\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts.beforeTokenTransfer(owner, zeroAddress, tid, 1)\n\n\ts.tokenApprovals.Remove(string(tid))\n\tbalance, err := s.BalanceOf(owner)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbalance -= 1\n\ts.balances.Set(owner.String(), balance)\n\ts.owners.Remove(string(tid))\n\n\tevent := TransferEvent{owner, zeroAddress, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(owner, zeroAddress, tid, 1)\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll()\nfunc (s *basicNFT) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn ErrApprovalToCurrentOwner\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\ts.operatorApprovals.Set(key, approved)\n\n\tevent := ApprovalForAllEvent{owner, operator, approved}\n\temit(\u0026event)\n\n\treturn nil\n}\n\n// Helper for TransferFrom() and SafeTransferFrom()\nfunc (s *basicNFT) transfer(from, to std.Address, tid TokenID) error {\n\tif err := isValidAddress(from); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\tif err := isValidAddress(to); err != nil {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\towner, err := s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.beforeTokenTransfer(from, to, tid, 1)\n\n\t// Check that tokenId was not transferred by `beforeTokenTransfer`\n\towner, err = s.OwnerOf(tid)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif owner != from {\n\t\treturn ErrTransferFromIncorrectOwner\n\t}\n\n\ts.tokenApprovals.Remove(string(tid))\n\tfromBalance, err := s.BalanceOf(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfromBalance -= 1\n\ttoBalance += 1\n\ts.balances.Set(from.String(), fromBalance)\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{from, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(from, to, tid, 1)\n\n\treturn nil\n}\n\n// Helper for Mint() and SafeMint()\nfunc (s *basicNFT) mint(to std.Address, tid TokenID) error {\n\tif err := isValidAddress(to); err != nil {\n\t\treturn err\n\t}\n\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ts.beforeTokenTransfer(zeroAddress, to, tid, 1)\n\n\t// Check that tokenId was not minted by `beforeTokenTransfer`\n\tif s.exists(tid) {\n\t\treturn ErrTokenIdAlreadyExists\n\t}\n\n\ttoBalance, err := s.BalanceOf(to)\n\tif err != nil {\n\t\treturn err\n\t}\n\ttoBalance += 1\n\ts.balances.Set(to.String(), toBalance)\n\ts.owners.Set(string(tid), to)\n\n\tevent := TransferEvent{zeroAddress, to, tid}\n\temit(\u0026event)\n\n\ts.afterTokenTransfer(zeroAddress, to, tid, 1)\n\n\treturn nil\n}\n\nfunc (s *basicNFT) isApprovedOrOwner(addr std.Address, tid TokenID) bool {\n\towner, found := s.owners.Get(string(tid))\n\tif !found {\n\t\treturn false\n\t}\n\n\tif addr == owner.(std.Address) || s.IsApprovedForAll(owner.(std.Address), addr) {\n\t\treturn true\n\t}\n\n\t_, err := s.GetApproved(tid)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Checks if token id already exists\nfunc (s *basicNFT) exists(tid TokenID) bool {\n\t_, found := s.owners.Get(string(tid))\n\treturn found\n}\n\nfunc (s *basicNFT) beforeTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) afterTokenTransfer(from, to std.Address, firstTokenId TokenID, batchSize uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicNFT) checkOnGRC721Received(from, to std.Address, tid TokenID) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicNFT) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# %s ($%s)\\n\\n\", s.name, s.symbol)\n\tstr += ufmt.Sprintf(\"* **Total supply**: %d\\n\", s.TokenCount())\n\tstr += ufmt.Sprintf(\"* **Known accounts**: %d\\n\", s.balances.Size())\n\n\treturn\n}\n"
                },
                {
                  "Name": "basic_nft_test.gno",
                  "Body": "package grc721\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tdummyNFTName   = \"DummyNFT\"\n\tdummyNFTSymbol = \"DNFT\"\n)\n\nfunc TestNewBasicNFT(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n}\n\nfunc TestName(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\tname := dummy.Name()\n\tif name != dummyNFTName {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", dummyNFTName, name)\n\t}\n}\n\nfunc TestSymbol(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\tsymbol := dummy.Symbol()\n\tif symbol != dummyNFTSymbol {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", dummyNFTSymbol, symbol)\n\t}\n}\n\nfunc TestTokenCount(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcount := dummy.TokenCount()\n\tif count != 0 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 0, count)\n\t}\n\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"1\"))\n\tdummy.mint(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\", TokenID(\"2\"))\n\n\tcount = dummy.TokenCount()\n\tif count != 2 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 2, count)\n\t}\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tbalanceAddr1, err := dummy.BalanceOf(addr1.Resolve())\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceAddr1 != 0 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 0, balanceAddr1)\n\t}\n\n\tdummy.mint(addr1.Resolve(), TokenID(\"1\"))\n\tdummy.mint(addr1.Resolve(), TokenID(\"2\"))\n\tdummy.mint(addr2.Resolve(), TokenID(\"3\"))\n\n\tbalanceAddr1, err = dummy.BalanceOf(addr1.Resolve())\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tbalanceAddr2, err := dummy.BalanceOf(addr2.Resolve())\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tif balanceAddr1 != 2 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 2, balanceAddr1)\n\t}\n\tif balanceAddr2 != 1 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 1, balanceAddr2)\n\t}\n}\n\nfunc TestOwnerOf(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\towner, err := dummy.OwnerOf(TokenID(\"invalid\"))\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\n\tdummy.mint(addr1.Resolve(), TokenID(\"1\"))\n\tdummy.mint(addr2.Resolve(), TokenID(\"2\"))\n\n\t// Checking for token id \"1\"\n\towner, err = dummy.OwnerOf(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif owner != addr1.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr1.Resolve().String(), owner.String())\n\t}\n\n\t// Checking for token id \"2\"\n\towner, err = dummy.OwnerOf(TokenID(\"2\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif owner != addr2.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr2.Resolve().String(), owner.String())\n\t}\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1.Resolve(), addr2.Resolve())\n\tif isApprovedForAll != false {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr.Resolve())\n\tif isApprovedForAll != false {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n\n\terr := dummy.SetApprovalForAll(addr.Resolve(), true)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr.Resolve())\n\tif isApprovedForAll != true {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n}\n\nfunc TestGetApproved(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"invalid\"))\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n}\n\nfunc TestApprove(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\n\t_, err := dummy.GetApproved(TokenID(\"1\"))\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\n\terr = dummy.Approve(addr.Resolve(), TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tapprovedAddr, err := dummy.GetApproved(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif approvedAddr != addr.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr.Resolve().String(), approvedAddr.String())\n\t}\n}\n\nfunc TestTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.TransferFrom(caller, addr.Resolve(), TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfCaller != 1 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 1, balanceOfCaller)\n\t}\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr.Resolve())\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfAddr != 1 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 1, balanceOfAddr)\n\t}\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif owner != addr.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr.Resolve().String(), owner.String())\n\t}\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(caller, TokenID(\"1\"))\n\tdummy.mint(caller, TokenID(\"2\"))\n\n\terr := dummy.SafeTransferFrom(caller, addr.Resolve(), TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfCaller != 1 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 1, balanceOfCaller)\n\t}\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr.Resolve())\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfAddr != 1 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 1, balanceOfAddr)\n\t}\n\n\t// Check Owner of transferred Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif owner != addr.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr.Resolve().String(), owner.String())\n\t}\n}\n\nfunc TestMint(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\n\terr := dummy.Mint(addr1.Resolve(), TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.Mint(addr1.Resolve(), TokenID(\"2\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.Mint(addr2.Resolve(), TokenID(\"3\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Try minting duplicate token id\n\terr = dummy.Mint(addr2.Resolve(), TokenID(\"1\"))\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif owner != addr1.Resolve() {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", addr1.Resolve().String(), owner.String())\n\t}\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicNFT(dummyNFTName, dummyNFTSymbol)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\")\n\n\tdummy.mint(addr.Resolve(), TokenID(\"1\"))\n\tdummy.mint(addr.Resolve(), TokenID(\"2\"))\n\n\terr := dummy.Burn(TokenID(\"1\"))\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check Owner of Token id\n\towner, err := dummy.OwnerOf(TokenID(\"1\"))\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n}\n"
                },
                {
                  "Name": "errors.gno",
                  "Body": "package grc721\n\nimport \"errors\"\n\nvar (\n\tErrInvalidTokenId              = errors.New(\"invalid token id\")\n\tErrInvalidAddress              = errors.New(\"invalid address\")\n\tErrTokenIdNotHasApproved       = errors.New(\"token id not approved for anyone\")\n\tErrApprovalToCurrentOwner      = errors.New(\"approval to current owner\")\n\tErrCallerIsNotOwner            = errors.New(\"caller is not token owner\")\n\tErrCallerNotApprovedForAll     = errors.New(\"caller is not approved for all\")\n\tErrCannotTransferToSelf        = errors.New(\"cannot send transfer to self\")\n\tErrTransferFromIncorrectOwner  = errors.New(\"transfer from incorrect owner\")\n\tErrTransferToNonGRC721Receiver = errors.New(\"transfer to non GRC721Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved  = errors.New(\"caller is not token owner or approved\")\n\tErrTokenIdAlreadyExists        = errors.New(\"token id already exists\")\n)\n"
                },
                {
                  "Name": "igrc721.gno",
                  "Body": "package grc721\n\nimport \"std\"\n\ntype IGRC721 interface {\n\tBalanceOf(owner std.Address) (uint64, error)\n\tOwnerOf(tid TokenID) (std.Address, error)\n\tSafeTransferFrom(from, to std.Address, tid TokenID) error\n\tTransferFrom(from, to std.Address, tid TokenID) error\n\tApprove(approved std.Address, tid TokenID) error\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tGetApproved(tid TokenID) (std.Address, error)\n\tIsApprovedForAll(owner, operator std.Address) bool\n}\n\ntype TokenID string\n\ntype TransferEvent struct {\n\tFrom    std.Address\n\tTo      std.Address\n\tTokenID TokenID\n}\n\ntype ApprovalEvent struct {\n\tOwner    std.Address\n\tApproved std.Address\n\tTokenID  TokenID\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n"
                },
                {
                  "Name": "util.gno",
                  "Body": "package grc721\n\nimport (\n\t\"std\"\n)\n\nvar zeroAddress = std.Address(\"\")\n\nfunc isValidAddress(addr std.Address) error {\n\tif addr.String() == \"\" {\n\t\treturn ErrInvalidAddress\n\t}\n\treturn nil\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "grc1155",
              "Path": "gno.land/p/demo/grc/grc1155",
              "Files": [
                {
                  "Name": "README.md",
                  "Body": "# GRC-1155 Spec: Multi Token Standard\n\nGRC1155 is a specification for managing multiple tokens based on Gnoland. The name and design is based on Ethereum's ERC1155 standard.\n\n## See also:\n\n[ERC-1155 Spec][erc-1155]\n\n[erc-1155]: https://eips.ethereum.org/EIPS/eip-1155"
                },
                {
                  "Name": "basic_grc1155_token.gno",
                  "Body": "package grc1155\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype basicGRC1155Token struct {\n\turi               string\n\tbalances          avl.Tree // \"TokenId:Address\" -\u003e uint64\n\toperatorApprovals avl.Tree // \"OwnerAddress:OperatorAddress\" -\u003e bool\n}\n\nvar _ IGRC1155 = (*basicGRC1155Token)(nil)\n\n// Returns new basic GRC1155 token\nfunc NewBasicGRC1155Token(uri string) *basicGRC1155Token {\n\treturn \u0026basicGRC1155Token{\n\t\turi:               uri,\n\t\tbalances:          avl.Tree{},\n\t\toperatorApprovals: avl.Tree{},\n\t}\n}\n\nfunc (s *basicGRC1155Token) Uri() string { return s.uri }\n\n// BalanceOf returns the input address's balance of the token type requested\nfunc (s *basicGRC1155Token) BalanceOf(addr std.Address, tid TokenID) (uint64, error) {\n\tif !isValidAddress(addr) {\n\t\treturn 0, ErrInvalidAddress\n\t}\n\n\tkey := string(tid) + \":\" + addr.String()\n\tbalance, found := s.balances.Get(key)\n\tif !found {\n\t\treturn 0, nil\n\t}\n\n\treturn balance.(uint64), nil\n}\n\n// BalanceOfBatch returns the balance of multiple account/token pairs\nfunc (s *basicGRC1155Token) BalanceOfBatch(owners []std.Address, batch []TokenID) ([]uint64, error) {\n\tif len(owners) != len(batch) {\n\t\treturn nil, ErrMismatchLength\n\t}\n\n\tbalanceOfBatch := make([]uint64, len(owners))\n\n\tfor i := 0; i \u003c len(owners); i++ {\n\t\tbalanceOfBatch[i], _ = s.BalanceOf(owners[i], batch[i])\n\t}\n\n\treturn balanceOfBatch, nil\n}\n\n// SetApprovalForAll can approve the operator to operate on all tokens\nfunc (s *basicGRC1155Token) SetApprovalForAll(operator std.Address, approved bool) error {\n\tif !isValidAddress(operator) {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.GetOrigCaller()\n\treturn s.setApprovalForAll(caller, operator, approved)\n}\n\n// IsApprovedForAll returns true if operator is the owner or is approved for all by the owner.\n// Otherwise, returns false\nfunc (s *basicGRC1155Token) IsApprovedForAll(owner, operator std.Address) bool {\n\tif operator == owner {\n\t\treturn true\n\t}\n\tkey := owner.String() + \":\" + operator.String()\n\t_, found := s.operatorApprovals.Get(key)\n\tif !found {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// Safely transfers `tokenId` token from `from` to `to`, checking that\n// contract recipients are aware of the GRC1155 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicGRC1155Token) SafeTransferFrom(from, to std.Address, tid TokenID, amount uint64) error {\n\tcaller := std.GetOrigCaller()\n\tif !s.IsApprovedForAll(caller, from) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.safeBatchTransferFrom(from, to, []TokenID{tid}, []uint64{amount})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.doSafeTransferAcceptanceCheck(caller, from, to, tid, amount) {\n\t\treturn ErrTransferToRejectedOrNonGRC1155Receiver\n\t}\n\n\temit(\u0026TransferSingleEvent{caller, from, to, tid, amount})\n\n\treturn nil\n}\n\n// Safely transfers a `batch` of tokens from `from` to `to`, checking that\n// contract recipients are aware of the GRC1155 protocol to prevent\n// tokens from being forever locked.\nfunc (s *basicGRC1155Token) SafeBatchTransferFrom(from, to std.Address, batch []TokenID, amounts []uint64) error {\n\tcaller := std.GetOrigCaller()\n\tif !s.IsApprovedForAll(caller, from) {\n\t\treturn ErrCallerIsNotOwnerOrApproved\n\t}\n\n\terr := s.safeBatchTransferFrom(from, to, batch, amounts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.doSafeBatchTransferAcceptanceCheck(caller, from, to, batch, amounts) {\n\t\treturn ErrTransferToRejectedOrNonGRC1155Receiver\n\t}\n\n\temit(\u0026TransferBatchEvent{caller, from, to, batch, amounts})\n\n\treturn nil\n}\n\n// Creates `amount` tokens of token type `id`, and assigns them to `to`. Also checks that\n// contract recipients are using GRC1155 protocol.\nfunc (s *basicGRC1155Token) SafeMint(to std.Address, tid TokenID, amount uint64) error {\n\tcaller := std.GetOrigCaller()\n\n\terr := s.mintBatch(to, []TokenID{tid}, []uint64{amount})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.doSafeTransferAcceptanceCheck(caller, zeroAddress, to, tid, amount) {\n\t\treturn ErrTransferToRejectedOrNonGRC1155Receiver\n\t}\n\n\temit(\u0026TransferSingleEvent{caller, zeroAddress, to, tid, amount})\n\n\treturn nil\n}\n\n// Batch version of `SafeMint()`. Also checks that\n// contract recipients are using GRC1155 protocol.\nfunc (s *basicGRC1155Token) SafeBatchMint(to std.Address, batch []TokenID, amounts []uint64) error {\n\tcaller := std.GetOrigCaller()\n\n\terr := s.mintBatch(to, batch, amounts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !s.doSafeBatchTransferAcceptanceCheck(caller, zeroAddress, to, batch, amounts) {\n\t\treturn ErrTransferToRejectedOrNonGRC1155Receiver\n\t}\n\n\temit(\u0026TransferBatchEvent{caller, zeroAddress, to, batch, amounts})\n\n\treturn nil\n}\n\n// Destroys `amount` tokens of token type `id` from `from`.\nfunc (s *basicGRC1155Token) Burn(from std.Address, tid TokenID, amount uint64) error {\n\tcaller := std.GetOrigCaller()\n\n\terr := s.burnBatch(from, []TokenID{tid}, []uint64{amount})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\temit(\u0026TransferSingleEvent{caller, from, zeroAddress, tid, amount})\n\n\treturn nil\n}\n\n// Batch version of `Burn()`\nfunc (s *basicGRC1155Token) BatchBurn(from std.Address, batch []TokenID, amounts []uint64) error {\n\tcaller := std.GetOrigCaller()\n\n\terr := s.burnBatch(from, batch, amounts)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\temit(\u0026TransferBatchEvent{caller, from, zeroAddress, batch, amounts})\n\n\treturn nil\n}\n\n/* Helper methods */\n\n// Helper for SetApprovalForAll(): approve `operator` to operate on all of `owner` tokens\nfunc (s *basicGRC1155Token) setApprovalForAll(owner, operator std.Address, approved bool) error {\n\tif owner == operator {\n\t\treturn nil\n\t}\n\n\tkey := owner.String() + \":\" + operator.String()\n\tif approved {\n\t\ts.operatorApprovals.Set(key, approved)\n\t} else {\n\t\ts.operatorApprovals.Remove(key)\n\t}\n\n\temit(\u0026ApprovalForAllEvent{owner, operator, approved})\n\n\treturn nil\n}\n\n// Helper for SafeTransferFrom() and SafeBatchTransferFrom()\nfunc (s *basicGRC1155Token) safeBatchTransferFrom(from, to std.Address, batch []TokenID, amounts []uint64) error {\n\tif len(batch) != len(amounts) {\n\t\treturn ErrMismatchLength\n\t}\n\tif !isValidAddress(from) || !isValidAddress(to) {\n\t\treturn ErrInvalidAddress\n\t}\n\tif from == to {\n\t\treturn ErrCannotTransferToSelf\n\t}\n\n\tcaller := std.GetOrigCaller()\n\ts.beforeTokenTransfer(caller, from, to, batch, amounts)\n\n\tfor i := 0; i \u003c len(batch); i++ {\n\t\ttid := batch[i]\n\t\tamount := amounts[i]\n\t\tfromBalance, err := s.BalanceOf(from, tid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fromBalance \u003c amount {\n\t\t\treturn ErrInsufficientBalance\n\t\t}\n\t\ttoBalance, err := s.BalanceOf(to, tid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfromBalance -= amount\n\t\ttoBalance += amount\n\t\tfromBalanceKey := string(tid) + \":\" + from.String()\n\t\ttoBalanceKey := string(tid) + \":\" + to.String()\n\t\ts.balances.Set(fromBalanceKey, fromBalance)\n\t\ts.balances.Set(toBalanceKey, toBalance)\n\t}\n\n\ts.afterTokenTransfer(caller, from, to, batch, amounts)\n\n\treturn nil\n}\n\n// Helper for SafeMint() and SafeBatchMint()\nfunc (s *basicGRC1155Token) mintBatch(to std.Address, batch []TokenID, amounts []uint64) error {\n\tif len(batch) != len(amounts) {\n\t\treturn ErrMismatchLength\n\t}\n\tif !isValidAddress(to) {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.GetOrigCaller()\n\ts.beforeTokenTransfer(caller, zeroAddress, to, batch, amounts)\n\n\tfor i := 0; i \u003c len(batch); i++ {\n\t\ttid := batch[i]\n\t\tamount := amounts[i]\n\t\ttoBalance, err := s.BalanceOf(to, tid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttoBalance += amount\n\t\ttoBalanceKey := string(tid) + \":\" + to.String()\n\t\ts.balances.Set(toBalanceKey, toBalance)\n\t}\n\n\ts.afterTokenTransfer(caller, zeroAddress, to, batch, amounts)\n\n\treturn nil\n}\n\n// Helper for Burn() and BurnBatch()\nfunc (s *basicGRC1155Token) burnBatch(from std.Address, batch []TokenID, amounts []uint64) error {\n\tif len(batch) != len(amounts) {\n\t\treturn ErrMismatchLength\n\t}\n\tif !isValidAddress(from) {\n\t\treturn ErrInvalidAddress\n\t}\n\n\tcaller := std.GetOrigCaller()\n\ts.beforeTokenTransfer(caller, from, zeroAddress, batch, amounts)\n\n\tfor i := 0; i \u003c len(batch); i++ {\n\t\ttid := batch[i]\n\t\tamount := amounts[i]\n\t\tfromBalance, err := s.BalanceOf(from, tid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif fromBalance \u003c amount {\n\t\t\treturn ErrBurnAmountExceedsBalance\n\t\t}\n\t\tfromBalance -= amount\n\t\tfromBalanceKey := string(tid) + \":\" + from.String()\n\t\ts.balances.Set(fromBalanceKey, fromBalance)\n\t}\n\n\ts.afterTokenTransfer(caller, from, zeroAddress, batch, amounts)\n\n\treturn nil\n}\n\nfunc (s *basicGRC1155Token) setUri(newUri string) {\n\ts.uri = newUri\n\temit(\u0026UpdateURIEvent{newUri})\n}\n\nfunc (s *basicGRC1155Token) beforeTokenTransfer(operator, from, to std.Address, batch []TokenID, amounts []uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicGRC1155Token) afterTokenTransfer(operator, from, to std.Address, batch []TokenID, amounts []uint64) {\n\t// TODO: Implementation\n}\n\nfunc (s *basicGRC1155Token) doSafeTransferAcceptanceCheck(operator, from, to std.Address, tid TokenID, amount uint64) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicGRC1155Token) doSafeBatchTransferAcceptanceCheck(operator, from, to std.Address, batch []TokenID, amounts []uint64) bool {\n\t// TODO: Implementation\n\treturn true\n}\n\nfunc (s *basicGRC1155Token) RenderHome() (str string) {\n\tstr += ufmt.Sprintf(\"# URI:%s\\n\", s.uri)\n\n\treturn\n}\n"
                },
                {
                  "Name": "basic_grc1155_token_test.gno",
                  "Body": "package grc1155\n\nimport (\n\t\"fmt\"\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nconst dummyURI = \"ipfs://xyz\"\n\nfunc TestNewBasicGRC1155Token(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\treturn t.Errorf(\"should not be nil\")\n\t}\n}\n\nfunc TestUri(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\turi := dummy.Uri()\n\tif uri != dummyURI {\n\t\tt.Errorf(\"expected: (%s), got: (%s)\", dummyURI, uri)\n\t}\n}\n\nfunc TestBalanceOf(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\tbalanceZeroAddressOfToken1, err := dummy.BalanceOf(zeroAddress, tid1)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\tbalanceAddr1OfToken1, err := dummy.BalanceOf(addr1, tid1)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceAddr1OfToken1 != 0 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 0, balanceAddr1OfToken1)\n\t}\n\n\tdummy.mintBatch(addr1, []TokenID{tid1, tid2}, []uint64{10, 100})\n\tdummy.mintBatch(addr2, []TokenID{tid1}, []uint64{20})\n\n\tbalanceAddr1OfToken1, err = dummy.BalanceOf(addr1, tid1)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tbalanceAddr1OfToken2, err := dummy.BalanceOf(addr1, tid2)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tbalanceAddr2OfToken1, err := dummy.BalanceOf(addr2, tid1)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tif balanceAddr1OfToken1 != 10 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 10, balanceAddr1OfToken1)\n\t}\n\tif balanceAddr1OfToken2 != 100 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 100, balanceAddr1OfToken2)\n\t}\n\tif balanceAddr2OfToken1 != 20 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 20, balanceAddr2OfToken1)\n\t}\n}\n\nfunc TestBalanceOfBatch(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{addr1, addr2}, []TokenID{tid1, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tif balanceBatch[0] != 0 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 0, balanceBatch[0])\n\t}\n\tif balanceBatch[1] != 0 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 0, balanceBatch[1])\n\t}\n\n\tdummy.mintBatch(addr1, []TokenID{tid1}, []uint64{10})\n\tdummy.mintBatch(addr2, []TokenID{tid2}, []uint64{20})\n\n\tbalanceBatch, err = dummy.BalanceOfBatch([]std.Address{addr1, addr2}, []TokenID{tid1, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tif balanceBatch[0] != 10 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 10, balanceBatch[0])\n\t}\n\tif balanceBatch[1] != 20 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 20, balanceBatch[1])\n\t}\n}\n\nfunc TestIsApprovedForAll(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\").Resolve()\n\n\tisApprovedForAll := dummy.IsApprovedForAll(addr1, addr2)\n\tif isApprovedForAll != false {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n}\n\nfunc TestSetApprovalForAll(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\n\tisApprovedForAll := dummy.IsApprovedForAll(caller, addr)\n\tif isApprovedForAll != false {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n\n\terr := dummy.SetApprovalForAll(addr, true)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tif isApprovedForAll != true {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", true, isApprovedForAll)\n\t}\n\n\terr = dummy.SetApprovalForAll(addr, false)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tisApprovedForAll = dummy.IsApprovedForAll(caller, addr)\n\tif isApprovedForAll != false {\n\t\tt.Errorf(\"expected: (%v), got: (%v)\", false, isApprovedForAll)\n\t}\n}\n\nfunc TestSafeTransferFrom(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\n\ttid := TokenID(\"1\")\n\n\tdummy.mintBatch(caller, []TokenID{tid}, []uint64{100})\n\n\terr := dummy.SafeTransferFrom(caller, zeroAddress, tid, 10)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\n\terr = dummy.SafeTransferFrom(caller, addr, tid, 160)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\n\terr = dummy.SafeTransferFrom(caller, addr, tid, 60)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check balance of caller after transfer\n\tbalanceOfCaller, err := dummy.BalanceOf(caller, tid)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfCaller != 40 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 40, balanceOfCaller)\n\t}\n\n\t// Check balance of addr after transfer\n\tbalanceOfAddr, err := dummy.BalanceOf(addr, tid)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tif balanceOfAddr != 60 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 60, balanceOfAddr)\n\t}\n}\n\nfunc TestSafeBatchTransferFrom(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\tcaller := std.GetOrigCaller()\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\tdummy.mintBatch(caller, []TokenID{tid1, tid2}, []uint64{10, 100})\n\n\terr := dummy.SafeBatchTransferFrom(caller, zeroAddress, []TokenID{tid1, tid2}, []uint64{4, 60})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.SafeBatchTransferFrom(caller, addr, []TokenID{tid1, tid2}, []uint64{40, 60})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.SafeBatchTransferFrom(caller, addr, []TokenID{tid1}, []uint64{40, 60})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.SafeBatchTransferFrom(caller, addr, []TokenID{tid1, tid2}, []uint64{4, 60})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{caller, addr, caller, addr}, []TokenID{tid1, tid1, tid2, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check token1's balance of caller after batch transfer\n\tif balanceBatch[0] != 6 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 6, balanceBatch[0])\n\t}\n\n\t// Check token1's balance of addr after batch transfer\n\tif balanceBatch[1] != 4 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 4, balanceBatch[1])\n\t}\n\n\t// Check token2's balance of caller after batch transfer\n\tif balanceBatch[2] != 40 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 40, balanceBatch[2])\n\t}\n\n\t// Check token2's balance of addr after batch transfer\n\tif balanceBatch[3] != 60 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 60, balanceBatch[3])\n\t}\n}\n\nfunc TestSafeMint(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\terr := dummy.SafeMint(zeroAddress, tid1, 100)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.SafeMint(addr1, tid1, 100)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.SafeMint(addr1, tid2, 200)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.SafeMint(addr2, tid1, 50)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{addr1, addr2, addr1}, []TokenID{tid1, tid1, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\t// Check token1's balance of addr1 after mint\n\tif balanceBatch[0] != 100 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 100, balanceBatch[0])\n\t}\n\t// Check token1's balance of addr2 after mint\n\tif balanceBatch[1] != 50 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 50, balanceBatch[1])\n\t}\n\t// Check token2's balance of addr1 after mint\n\tif balanceBatch[2] != 200 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 200, balanceBatch[2])\n\t}\n}\n\nfunc TestSafeBatchMint(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr1 := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\taddr2 := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\terr := dummy.SafeBatchMint(zeroAddress, []TokenID{tid1, tid2}, []uint64{100, 200})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.SafeBatchMint(addr1, []TokenID{tid1, tid2}, []uint64{100, 200})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.SafeBatchMint(addr2, []TokenID{tid1, tid2}, []uint64{300, 400})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{addr1, addr2, addr1, addr2}, []TokenID{tid1, tid1, tid2, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\t// Check token1's balance of addr1 after batch mint\n\tif balanceBatch[0] != 100 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 100, balanceBatch[0])\n\t}\n\t// Check token1's balance of addr2 after batch mint\n\tif balanceBatch[1] != 300 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 300, balanceBatch[1])\n\t}\n\t// Check token2's balance of addr1 after batch mint\n\tif balanceBatch[2] != 200 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 200, balanceBatch[2])\n\t}\n\t// Check token2's balance of addr2 after batch mint\n\tif balanceBatch[3] != 400 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 400, balanceBatch[3])\n\t}\n}\n\nfunc TestBurn(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\tdummy.mintBatch(addr, []TokenID{tid1, tid2}, []uint64{100, 200})\n\terr := dummy.Burn(zeroAddress, tid1, 60)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.Burn(addr, tid1, 160)\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.Burn(addr, tid1, 60)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\terr = dummy.Burn(addr, tid2, 60)\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{addr, addr}, []TokenID{tid1, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check token1's balance of addr after burn\n\tif balanceBatch[0] != 40 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 40, balanceBatch[0])\n\t}\n\t// Check token2's balance of addr after burn\n\tif balanceBatch[1] != 140 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 140, balanceBatch[1])\n\t}\n}\n\nfunc TestBatchBurn(t *testing.T) {\n\tdummy := NewBasicGRC1155Token(dummyURI)\n\tif dummy == nil {\n\t\tt.Errorf(\"should not be nil\")\n\t}\n\n\taddr := users.AddressOrName(\"g1var589z07ppjsjd24ukm4uguzwdt0tw7g47cgm\").Resolve()\n\n\ttid1 := TokenID(\"1\")\n\ttid2 := TokenID(\"2\")\n\n\tdummy.mintBatch(addr, []TokenID{tid1, tid2}, []uint64{100, 200})\n\terr := dummy.BatchBurn(zeroAddress, []TokenID{tid1, tid2}, []uint64{60, 60})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.BatchBurn(addr, []TokenID{tid1, tid2}, []uint64{160, 60})\n\tif err == nil {\n\t\tt.Errorf(\"should result in error\")\n\t}\n\terr = dummy.BatchBurn(addr, []TokenID{tid1, tid2}, []uint64{60, 60})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\tbalanceBatch, err := dummy.BalanceOfBatch([]std.Address{addr, addr}, []TokenID{tid1, tid2})\n\tif err != nil {\n\t\tt.Errorf(\"should not result in error\")\n\t}\n\n\t// Check token1's balance of addr after batch burn\n\tif balanceBatch[0] != 40 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 40, balanceBatch[0])\n\t}\n\t// Check token2's balance of addr after batch burn\n\tif balanceBatch[1] != 140 {\n\t\tt.Errorf(\"expected: (%d), got: (%d)\", 140, balanceBatch[1])\n\t}\n}\n"
                },
                {
                  "Name": "errors.gno",
                  "Body": "package grc1155\n\nimport \"errors\"\n\nvar (\n\tErrInvalidAddress                         = errors.New(\"invalid address\")\n\tErrMismatchLength                         = errors.New(\"accounts and ids length mismatch\")\n\tErrCannotTransferToSelf                   = errors.New(\"cannot send transfer to self\")\n\tErrTransferToRejectedOrNonGRC1155Receiver = errors.New(\"transfer to rejected or non GRC1155Receiver implementer\")\n\tErrCallerIsNotOwnerOrApproved             = errors.New(\"caller is not token owner or approved\")\n\tErrInsufficientBalance                    = errors.New(\"insufficient balance for transfer\")\n\tErrBurnAmountExceedsBalance               = errors.New(\"burn amount exceeds balance\")\n)\n"
                },
                {
                  "Name": "igrc1155.gno",
                  "Body": "package grc1155\n\nimport \"std\"\n\ntype IGRC1155 interface {\n\tSafeTransferFrom(from, to std.Address, tid TokenID, amount uint64) error\n\tSafeBatchTransferFrom(from, to std.Address, batch []TokenID, amounts []uint64) error\n\tBalanceOf(owner std.Address, tid TokenID) (uint64, error)\n\tBalanceOfBatch(owners []std.Address, batch []TokenID) ([]uint64, error)\n\tSetApprovalForAll(operator std.Address, approved bool) error\n\tIsApprovedForAll(owner, operator std.Address) bool\n}\n\ntype TokenID string\n\ntype TransferSingleEvent struct {\n\tOperator std.Address\n\tFrom     std.Address\n\tTo       std.Address\n\tTokenID  TokenID\n\tAmount   uint64\n}\n\ntype TransferBatchEvent struct {\n\tOperator std.Address\n\tFrom     std.Address\n\tTo       std.Address\n\tBatch    []TokenID\n\tAmounts  []uint64\n}\n\ntype ApprovalForAllEvent struct {\n\tOwner    std.Address\n\tOperator std.Address\n\tApproved bool\n}\n\ntype UpdateURIEvent struct {\n\tURI string\n}\n"
                },
                {
                  "Name": "util.gno",
                  "Body": "package grc1155\n\nimport (\n\t\"std\"\n)\n\nconst zeroAddress std.Address = \"\"\n\nfunc isValidAddress(addr std.Address) bool {\n\tif addr.String() == \"\" {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc emit(event interface{}) {\n\t// TODO: setup a pubsub system here?\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "maths",
              "Path": "gno.land/p/demo/maths",
              "Files": [
                {
                  "Name": "maths.gno",
                  "Body": "package maths\n\nconst (\n\tintSize = 32 \u003c\u003c (^uint(0) \u003e\u003e 63) // 32 or 64\n\n\tMaxInt    = 1\u003c\u003c(intSize-1) - 1\n\tMinInt    = -1 \u003c\u003c (intSize - 1)\n\tMaxInt8   = 1\u003c\u003c7 - 1\n\tMinInt8   = -1 \u003c\u003c 7\n\tMaxInt16  = 1\u003c\u003c15 - 1\n\tMinInt16  = -1 \u003c\u003c 15\n\tMaxInt32  = 1\u003c\u003c31 - 1\n\tMinInt32  = -1 \u003c\u003c 31\n\tMaxInt64  = 1\u003c\u003c63 - 1\n\tMinInt64  = -1 \u003c\u003c 63\n\tMaxUint   = 1\u003c\u003cintSize - 1\n\tMaxUint8  = 1\u003c\u003c8 - 1\n\tMaxUint16 = 1\u003c\u003c16 - 1\n\tMaxUint32 = 1\u003c\u003c32 - 1\n\tMaxUint64 = 1\u003c\u003c64 - 1\n)\n"
                },
                {
                  "Name": "overflow.gno",
                  "Body": "// This is modified from https://github.com/JohnCGriffin/overflow (MIT).\n// NOTE: there was a bug with the original Quotient* functions, and\n// testing method. These have been fixed here, and tests ported to\n// tests/files/maths_int*.go respectively.\n// TODO: make PR upstream.\npackage maths\n\n/*\nPackage overflow offers overflow-checked integer arithmetic operations\nfor int, int32, and int64. Each of the operations returns a\nresult,bool combination.  This was prompted by the need to know when\nto flow into higher precision types from the math.big library.\n\nFor instance, assuing a 64 bit machine:\n\n10 + 20 -\u003e 30\nint(math.MaxInt64) + 1 -\u003e -9223372036854775808\n\nwhereas\n\noverflow.Add(10,20) -\u003e (30, true)\noverflow.Add(math.MaxInt64,1) -\u003e (0, false)\n\nAdd, Sub, Mul, Div are for int.  Add64, Add32, etc. are specifically sized.\n\nIf anybody wishes an unsigned version, submit a pull request for code\nand new tests. */\n\n//go:generate ./overflow_template.sh\n\nfunc _is64Bit() bool {\n\tmaxU32 := uint(MaxUint32)\n\treturn ((maxU32 \u003c\u003c 1) \u003e\u003e 1) == maxU32\n}\n\n/********** PARTIAL TEST COVERAGE FROM HERE DOWN *************\n\nThe only way that I could see to do this is a combination of\nmy normal 64 bit system and a GopherJS running on Node.  My\nunderstanding is that its ints are 32 bit.\n\nSo, FEEL FREE to carefully review the code visually.\n\n*************************************************************/\n\n// Unspecified size, i.e. normal signed int\n\n// Add sums two ints, returning the result and a boolean status.\nfunc Add(a, b int) (int, bool) {\n\tif _is64Bit() {\n\t\tr64, ok := Add64(int64(a), int64(b))\n\t\treturn int(r64), ok\n\t}\n\tr32, ok := Add32(int32(a), int32(b))\n\treturn int(r32), ok\n}\n\n// Sub returns the difference of two ints and a boolean status.\nfunc Sub(a, b int) (int, bool) {\n\tif _is64Bit() {\n\t\tr64, ok := Sub64(int64(a), int64(b))\n\t\treturn int(r64), ok\n\t}\n\tr32, ok := Sub32(int32(a), int32(b))\n\treturn int(r32), ok\n}\n\n// Mul returns the product of two ints and a boolean status.\nfunc Mul(a, b int) (int, bool) {\n\tif _is64Bit() {\n\t\tr64, ok := Mul64(int64(a), int64(b))\n\t\treturn int(r64), ok\n\t}\n\tr32, ok := Mul32(int32(a), int32(b))\n\treturn int(r32), ok\n}\n\n// Div returns the quotient of two ints and a boolean status\nfunc Div(a, b int) (int, bool) {\n\tif _is64Bit() {\n\t\tr64, ok := Div64(int64(a), int64(b))\n\t\treturn int(r64), ok\n\t}\n\tr32, ok := Div32(int32(a), int32(b))\n\treturn int(r32), ok\n}\n\n// Quo returns the quotient, remainder and status of two ints\nfunc Quo(a, b int) (int, int, bool) {\n\tif _is64Bit() {\n\t\tq64, r64, ok := Quo64(int64(a), int64(b))\n\t\treturn int(q64), int(r64), ok\n\t}\n\tq32, r32, ok := Quo32(int32(a), int32(b))\n\treturn int(q32), int(r32), ok\n}\n\n/************* Panic versions for int ****************/\n\n// Addp returns the sum of two ints, panicking on overflow\nfunc Addp(a, b int) int {\n\tr, ok := Add(a, b)\n\tif !ok {\n\t\tpanic(\"addition overflow\")\n\t}\n\treturn r\n}\n\n// Subp returns the difference of two ints, panicking on overflow.\nfunc Subp(a, b int) int {\n\tr, ok := Sub(a, b)\n\tif !ok {\n\t\tpanic(\"subtraction overflow\")\n\t}\n\treturn r\n}\n\n// Mulp returns the product of two ints, panicking on overflow.\nfunc Mulp(a, b int) int {\n\tr, ok := Mul(a, b)\n\tif !ok {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn r\n}\n\n// Divp returns the quotient of two ints, panicking on overflow.\nfunc Divp(a, b int) int {\n\tr, ok := Div(a, b)\n\tif !ok {\n\t\tpanic(\"division failure\")\n\t}\n\treturn r\n}\n\n//----------------------------------------\n// This is generated code, created by overflow_template.sh executed\n// by \"go generate\"\n\n// Add8 performs + operation on two int8 operands\n// returning a result and status\nfunc Add8(a, b int8) (int8, bool) {\n\tc := a + b\n\tif (c \u003e a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Add8p is the unchecked panicking version of Add8\nfunc Add8p(a, b int8) int8 {\n\tr, ok := Add8(a, b)\n\tif !ok {\n\t\tpanic(\"addition overflow\")\n\t}\n\treturn r\n}\n\n// Sub8 performs - operation on two int8 operands\n// returning a result and status\nfunc Sub8(a, b int8) (int8, bool) {\n\tc := a - b\n\tif (c \u003c a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Sub8p is the unchecked panicking version of Sub8\nfunc Sub8p(a, b int8) int8 {\n\tr, ok := Sub8(a, b)\n\tif !ok {\n\t\tpanic(\"subtraction overflow\")\n\t}\n\treturn r\n}\n\n// Mul8 performs * operation on two int8 operands\n// returning a result and status\nfunc Mul8(a, b int8) (int8, bool) {\n\tif a == 0 || b == 0 {\n\t\treturn 0, true\n\t}\n\tc := a * b\n\tif (c \u003c 0) == ((a \u003c 0) != (b \u003c 0)) {\n\t\tif c/b == a {\n\t\t\treturn c, true\n\t\t}\n\t}\n\treturn c, false\n}\n\n// Mul8p is the unchecked panicking version of Mul8\nfunc Mul8p(a, b int8) int8 {\n\tr, ok := Mul8(a, b)\n\tif !ok {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn r\n}\n\n// Div8 performs / operation on two int8 operands\n// returning a result and status\nfunc Div8(a, b int8) (int8, bool) {\n\tq, _, ok := Quo8(a, b)\n\treturn q, ok\n}\n\n// Div8p is the unchecked panicking version of Div8\nfunc Div8p(a, b int8) int8 {\n\tr, ok := Div8(a, b)\n\tif !ok {\n\t\tpanic(\"division failure\")\n\t}\n\treturn r\n}\n\n// Quo8 performs + operation on two int8 operands\n// returning a quotient, a remainder and status\nfunc Quo8(a, b int8) (int8, int8, bool) {\n\tif b == 0 {\n\t\treturn 0, 0, false\n\t} else if b == -1 \u0026\u0026 a == MinInt8 {\n\t\treturn 0, 0, false\n\t}\n\tc := a / b\n\treturn c, a % b, true\n}\n\n// Add16 performs + operation on two int16 operands\n// returning a result and status\nfunc Add16(a, b int16) (int16, bool) {\n\tc := a + b\n\tif (c \u003e a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Add16p is the unchecked panicking version of Add16\nfunc Add16p(a, b int16) int16 {\n\tr, ok := Add16(a, b)\n\tif !ok {\n\t\tpanic(\"addition overflow\")\n\t}\n\treturn r\n}\n\n// Sub16 performs - operation on two int16 operands\n// returning a result and status\nfunc Sub16(a, b int16) (int16, bool) {\n\tc := a - b\n\tif (c \u003c a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Sub16p is the unchecked panicking version of Sub16\nfunc Sub16p(a, b int16) int16 {\n\tr, ok := Sub16(a, b)\n\tif !ok {\n\t\tpanic(\"subtraction overflow\")\n\t}\n\treturn r\n}\n\n// Mul16 performs * operation on two int16 operands\n// returning a result and status\nfunc Mul16(a, b int16) (int16, bool) {\n\tif a == 0 || b == 0 {\n\t\treturn 0, true\n\t}\n\tc := a * b\n\tif (c \u003c 0) == ((a \u003c 0) != (b \u003c 0)) {\n\t\tif c/b == a {\n\t\t\treturn c, true\n\t\t}\n\t}\n\treturn c, false\n}\n\n// Mul16p is the unchecked panicking version of Mul16\nfunc Mul16p(a, b int16) int16 {\n\tr, ok := Mul16(a, b)\n\tif !ok {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn r\n}\n\n// Div16 performs / operation on two int16 operands\n// returning a result and status\nfunc Div16(a, b int16) (int16, bool) {\n\tq, _, ok := Quo16(a, b)\n\treturn q, ok\n}\n\n// Div16p is the unchecked panicking version of Div16\nfunc Div16p(a, b int16) int16 {\n\tr, ok := Div16(a, b)\n\tif !ok {\n\t\tpanic(\"division failure\")\n\t}\n\treturn r\n}\n\n// Quo16 performs + operation on two int16 operands\n// returning a quotient, a remainder and status\nfunc Quo16(a, b int16) (int16, int16, bool) {\n\tif b == 0 {\n\t\treturn 0, 0, false\n\t} else if b == -1 \u0026\u0026 a == MinInt16 {\n\t\treturn 0, 0, false\n\t}\n\tc := a / b\n\treturn c, a % b, true\n}\n\n// Add32 performs + operation on two int32 operands\n// returning a result and status\nfunc Add32(a, b int32) (int32, bool) {\n\tc := a + b\n\tif (c \u003e a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Add32p is the unchecked panicking version of Add32\nfunc Add32p(a, b int32) int32 {\n\tr, ok := Add32(a, b)\n\tif !ok {\n\t\tpanic(\"addition overflow\")\n\t}\n\treturn r\n}\n\n// Sub32 performs - operation on two int32 operands\n// returning a result and status\nfunc Sub32(a, b int32) (int32, bool) {\n\tc := a - b\n\tif (c \u003c a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Sub32p is the unchecked panicking version of Sub32\nfunc Sub32p(a, b int32) int32 {\n\tr, ok := Sub32(a, b)\n\tif !ok {\n\t\tpanic(\"subtraction overflow\")\n\t}\n\treturn r\n}\n\n// Mul32 performs * operation on two int32 operands\n// returning a result and status\nfunc Mul32(a, b int32) (int32, bool) {\n\tif a == 0 || b == 0 {\n\t\treturn 0, true\n\t}\n\tc := a * b\n\tif (c \u003c 0) == ((a \u003c 0) != (b \u003c 0)) {\n\t\tif c/b == a {\n\t\t\treturn c, true\n\t\t}\n\t}\n\treturn c, false\n}\n\n// Mul32p is the unchecked panicking version of Mul32\nfunc Mul32p(a, b int32) int32 {\n\tr, ok := Mul32(a, b)\n\tif !ok {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn r\n}\n\n// Div32 performs / operation on two int32 operands\n// returning a result and status\nfunc Div32(a, b int32) (int32, bool) {\n\tq, _, ok := Quo32(a, b)\n\treturn q, ok\n}\n\n// Div32p is the unchecked panicking version of Div32\nfunc Div32p(a, b int32) int32 {\n\tr, ok := Div32(a, b)\n\tif !ok {\n\t\tpanic(\"division failure\")\n\t}\n\treturn r\n}\n\n// Quo32 performs + operation on two int32 operands\n// returning a quotient, a remainder and status\nfunc Quo32(a, b int32) (int32, int32, bool) {\n\tif b == 0 {\n\t\treturn 0, 0, false\n\t} else if b == -1 \u0026\u0026 a == MinInt32 {\n\t\treturn 0, 0, false\n\t}\n\tc := a / b\n\treturn c, a % b, true\n}\n\n// Add64 performs + operation on two int64 operands\n// returning a result and status\nfunc Add64(a, b int64) (int64, bool) {\n\tc := a + b\n\tif (c \u003e a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Add64p is the unchecked panicking version of Add64\nfunc Add64p(a, b int64) int64 {\n\tr, ok := Add64(a, b)\n\tif !ok {\n\t\tpanic(\"addition overflow\")\n\t}\n\treturn r\n}\n\n// Sub64 performs - operation on two int64 operands\n// returning a result and status\nfunc Sub64(a, b int64) (int64, bool) {\n\tc := a - b\n\tif (c \u003c a) == (b \u003e 0) {\n\t\treturn c, true\n\t}\n\treturn c, false\n}\n\n// Sub64p is the unchecked panicking version of Sub64\nfunc Sub64p(a, b int64) int64 {\n\tr, ok := Sub64(a, b)\n\tif !ok {\n\t\tpanic(\"subtraction overflow\")\n\t}\n\treturn r\n}\n\n// Mul64 performs * operation on two int64 operands\n// returning a result and status\nfunc Mul64(a, b int64) (int64, bool) {\n\tif a == 0 || b == 0 {\n\t\treturn 0, true\n\t}\n\tc := a * b\n\tif (c \u003c 0) == ((a \u003c 0) != (b \u003c 0)) {\n\t\tif c/b == a {\n\t\t\treturn c, true\n\t\t}\n\t}\n\treturn c, false\n}\n\n// Mul64p is the unchecked panicking version of Mul64\nfunc Mul64p(a, b int64) int64 {\n\tr, ok := Mul64(a, b)\n\tif !ok {\n\t\tpanic(\"multiplication overflow\")\n\t}\n\treturn r\n}\n\n// Div64 performs / operation on two int64 operands\n// returning a result and status\nfunc Div64(a, b int64) (int64, bool) {\n\tq, _, ok := Quo64(a, b)\n\treturn q, ok\n}\n\n// Div64p is the unchecked panicking version of Div64\nfunc Div64p(a, b int64) int64 {\n\tr, ok := Div64(a, b)\n\tif !ok {\n\t\tpanic(\"division failure\")\n\t}\n\treturn r\n}\n\n// Quo64 performs + operation on two int64 operands\n// returning a quotient, a remainder and status\nfunc Quo64(a, b int64) (int64, int64, bool) {\n\tif b == 0 {\n\t\treturn 0, 0, false\n\t} else if b == -1 \u0026\u0026 a == MinInt64 {\n\t\treturn 0, 0, false\n\t}\n\tc := a / b\n\treturn c, a % b, true\n}\n"
                },
                {
                  "Name": "rat.gno",
                  "Body": "package maths\n\n//----------------------------------------\n// Rat fractions\n\n// represents a fraction.\ntype Rat struct {\n\tX int32\n\tY int32 // must be positive\n}\n\nfunc NewRat(x, y int32) Rat {\n\tif y \u003c= 0 {\n\t\tpanic(\"invalid std.Rat denominator\")\n\t}\n\treturn Rat{X: x, Y: y}\n}\n\nfunc (r1 Rat) IsValid() bool {\n\tif r1.Y \u003c= 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (r1 Rat) Cmp(r2 Rat) int {\n\tif !r1.IsValid() {\n\t\tpanic(\"invalid std.Rat left operand\")\n\t}\n\tif !r2.IsValid() {\n\t\tpanic(\"invalid std.Rat right operand\")\n\t}\n\tvar p1, p2 int64\n\tp1 = int64(r1.X) * int64(r2.Y)\n\tp2 = int64(r1.Y) * int64(r2.X)\n\tif p1 \u003c p2 {\n\t\treturn -1\n\t} else if p1 == p2 {\n\t\treturn 0\n\t} else {\n\t\treturn 1\n\t}\n}\n\n//func (r1 Rat) Plus(r2 Rat) Rat {\n// XXX\n//}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "blog",
              "Path": "gno.land/p/demo/blog",
              "Files": [
                {
                  "Name": "blog.gno",
                  "Body": "package blog\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype Blog struct {\n\tTitle  string\n\tPrefix string   // i.e. r/gnoland/blog:\n\tPosts  avl.Tree // slug -\u003e Post\n}\n\nfunc (b Blog) Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\n\tisHome := path == \"\"\n\tisViewPost := len(parts) == 2 \u0026\u0026 parts[0] == \"p\" \u0026\u0026 len(parts[1]) \u003e 0\n\tisViewTag := len(parts) == 2 \u0026\u0026 parts[0] == \"t\" \u0026\u0026 len(parts[1]) \u003e 0\n\n\tswitch {\n\tcase isHome:\n\t\toutput := breadcrumb([]string{b.Title})\n\n\t\tif b.Posts.Size() == 0 {\n\t\t\toutput += \"No posts.\"\n\t\t\treturn output\n\t\t}\n\n\t\tb.Posts.Iterate(\"\", \"\", func(n *avl.Node) bool {\n\t\t\tpost := n.Value().(*Post)\n\t\t\toutput += post.RenderListItem()\n\t\t\treturn false\n\t\t})\n\n\t\t// FIXME: tag list/cloud.\n\t\treturn output\n\n\tcase isViewPost:\n\t\tslug := parts[1]\n\n\t\tpost, found := b.Posts.Get(slug)\n\t\tif !found {\n\t\t\treturn \"404\"\n\t\t}\n\t\tp := post.(*Post)\n\n\t\toutput := breadcrumb([]string{\n\t\t\tufmt.Sprintf(\"[%s](%s)\", b.Title, b.Prefix),\n\t\t\t\"p\",\n\t\t\tp.Title,\n\t\t})\n\n\t\t// output += ufmt.Sprintf(\"## [%s](%s)\\n\", p.Title, p.URL())\n\t\toutput += p.Body + \"\\n\\n\"\n\t\toutput += p.RenderTagList() + \"\\n\\n\"\n\t\toutput += formatAuthorAndDate(p.Author, p.CreatedAt) + \"\\n\"\n\t\toutput += \"\\n\"\n\n\t\t// comments\n\t\tp.Comments.IterateReverse(\"\", \"\", func(n *avl.Node) bool {\n\t\t\tcomment := n.Value().(*Comment)\n\t\t\toutput += comment.RenderListItem()\n\t\t\treturn false\n\t\t})\n\n\t\treturn output\n\n\tcase isViewTag:\n\t\ttagSlug := parts[1]\n\n\t\toutput := breadcrumb([]string{\n\t\t\tufmt.Sprintf(\"[%s](%s)\", b.Title, b.Prefix),\n\t\t\t\"t\",\n\t\t\ttagSlug,\n\t\t})\n\n\t\tnb := 0\n\t\tb.Posts.Iterate(\"\", \"\", func(n *avl.Node) bool {\n\t\t\tpost := n.Value().(*Post)\n\t\t\tif !post.HasTag(tagSlug) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\toutput += post.RenderListItem()\n\t\t\tnb++\n\t\t\treturn false\n\t\t})\n\t\tif nb == 0 {\n\t\t\toutput += \"No posts.\"\n\t\t}\n\t\treturn output\n\t}\n\n\treturn \"404\"\n}\n\nfunc (b *Blog) NewPost(author std.Address, slug, title, body string, tags []string) error {\n\t_, found := b.Posts.Get(slug)\n\tif found {\n\t\treturn errors.New(\"slug already exists.\")\n\t}\n\n\tpost := Post{\n\t\tAuthor:    author,\n\t\tSlug:      slug,\n\t\tTitle:     title,\n\t\tBody:      body,\n\t\tTags:      tags,\n\t\tCreatedAt: time.Now(),\n\t}\n\treturn b.prepareAndSetPost(\u0026post)\n}\n\nfunc (b *Blog) prepareAndSetPost(post *Post) error {\n\tpost.Title = strings.TrimSpace(post.Title)\n\tpost.Body = strings.TrimSpace(post.Body)\n\n\tif post.Title == \"\" {\n\t\treturn errors.New(\"title is missing.\")\n\t}\n\tif post.Body == \"\" {\n\t\treturn errors.New(\"body is missing.\")\n\t}\n\tif post.Slug == \"\" {\n\t\treturn errors.New(\"slug is missing.\")\n\t}\n\t// more input sanitization?\n\n\tpost.Blog = b\n\tpost.UpdatedAt = time.Now()\n\n\tb.Posts.Set(post.Slug, post)\n\treturn nil\n}\n\nfunc (b *Blog) GetPost(slug string) *Post {\n\tpost, found := b.Posts.Get(slug)\n\tif !found {\n\t\treturn nil\n\t}\n\treturn post.(*Post)\n}\n\ntype Post struct {\n\tBlog         *Blog\n\tSlug         string // FIXME: save space?\n\tTitle        string\n\tBody         string\n\tCreatedAt    time.Time\n\tUpdatedAt    time.Time\n\tComments     avl.Tree\n\tAuthor       std.Address\n\tTags         []string\n\tCommentIndex int\n}\n\nfunc (p *Post) Update(title, body string, tags []string) error {\n\tp.Title = title\n\tp.Body = body\n\tp.Tags = tags\n\treturn p.Blog.prepareAndSetPost(p)\n}\n\nfunc (p *Post) AddComment(author std.Address, comment string) error {\n\tif p == nil {\n\t\treturn ErrNoSuchPost\n\t}\n\tp.CommentIndex++\n\tcommentKey := strconv.Itoa(p.CommentIndex)\n\tcomment = strings.TrimSpace(comment)\n\tp.Comments.Set(commentKey, \u0026Comment{\n\t\tPost:      p,\n\t\tCreatedAt: time.Now(),\n\t\tAuthor:    author,\n\t\tComment:   comment,\n\t})\n\n\treturn nil\n}\n\nfunc (p *Post) DeleteComment(index int) error {\n\tif p == nil {\n\t\treturn ErrNoSuchPost\n\t}\n\tcommentKey := strconv.Itoa(index)\n\tp.Comments.Remove(commentKey)\n\treturn nil\n}\n\nfunc (p *Post) HasTag(tag string) bool {\n\tif p == nil {\n\t\treturn false\n\t}\n\tfor _, t := range p.Tags {\n\t\tif t == tag {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *Post) RenderListItem() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\toutput := \"\"\n\toutput += ufmt.Sprintf(\"## [\u0026#9656; %s](%s)\\n\", p.Title, p.URL())\n\t// output += p.Summary() + \"\\n\\n\"\n\t// output += p.RenderTagList() + \"\\n\\n\"\n\t// output += formatAuthorAndDate(p.Author, p.CreatedAt) + \"\\n\"\n\toutput += \"\\n\"\n\treturn output\n}\n\nfunc (p *Post) RenderTagList() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\toutput := \"\"\n\tfor idx, tag := range p.Tags {\n\t\tif idx \u003e 0 {\n\t\t\toutput += \" \"\n\t\t}\n\t\ttagURL := p.Blog.Prefix + \"t/\" + tag\n\t\toutput += ufmt.Sprintf(\"[#%s](%s)\", tag, tagURL)\n\t}\n\treturn output\n}\n\nfunc (p *Post) URL() string {\n\tif p == nil {\n\t\treturn p.Blog.Prefix + \"404\"\n\t}\n\treturn p.Blog.Prefix + \"p/\" + p.Slug\n}\n\nfunc (p *Post) Summary() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\n\t// FIXME: better summary.\n\tlines := strings.Split(p.Body, \"\\n\")\n\tif len(lines) \u003c= 3 {\n\t\treturn p.Body\n\t}\n\treturn strings.Join(lines[0:3], \"\\n\") + \"...\"\n}\n\ntype Comment struct {\n\tPost      *Post\n\tCreatedAt time.Time\n\tAuthor    std.Address\n\tComment   string\n}\n\nfunc (c Comment) RenderListItem() string {\n\toutput := \"\"\n\toutput += ufmt.Sprintf(\"#### %s\\n\", formatAuthorAndDate(c.Author, c.CreatedAt))\n\toutput += c.Comment + \"\\n\"\n\toutput += \"\\n\"\n\treturn output\n}\n\nfunc formatAuthorAndDate(author std.Address, createdAt time.Time) string {\n\tauthorString := author.String() // FIXME: username.\n\tcreatedAtString := createdAt.Format(\"2006-01-02 3:04pm MST\")\n\treturn ufmt.Sprintf(\"by %s on %s\", authorString, createdAtString)\n}\n"
                },
                {
                  "Name": "blog_test.gno",
                  "Body": "package blog\n\n// TODO: add generic tests here.\n//       right now, you can checkout r/gnoland/blog/*_test.gno.\n"
                },
                {
                  "Name": "errors.gno",
                  "Body": "package blog\n\nimport \"errors\"\n\nvar ErrNoSuchPost = errors.New(\"no such post\")\n"
                },
                {
                  "Name": "util.gno",
                  "Body": "package blog\n\nimport \"strings\"\n\nfunc breadcrumb(parts []string) string {\n\treturn \"# \" + strings.Join(parts, \" / \") + \"\\n\\n\"\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "users",
              "Path": "gno.land/r/demo/users",
              "Files": [
                {
                  "Name": "types.gno",
                  "Body": "package users\n\nimport \"std\"\n\ntype AddressOrName string\n\nfunc (aon AddressOrName) IsName() bool {\n\treturn aon != \"\" \u0026\u0026 aon[0] == '@'\n}\n\nfunc (aon AddressOrName) GetName() (string, bool) {\n\tif len(aon) \u003e= 2 \u0026\u0026 aon[0] == '@' {\n\t\treturn string(aon[1:]), true\n\t}\n\treturn \"\", false\n}\n\nfunc (aon AddressOrName) Resolve() std.Address {\n\tname, isName := aon.GetName()\n\tif isName {\n\t\tuser := GetUserByName(name)\n\t\treturn user.address\n\t} else {\n\t\treturn std.Address(aon) // TODO check validity\n\t}\n}\n"
                },
                {
                  "Name": "users.gno",
                  "Body": "package users\n\nimport (\n\t\"regexp\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Types\n\ntype User struct {\n\taddress std.Address\n\tname    string\n\tprofile string\n\tnumber  int\n\tinvites int\n\tinviter std.Address\n}\n\nfunc (u *User) Render() string {\n\tstr := \"## user \" + u.name + \"\\n\" +\n\t\t\"\\n\" +\n\t\t\" * address = \" + string(u.address) + \"\\n\" +\n\t\t\" * \" + strconv.Itoa(u.invites) + \" invites\\n\"\n\tif u.inviter != \"\" {\n\t\tstr = str + \" * invited by \" + string(u.inviter) + \"\\n\"\n\t}\n\tstr = str + \"\\n\" +\n\t\tu.profile + \"\\n\"\n\treturn str\n}\n\nfunc (u User) Name() string         { return u.name }\nfunc (u User) Profile() string      { return u.profile }\nfunc (u User) Address() std.Address { return u.address }\n\n//----------------------------------------\n// State\n\nvar (\n\tadmin      std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\"\n\tname2User  avl.Tree                    // Name -\u003e *User\n\taddr2User  avl.Tree                    // std.Address -\u003e *User\n\tinvites    avl.Tree                    // string(inviter+\":\"+invited) -\u003e true\n\tcounter    int                         // user id counter\n\tminFee     int64       = 200 * 1000000 // minimum gnot must be paid to register.\n\tmaxFeeMult int64       = 10            // maximum multiples of minFee accepted.\n)\n\n//----------------------------------------\n// Top-level functions\n\nfunc Register(inviter std.Address, name string, profile string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert invited or paid.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tsentCoins := std.GetOrigSend()\n\tminCoin := std.Coin{\"ugnot\", minFee}\n\tif inviter == \"\" {\n\t\t// banker := std.GetBanker(std.BankerTypeOrigSend)\n\t\tif len(sentCoins) == 1 \u0026\u0026 sentCoins[0].IsGTE(minCoin) {\n\t\t\tif sentCoins[0].Amount \u003e minFee*maxFeeMult {\n\t\t\t\tpanic(\"payment must not be greater than \" + strconv.Itoa(int(minFee*maxFeeMult)))\n\t\t\t} else {\n\t\t\t\t// ok\n\t\t\t}\n\t\t} else {\n\t\t\tpanic(\"payment must not be less than \" + strconv.Itoa(int(minFee)))\n\t\t}\n\t} else {\n\t\tinvitekey := inviter.String() + \":\" + caller.String()\n\t\t_, ok := invites.Get(invitekey)\n\t\tif !ok {\n\t\t\tpanic(\"invalid invitation\")\n\t\t}\n\t\tinvites.Remove(invitekey)\n\t}\n\t// assert not already registered.\n\t_, ok := name2User.Get(name)\n\tif ok {\n\t\tpanic(\"name already registered\")\n\t}\n\t_, ok = addr2User.Get(caller.String())\n\tif ok {\n\t\tpanic(\"address already registered\")\n\t}\n\t// assert name is valid.\n\tif !reName.MatchString(name) {\n\t\tpanic(\"invalid name: \" + name + \" (must be at least 6 characters, lowercase alphanumeric with underscore)\")\n\t}\n\t// remainder of fees go toward invites.\n\tinvites := int(0)\n\tif len(sentCoins) == 1 {\n\t\tif sentCoins[0].Denom == \"ugnot\" \u0026\u0026 sentCoins[0].Amount \u003e= minFee {\n\t\t\tinvites = int(sentCoins[0].Amount / minFee)\n\t\t\tif inviter == \"\" \u0026\u0026 invites \u003e 0 {\n\t\t\t\tinvites -= 1\n\t\t\t}\n\t\t}\n\t}\n\t// register.\n\tcounter++\n\tuser := \u0026User{\n\t\taddress: caller,\n\t\tname:    name,\n\t\tprofile: profile,\n\t\tnumber:  counter,\n\t\tinvites: invites,\n\t\tinviter: inviter,\n\t}\n\tname2User.Set(name, user)\n\taddr2User.Set(caller.String(), user)\n}\n\nfunc Invite(invitee string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// get caller/inviter.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tlines := strings.Split(invitee, \"\\n\")\n\tif caller == admin {\n\t\t// nothing to do, all good\n\t} else {\n\t\t// ensure has invites.\n\t\tuserI, ok := addr2User.Get(caller.String())\n\t\tif !ok {\n\t\t\tpanic(\"user unknown\")\n\t\t}\n\t\tuser := userI.(*User)\n\t\tif user.invites \u003c= 0 {\n\t\t\tpanic(\"user has no invite tokens\")\n\t\t}\n\t\tuser.invites -= len(lines)\n\t\tif user.invites \u003c 0 {\n\t\t\tpanic(\"user has insufficient invite tokens\")\n\t\t}\n\t}\n\t// for each line...\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// record invite.\n\t\tinvitekey := string(caller) + \":\" + string(line)\n\t\tinvites.Set(invitekey, true)\n\t}\n}\n\nfunc GrantInvites(invites string) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin.\n\tcaller := std.GetCallerAt(2)\n\tif caller != std.GetOrigCaller() {\n\t\tpanic(\"should not happen\") // because std.AssertOrigCall().\n\t}\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// for each line...\n\tlines := strings.Split(invites, \"\\n\")\n\tfor _, line := range lines {\n\t\tif line == \"\" {\n\t\t\tcontinue // file bodies have a trailing newline.\n\t\t} else if strings.HasPrefix(line, `//`) {\n\t\t\tcontinue // comment\n\t\t}\n\t\t// parse name and invites.\n\t\tvar name string\n\t\tvar invites int\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) == 1 { // short for :1.\n\t\t\tname = parts[0]\n\t\t\tinvites = 1\n\t\t} else if len(parts) == 2 {\n\t\t\tname = parts[0]\n\t\t\tinvites_, err := strconv.Atoi(parts[1])\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tinvites = int(invites_)\n\t\t} else {\n\t\t\tpanic(\"should not happen\")\n\t\t}\n\t\t// give invites.\n\t\tuserI, ok := name2User.Get(name)\n\t\tif !ok {\n\t\t\t// maybe address.\n\t\t\tuserI, ok = addr2User.Get(name)\n\t\t\tif !ok {\n\t\t\t\tpanic(\"invalid user \" + name)\n\t\t\t}\n\t\t}\n\t\tuser := userI.(*User)\n\t\tuser.invites += invites\n\t}\n}\n\n// Any leftover fees go toward invitations.\nfunc SetMinFee(newMinFee int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tminFee = newMinFee\n}\n\n// This helps prevent fat finger accidents.\nfunc SetMaxFeeMultiple(newMaxFeeMult int64) {\n\t// assert CallTx call.\n\tstd.AssertOriginCall()\n\t// assert admin caller.\n\tcaller := std.GetCallerAt(2)\n\tif caller != admin {\n\t\tpanic(\"unauthorized\")\n\t}\n\t// update global variables.\n\tmaxFeeMult = newMaxFeeMult\n}\n\n//----------------------------------------\n// Exposed public functions\n\nfunc GetUserByName(name string) *User {\n\tuserI, ok := name2User.Get(name)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*User)\n}\n\nfunc GetUserByAddress(addr std.Address) *User {\n\tuserI, ok := addr2User.Get(addr.String())\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn userI.(*User)\n}\n\n// unlike GetUserByName, input must be \"@\" prefixed for names.\nfunc GetUserByAddressOrName(input AddressOrName) *User {\n\tname, isName := input.GetName()\n\tif isName {\n\t\treturn GetUserByName(name)\n\t}\n\treturn GetUserByAddress(std.Address(input))\n}\n\n//----------------------------------------\n// Constants\n\n// NOTE: name length must be clearly distinguishable from a bech32 address.\nvar reName = regexp.MustCompile(`^[a-z]+[_a-z0-9]{5,16}$`)\n\n//----------------------------------------\n// Render main page\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn renderHome()\n\t} else if len(path) \u003e= 38 { // 39? 40?\n\t\tif path[:2] != \"g1\" {\n\t\t\treturn \"invalid address \" + path\n\t\t}\n\t\tuser := GetUserByAddress(std.Address(path))\n\t\tif user == nil {\n\t\t\t// TODO: display basic information about account.\n\t\t\treturn \"unknown address \" + path\n\t\t}\n\t\treturn user.Render()\n\t} else {\n\t\tuser := GetUserByName(path)\n\t\tif user == nil {\n\t\t\treturn \"unknown username \" + path\n\t\t}\n\t\treturn user.Render()\n\t}\n}\n\nfunc renderHome() string {\n\tdoc := \"\"\n\tname2User.Iterate(\"\", \"\", func(t *avl.Node) bool {\n\t\tuser := t.Value().(*User)\n\t\tdoc += \" * [\" + user.name + \"](/r/demo/users:\" + user.name + \")\\n\"\n\t\treturn false\n\t})\n\treturn doc\n}\n"
                },
                {
                  "Name": "z_0_b_filetest.gno",
                  "Body": "package main\n\n// SEND: 199000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// payment must not be less than 200000000\n"
                },
                {
                  "Name": "z_0_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid coin denominations: dontcare\n"
                },
                {
                  "Name": "z_10_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/users_test\npackage users_test\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc init() {\n\tcaller := std.GetOrigCaller() // main\n\ttest2 := testutils.TestAddress(\"test2\")\n\t// as admin, invite gnouser and test2\n\tstd.TestSetOrigCaller(admin)\n\tusers.Invite(caller.String() + \"\\n\" + test2.String())\n\t// register as caller\n\tstd.TestSetOrigCaller(caller)\n\tusers.Register(admin, \"gnouser\", \"my profile\")\n}\n\nfunc main() {\n\t// register as test2\n\ttest2 := testutils.TestAddress(\"test2\")\n\tstd.TestSetOrigCaller(test2)\n\tusers.Register(admin, \"test222\", \"my profile 2\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_1_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"gno.land/r/demo/users\"\n)\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_2_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_3_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_4_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\ttest2 := testutils.TestAddress(\"test2\")\n\tusers.Invite(test1.String())\n\t// switch to test2 (not test1)\n\tstd.TestSetOrigCaller(test2)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid invitation\n"
                },
                {
                  "Name": "z_5_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\tprintln(users.Render(\"\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"gnouser\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"satoshi\"))\n\tprintln(\"========================================\")\n\tprintln(users.Render(\"badname\"))\n}\n\n// Output:\n// * [gnouser](/r/demo/users:gnouser)\n//  * [satoshi](/r/demo/users:satoshi)\n//\n// ========================================\n// ## user gnouser\n//\n//  * address = g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n//  * 9 invites\n//\n// my profile\n//\n// ========================================\n// ## user satoshi\n//\n//  * address = g1w3jhxap3ta047h6lta047h6lta047h6l4mfnm7\n//  * 0 invites\n//  * invited by g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n//\n// my other profile\n//\n// ========================================\n// unknown username badname\n"
                },
                {
                  "Name": "z_6_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller()\n\t// as admin, grant invites to unregistered user.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid user g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\n"
                },
                {
                  "Name": "z_7_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and satoshi.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test1.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_7b_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and satoshi.\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test1.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                },
                {
                  "Name": "z_8_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// as admin, grant invites to gnouser\n\tstd.TestSetOrigCaller(admin)\n\tusers.GrantInvites(caller.String() + \":1\")\n\t// switch back to caller\n\tstd.TestSetOrigCaller(caller)\n\t// invite another addr\n\ttest1 := testutils.TestAddress(\"test1\")\n\tusers.Invite(test1.String())\n\t// switch to test1\n\tstd.TestSetOrigCaller(test1)\n\tstd.TestSetOrigSend(std.Coins{{\"dontcare\", 1}}, nil)\n\tusers.Register(caller, \"satoshi\", \"my other profile\")\n\t// as admin, grant invites to gnouser(again) and nonexistent user.\n\tstd.TestSetOrigCaller(admin)\n\ttest2 := testutils.TestAddress(\"test2\")\n\tusers.GrantInvites(caller.String() + \":1\\n\" + test2.String() + \":1\")\n\tprintln(\"done\")\n}\n\n// Error:\n// invalid user g1w3jhxapjta047h6lta047h6lta047h6laqcyu4\n"
                },
                {
                  "Name": "z_9_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tcaller := std.GetOrigCaller() // main\n\ttest2 := testutils.TestAddress(\"test2\")\n\t// as admin, invite gnouser and test2\n\tstd.TestSetOrigCaller(admin)\n\tusers.Invite(caller.String() + \"\\n\" + test2.String())\n\t// register as caller\n\tstd.TestSetOrigCaller(caller)\n\tusers.Register(admin, \"gnouser\", \"my profile\")\n\t// register as test2\n\tstd.TestSetOrigCaller(test2)\n\tusers.Register(admin, \"test222\", \"my profile 2\")\n\tprintln(\"done\")\n}\n\n// Output:\n// done\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "foo20",
              "Path": "gno.land/r/demo/foo20",
              "Files": [
                {
                  "Name": "foo20.gno",
                  "Body": "package foo20\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tfoo   *grc20.AdminToken\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // TODO: helper to change admin\n)\n\nfunc init() {\n\tfoo = grc20.NewAdminToken(\"Foo\", \"FOO\", 4)\n\tfoo.Mint(admin, 1000000*10000)                                    // @administrator (1M)\n\tfoo.Mint(\"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\", 10000*10000) // @manfred (10k)\n}\n\n// method proxies as public functions.\n//\n\n// getters.\n\nfunc TotalSupply() uint64 {\n\treturn foo.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := foo.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := foo.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\n// setters.\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Transfer(caller, to.Resolve(), amount)\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.Approve(caller, spender.Resolve(), amount)\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tfoo.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n}\n\n// faucet.\n\nfunc Faucet() {\n\t// FIXME: add limits?\n\t// FIXME: add payment in gnot?\n\tcaller := std.GetOrigCaller()\n\tfoo.Mint(caller, 1000*10000) // 1k\n}\n\n// administration.\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Mint(address.Resolve(), amount)\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\tfoo.Burn(address.Resolve(), amount)\n}\n\n// render.\n//\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn foo.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := foo.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"
                },
                {
                  "Name": "foo20_test.gno",
                  "Body": "package foo20\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/r/demo/users\"\n)\n\nfunc TestReadOnlyPublicMethods(t *testing.T) {\n\tadmin := users.AddressOrName(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\tmanfred := users.AddressOrName(\"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\")\n\tunknown := std.Address(\"g1u0000000000000000000000000000000000000\")\n\n\ttype test struct {\n\t\tname    string\n\t\tbalance uint64\n\t\tfn      func() uint64\n\t}\n\n\t// check balances #1.\n\t{\n\t\ttests := []test{\n\t\t\t{\"TotalSupply\", 10100000000, func() uint64 { return TotalSupply() }},\n\t\t\t{\"BalanceOf(admin)\", 10000000000, func() uint64 { return BalanceOf(admin) }},\n\t\t\t{\"BalanceOf(manfred)\", 100000000, func() uint64 { return BalanceOf(manfred) }},\n\t\t\t{\"Allowance(admin, manfred)\", 0, func() uint64 { return Allowance(admin, manfred) }},\n\t\t\t{\"BalanceOf(unknown)\", 0, func() uint64 { return BalanceOf(users.AddressOrName(unknown)) }},\n\t\t}\n\t\tfor _, tc := range tests {\n\t\t\tif tc.fn() != tc.balance {\n\t\t\t\tt.Errorf(\"%s: have: %d want: %d\", tc.name, tc.fn(), tc.balance)\n\t\t\t}\n\t\t}\n\t}\n\n\t// unknown uses the faucet.\n\tstd.TestSetOrigCaller(unknown)\n\tFaucet()\n\n\t// check balances #2.\n\t{\n\t\ttests := []test{\n\t\t\t{\"TotalSupply\", 10110000000, func() uint64 { return TotalSupply() }},\n\t\t\t{\"BalanceOf(admin)\", 10000000000, func() uint64 { return BalanceOf(admin) }},\n\t\t\t{\"BalanceOf(manfred)\", 100000000, func() uint64 { return BalanceOf(manfred) }},\n\t\t\t{\"Allowance(admin, manfred)\", 0, func() uint64 { return Allowance(admin, manfred) }},\n\t\t\t{\"BalanceOf(unknown)\", 10000000, func() uint64 { return BalanceOf(users.AddressOrName(unknown)) }},\n\t\t}\n\t\tfor _, tc := range tests {\n\t\t\tif tc.fn() != tc.balance {\n\t\t\t\tt.Errorf(\"%s: have: %d want: %d\", tc.name, tc.fn(), tc.balance)\n\t\t\t}\n\t\t}\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "foo1155",
              "Path": "gno.land/r/demo/foo1155",
              "Files": [
                {
                  "Name": "foo1155.gno",
                  "Body": "package foo1155\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/grc/grc1155\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tdummyURI             = \"ipfs://xyz\"\n\tadmin    std.Address = \"g10x5phu0k6p64cwrhfpsc8tk43st9kug6wft530\"\n\tfoo                  = grc1155.NewBasicGRC1155Token(dummyURI)\n)\n\nfunc init() {\n\tmintGRC1155Token(admin) // @administrator (10)\n}\n\nfunc mintGRC1155Token(owner std.Address) {\n\tfor i := 1; i \u003c= 10; i++ {\n\t\ttid := grc1155.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tfoo.SafeMint(owner, tid, 100)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName, tid grc1155.TokenID) uint64 {\n\tbalance, err := foo.BalanceOf(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balance\n}\n\nfunc BalanceOfBatch(users []users.AddressOrName, batch []grc1155.TokenID) []uint64 {\n\tvar usersResolved []std.Address\n\n\tfor i := 0; i \u003c len(users); i++ {\n\t\tusersResolved[i] = users[i].Resolve()\n\t}\n\tbalanceBatch, err := foo.BalanceOfBatch(usersResolved, batch)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\treturn balanceBatch\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn foo.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\n// Setters\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := foo.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc1155.TokenID, amount uint64) {\n\terr := foo.SafeTransferFrom(from.Resolve(), to.Resolve(), tid, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc BatchTransferFrom(from, to users.AddressOrName, batch []grc1155.TokenID, amounts []uint64) {\n\terr := foo.SafeBatchTransferFrom(from.Resolve(), to.Resolve(), batch, amounts)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc1155.TokenID, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := foo.SafeMint(to.Resolve(), tid, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc MintBatch(to users.AddressOrName, batch []grc1155.TokenID, amounts []uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := foo.SafeBatchMint(to.Resolve(), batch, amounts)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(from users.AddressOrName, tid grc1155.TokenID, amount uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := foo.Burn(from.Resolve(), tid, amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc BurnBatch(from users.AddressOrName, batch []grc1155.TokenID, amounts []uint64) {\n\tcaller := std.GetOrigCaller()\n\tassertIsAdmin(caller)\n\terr := foo.BatchBurn(from.Resolve(), batch, amounts)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn foo.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"
                },
                {
                  "Name": "foo1155_test.gno",
                  "Body": "package foo1155\n\nimport (\n\t\"testing\"\n\n\t\"gno.land/p/demo/grc/grc1155\"\n\t\"gno.land/r/demo/users\"\n)\n\nfunc TestFoo721(t *testing.T) {\n\tadmin := users.AddressOrName(\"g10x5phu0k6p64cwrhfpsc8tk43st9kug6wft530\")\n\tbob := users.AddressOrName(\"g1ze6et22ces5atv79y4xh38s4kuraey4y2fr6tw\")\n\ttid1 := grc1155.TokenID(\"1\")\n\ttid2 := grc1155.TokenID(\"2\")\n\n\tfor i, tc := range []struct {\n\t\tname     string\n\t\texpected interface{}\n\t\tfn       func() interface{}\n\t}{\n\t\t{\"BalanceOf(admin, tid1)\", 100, func() interface{} { return BalanceOf(admin, tid1) }},\n\t\t{\"BalanceOf(bob, tid1)\", 0, func() interface{} { return BalanceOf(bob, tid1) }},\n\t\t{\"IsApprovedForAll(admin, bob)\", false, func() interface{} { return IsApprovedForAll(admin, bob) }},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tgot := tc.fn()\n\t\t\tif tc.expected != got {\n\t\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, got)\n\t\t\t}\n\t\t})\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "boards",
              "Path": "gno.land/r/demo/boards",
              "Files": [
                {
                  "Name": "README.md",
                  "Body": "This is a demo of Gno smart contract programming.  This document was\nconstructed by Gno onto a smart contract hosted on the data Realm\nname [\"gno.land/r/boards\"](https://gno.land/r/boards/)\n([github](https://github.com/gnolang/gno/tree/master/examples/gno.land/r/boards)).\n\n\n\n## Build `gnokey`, create your account, and interact with Gno.\n\nNOTE: Where you see `--remote gno.land:36657` here, that flag can be replaced\nwith `--remote localhost:26657` for local testnets.\n\n### Build `gnokey`.\n\n```bash\ngit clone git@github.com:gnolang/gno.git\ncd ./gno\nmake\n```\n\n### Generate a seed/mnemonic code.\n\n```bash\n./build/gnokey generate\n```\n\nNOTE: You can generate 24 words with any good bip39 generator.\n\n### Create a new account using your mnemonic.\n\n```bash\n./build/gnokey add --recover KEYNAME\n```\n\nNOTE: `KEYNAME` is your key identifier, and should be changed.\n\n### Verify that you can see your account locally.\n\n```bash\n./build/gnokey list\n```\n\n## Interact with the blockchain:\n\n### Get your current balance, account number, and sequence number.\n\n```bash\n./build/gnokey query auth/accounts/ACCOUNT_ADDR --remote gno.land:36657\n```\n\nNOTE: you can retrieve your `ACCOUNT_ADDR` with `./build/gnokey list`.\n\n### Acquire testnet tokens using the official faucet.\n\nGo to https://gno.land/faucet\n\n### Create a board with a smart contract call.\n\nNOTE: `BOARDNAME` will be the slug of the board, and should be changed.\n\n```bash\n./build/gnokey maketx call -pkgpath \"gno.land/r/boards\" -func \"CreateBoard\" -args \"BOARDNAME\" -gas-fee \"1000000ugnot\" -gas-wanted \"2000000\" -broadcast -chainid testchain -remote gno.land:36657 KEYNAME\n```\n\nInteractive documentation: https://gno.land/r/boards?help\u0026__func=CreateBoard\n\nNext, query for the permanent board ID by querying (you need this to create a new post):\n\n```bash\n./build/gnokey query \"vm/qeval\" -data \"gno.land/r/boards\nGetBoardIDFromName(\\\"BOARDNAME\\\")\" -remote gno.land:36657\n```\n\n### Create a post of a board with a smart contract call.\n\nNOTE: If a board was created successfully, your SEQUENCE_NUMBER would have increased.\n\n```bash\n./build/gnokey maketx call -pkgpath \"gno.land/r/boards\" -func \"CreateThread\" -args BOARD_ID -args \"Hello gno.land\" -args\\#file \"./examples/gno.land/r/boards/example_post.md\" -gas-fee 1000000ugnot -gas-wanted 2000000 -broadcast -chainid testchain -remote gno.land:36657 KEYNAME\n```\n\nInteractive documentation: https://gno.land/r/boards?help\u0026__func=CreateThread\n\n### Create a comment to a post.\n\n```bash\n./build/gnokey maketx call -pkgpath \"gno.land/r/boards\" -func \"CreateReply\" -args \"BOARD_ID\" -args \"1\" -args \"1\" -args \"Nice to meet you too.\" -gas-fee 1000000ugnot -gas-wanted 2000000 -broadcast -chainid testchain -remote gno.land:36657 KEYNAME\n```\n\nInteractive documentation: https://gno.land/r/boards?help\u0026__func=CreateReply\n\n```bash\n./build/gnokey query \"vm/qrender\" -data \"gno.land/r/boards\nBOARDNAME/1\" -remote gno.land:36657\n```\n\n### Render page with optional path expression.\n\nThe contents of `https://gno.land/r/boards:` and `https://gno.land/r/boards:gnolang` are rendered by calling\nthe `Render(path string)` function like so:\n\n```bash\n./build/gnokey query \"vm/qrender\" -data \"gno.land/r/boards\ngnolang\"\n```\n\n## Starting a local `gnoland` node:\n\n### Add test account.\n\n```bash\n./build/gnokey add -recover test1\n```\n\nUse this mneonic:\n\u003e source bonus chronic canvas draft south burst lottery vacant surface solve popular case indicate oppose farm nothing bullet exhibit title speed wink action roast\n\n### Start `gnoland` node.\n\n```bash\n./build/gnoland\n```\n\nNOTE: This can be reset with `make reset`\n\n### Publish the \"gno.land/p/demo/avl\" package.\n\n```bash\n./build/gnokey maketx addpkg -pkgpath \"gno.land/p/demo/avl\" -pkgdir \"examples/gno.land/p/demo/avl\" -deposit 100000000ugnot -gas-fee 1000000ugnot -gas-wanted 2000000 -broadcast -chainid dev -remote localhost:26657 test1\n```\n\n### Publish the \"gno.land/r/boards\" realm package.\n\n```bash\n./build/gnokey maketx addpkg -pkgpath \"gno.land/r/boards\" -pkgdir \"examples/gno.land/r/boards\" -deposit 100000000ugnot -gas-fee 1000000ugnot -gas-wanted 300000000 -broadcast -chainid dev -remote localhost:26657 test1\n```\n"
                },
                {
                  "Name": "board.gno",
                  "Body": "package boards\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Board\n\ntype BoardID uint64\n\nfunc (bid BoardID) String() string {\n\treturn strconv.Itoa(int(bid))\n}\n\ntype Board struct {\n\tid        BoardID // only set for public boards.\n\turl       string\n\tname      string\n\tcreator   std.Address\n\tthreads   avl.Tree // Post.id -\u003e *Post\n\tpostsCtr  uint64   // increments Post.id\n\tcreatedAt time.Time\n\tdeleted   avl.Tree // TODO reserved for fast-delete.\n}\n\nfunc newBoard(id BoardID, url string, name string, creator std.Address) *Board {\n\tif !reName.MatchString(name) {\n\t\tpanic(\"invalid name: \" + name)\n\t}\n\texists := gBoardsByName.Has(name)\n\tif exists {\n\t\tpanic(\"board already exists\")\n\t}\n\treturn \u0026Board{\n\t\tid:        id,\n\t\turl:       url,\n\t\tname:      name,\n\t\tcreator:   creator,\n\t\tthreads:   avl.Tree{},\n\t\tcreatedAt: time.Now(),\n\t\tdeleted:   avl.Tree{},\n\t}\n}\n\n/* TODO support this once we figure out how to ensure URL correctness.\n// A private board is not tracked by gBoards*,\n// but must be persisted by the caller's realm.\n// Private boards have 0 id and does not ping\n// back the remote board on reposts.\nfunc NewPrivateBoard(url string, name string, creator std.Address) *Board {\n\treturn newBoard(0, url, name, creator)\n}\n*/\n\nfunc (board *Board) IsPrivate() bool {\n\treturn board.id == 0\n}\n\nfunc (board *Board) GetThread(pid PostID) *Post {\n\tpidkey := postIDKey(pid)\n\tpostI, exists := board.threads.Get(pidkey)\n\tif !exists {\n\t\treturn nil\n\t}\n\treturn postI.(*Post)\n}\n\nfunc (board *Board) AddThread(creator std.Address, title string, body string) *Post {\n\tpid := board.incGetPostID()\n\tpidkey := postIDKey(pid)\n\tthread := newPost(board, pid, creator, title, body, pid, 0, 0)\n\tboard.threads.Set(pidkey, thread)\n\treturn thread\n}\n\n// NOTE: this can be potentially very expensive for threads with many replies.\n// TODO: implement optional fast-delete where thread is simply moved.\nfunc (board *Board) DeleteThread(pid PostID) {\n\tpidkey := postIDKey(pid)\n\t_, removed := board.threads.Remove(pidkey)\n\tif !removed {\n\t\tpanic(\"thread does not exist with id \" + pid.String())\n\t}\n}\n\nfunc (board *Board) HasPermission(addr std.Address, perm Permission) bool {\n\tif board.creator == addr {\n\t\tswitch perm {\n\t\tcase EditPermission:\n\t\t\treturn true\n\t\tcase DeletePermission:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\treturn false\n}\n\n// Renders the board for display suitable as plaintext in\n// console.  This is suitable for demonstration or tests,\n// but not for prod.\nfunc (board *Board) RenderBoard() string {\n\tstr := \"\"\n\tstr += \"\\\\[[post](\" + board.GetPostFormURL() + \")]\\n\\n\"\n\tif board.threads.Size() \u003e 0 {\n\t\tboard.threads.Iterate(\"\", \"\", func(n *avl.Node) bool {\n\t\t\tif str != \"\" {\n\t\t\t\tstr += \"----------------------------------------\\n\"\n\t\t\t}\n\t\t\tstr += n.Value().(*Post).RenderSummary() + \"\\n\"\n\t\t\treturn false\n\t\t})\n\t}\n\treturn str\n}\n\nfunc (board *Board) incGetPostID() PostID {\n\tboard.postsCtr++\n\treturn PostID(board.postsCtr)\n}\n\nfunc (board *Board) GetURLFromThreadAndReplyID(threadID, replyID PostID) string {\n\tif replyID == 0 {\n\t\treturn board.url + \"/\" + threadID.String()\n\t} else {\n\t\treturn board.url + \"/\" + threadID.String() + \"/\" + replyID.String()\n\t}\n}\n\nfunc (board *Board) GetPostFormURL() string {\n\treturn \"/r/demo/boards?help\u0026__func=CreateThread\" +\n\t\t\"\u0026bid=\" + board.id.String() +\n\t\t\"\u0026body.type=textarea\"\n}\n"
                },
                {
                  "Name": "boards.gno",
                  "Body": "package boards\n\nimport (\n\t\"regexp\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Realm (package) state\n\nvar (\n\tgBoards         avl.Tree    // id -\u003e *Board\n\tgBoardsCtr      int         // increments Board.id\n\tgBoardsByName   avl.Tree    // name -\u003e *Board\n\tgDefaultAnonFee = 100000000 // minimum fee required if anonymous\n)\n\n//----------------------------------------\n// Constants\n\nvar reName = regexp.MustCompile(`^[a-z]+[_a-z0-9]{2,29}$`)\n"
                },
                {
                  "Name": "example_post.md",
                  "Body": "Hey all! \n\nThis is my first post in this land!"
                },
                {
                  "Name": "misc.gno",
                  "Body": "package boards\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/r/demo/users\"\n)\n\n//----------------------------------------\n// private utility methods\n// XXX ensure these cannot be called from public.\n\nfunc getBoard(bid BoardID) *Board {\n\tbidkey := boardIDKey(bid)\n\tboard_, exists := gBoards.Get(bidkey)\n\tif !exists {\n\t\treturn nil\n\t}\n\tboard := board_.(*Board)\n\treturn board\n}\n\nfunc incGetBoardID() BoardID {\n\tgBoardsCtr++\n\treturn BoardID(gBoardsCtr)\n}\n\nfunc padLeft(str string, length int) string {\n\tif len(str) \u003e= length {\n\t\treturn str\n\t} else {\n\t\treturn strings.Repeat(\" \", length-len(str)) + str\n\t}\n}\n\nfunc padZero(u64 uint64, length int) string {\n\tstr := strconv.Itoa(int(u64))\n\tif len(str) \u003e= length {\n\t\treturn str\n\t} else {\n\t\treturn strings.Repeat(\"0\", length-len(str)) + str\n\t}\n}\n\nfunc boardIDKey(bid BoardID) string {\n\treturn padZero(uint64(bid), 10)\n}\n\nfunc postIDKey(pid PostID) string {\n\treturn padZero(uint64(pid), 10)\n}\n\nfunc indentBody(indent string, body string) string {\n\tlines := strings.Split(body, \"\\n\")\n\tres := \"\"\n\tfor i, line := range lines {\n\t\tif i \u003e 0 {\n\t\t\tres += \"\\n\"\n\t\t}\n\t\tres += indent + line\n\t}\n\treturn res\n}\n\n// NOTE: length must be greater than 3.\nfunc summaryOf(str string, length int) string {\n\tlines := strings.SplitN(str, \"\\n\", 2)\n\tline := lines[0]\n\tif len(line) \u003e length {\n\t\tline = line[:(length-3)] + \"...\"\n\t} else if len(lines) \u003e 1 {\n\t\t// len(line) \u003c= 80\n\t\tline = line + \"...\"\n\t}\n\treturn line\n}\n\nfunc displayAddressMD(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user == nil {\n\t\treturn \"[\" + addr.String() + \"](/r/users:\" + addr.String() + \")\"\n\t} else {\n\t\treturn \"[@\" + user.Name() + \"](/r/users:\" + user.Name() + \")\"\n\t}\n}\n\nfunc usernameOf(addr std.Address) string {\n\tuser := users.GetUserByAddress(addr)\n\tif user == nil {\n\t\treturn \"\"\n\t} else {\n\t\treturn user.Name()\n\t}\n}\n"
                },
                {
                  "Name": "post.gno",
                  "Body": "package boards\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Post\n\n// NOTE: a PostID is relative to the board.\ntype PostID uint64\n\nfunc (pid PostID) String() string {\n\treturn strconv.Itoa(int(pid))\n}\n\n// A Post is a \"thread\" or a \"reply\" depending on context.\n// A thread is a Post of a Board that holds other replies.\ntype Post struct {\n\tboard       *Board\n\tid          PostID\n\tcreator     std.Address\n\ttitle       string // optional\n\tbody        string\n\treplies     avl.Tree // Post.id -\u003e *Post\n\trepliesAll  avl.Tree // Post.id -\u003e *Post (all replies, for top-level posts)\n\treposts     avl.Tree // Board.id -\u003e Post.id\n\tthreadID    PostID   // original Post.id\n\tparentID    PostID   // parent Post.id (if reply or repost)\n\trepostBoard BoardID  // original Board.id (if repost)\n\tcreatedAt   time.Time\n\tupdatedAt   time.Time\n}\n\nfunc newPost(board *Board, id PostID, creator std.Address, title, body string, threadID, parentID PostID, repostBoard BoardID) *Post {\n\treturn \u0026Post{\n\t\tboard:       board,\n\t\tid:          id,\n\t\tcreator:     creator,\n\t\ttitle:       title,\n\t\tbody:        body,\n\t\treplies:     avl.Tree{},\n\t\trepliesAll:  avl.Tree{},\n\t\treposts:     avl.Tree{},\n\t\tthreadID:    threadID,\n\t\tparentID:    parentID,\n\t\trepostBoard: repostBoard,\n\t\tcreatedAt:   time.Now(),\n\t}\n}\n\nfunc (post *Post) IsThread() bool {\n\treturn post.parentID == 0\n}\n\nfunc (post *Post) GetPostID() PostID {\n\treturn post.id\n}\n\nfunc (post *Post) AddReply(creator std.Address, body string) *Post {\n\tboard := post.board\n\tpid := board.incGetPostID()\n\tpidkey := postIDKey(pid)\n\treply := newPost(board, pid, creator, \"\", body, post.threadID, post.id, 0)\n\tpost.replies.Set(pidkey, reply)\n\tif post.threadID == post.id {\n\t\tpost.repliesAll.Set(pidkey, reply)\n\t} else {\n\t\tthread := board.GetThread(post.threadID)\n\t\tthread.repliesAll.Set(pidkey, reply)\n\t}\n\treturn reply\n}\n\nfunc (post *Post) Update(title string, body string) {\n\tpost.title = title\n\tpost.body = body\n\tpost.updatedAt = time.Now()\n}\n\nfunc (thread *Post) GetReply(pid PostID) *Post {\n\tpidkey := postIDKey(pid)\n\treplyI, ok := thread.repliesAll.Get(pidkey)\n\tif !ok {\n\t\treturn nil\n\t} else {\n\t\treturn replyI.(*Post)\n\t}\n}\n\nfunc (post *Post) AddRepostTo(creator std.Address, title, body string, dst *Board) *Post {\n\tif !post.IsThread() {\n\t\tpanic(\"cannot repost non-thread post\")\n\t}\n\tpid := dst.incGetPostID()\n\tpidkey := postIDKey(pid)\n\trepost := newPost(dst, pid, creator, title, body, pid, post.id, post.board.id)\n\tdst.threads.Set(pidkey, repost)\n\tif !dst.IsPrivate() {\n\t\tbidkey := boardIDKey(dst.id)\n\t\tpost.reposts.Set(bidkey, pid)\n\t}\n\treturn repost\n}\n\nfunc (thread *Post) DeletePost(pid PostID) {\n\tif thread.id == pid {\n\t\tpanic(\"should not happen\")\n\t}\n\tpidkey := postIDKey(pid)\n\tpostI, removed := thread.repliesAll.Remove(pidkey)\n\tif !removed {\n\t\tpanic(\"post not found in thread\")\n\t}\n\tpost := postI.(*Post)\n\tif post.parentID != thread.id {\n\t\tparent := thread.GetReply(post.parentID)\n\t\tparent.replies.Remove(pidkey)\n\t} else {\n\t\tthread.replies.Remove(pidkey)\n\t}\n}\n\nfunc (post *Post) HasPermission(addr std.Address, perm Permission) bool {\n\tif post.creator == addr {\n\t\tswitch perm {\n\t\tcase EditPermission:\n\t\t\treturn true\n\t\tcase DeletePermission:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n\t// post notes inherit permissions of the board.\n\treturn post.board.HasPermission(addr, perm)\n}\n\nfunc (post *Post) GetSummary() string {\n\treturn summaryOf(post.body, 80)\n}\n\nfunc (post *Post) GetURL() string {\n\tif post.IsThread() {\n\t\treturn post.board.GetURLFromThreadAndReplyID(\n\t\t\tpost.id, 0)\n\t} else {\n\t\treturn post.board.GetURLFromThreadAndReplyID(\n\t\t\tpost.threadID, post.id)\n\t}\n}\n\nfunc (post *Post) GetReplyFormURL() string {\n\treturn \"/r/demo/boards?help\u0026__func=CreateReply\" +\n\t\t\"\u0026bid=\" + post.board.id.String() +\n\t\t\"\u0026threadid=\" + post.threadID.String() +\n\t\t\"\u0026postid=\" + post.id.String() +\n\t\t\"\u0026body.type=textarea\"\n}\n\nfunc (post *Post) GetDeleteFormURL() string {\n\treturn \"/r/demo/boards?help\u0026__func=DeletePost\" +\n\t\t\"\u0026bid=\" + post.board.id.String() +\n\t\t\"\u0026threadid=\" + post.threadID.String() +\n\t\t\"\u0026postid=\" + post.id.String()\n}\n\nfunc (post *Post) RenderSummary() string {\n\tstr := \"\"\n\tif post.title != \"\" {\n\t\tstr += \"## [\" + summaryOf(post.title, 80) + \"](\" + post.GetURL() + \")\\n\"\n\t\tstr += \"\\n\"\n\t}\n\tstr += post.GetSummary() + \"\\n\"\n\tstr += \"\\\\- \" + displayAddressMD(post.creator) + \",\"\n\tstr += \" [\" + post.createdAt.Format(\"2006-01-02 3:04pm MST\") + \"](\" + post.GetURL() + \")\"\n\tstr += \" \\\\[[x](\" + post.GetDeleteFormURL() + \")]\"\n\tstr += \" (\" + strconv.Itoa(post.replies.Size()) + \" replies)\" + \"\\n\"\n\treturn str\n}\n\nfunc (post *Post) RenderPost(indent string, levels int) string {\n\tif post == nil {\n\t\treturn \"nil post\"\n\t}\n\tstr := \"\"\n\tif post.title != \"\" {\n\t\tstr += indent + \"# \" + post.title + \"\\n\"\n\t\tstr += indent + \"\\n\"\n\t}\n\tstr += indentBody(indent, post.body) + \"\\n\" // TODO: indent body lines.\n\tstr += indent + \"\\\\- \" + displayAddressMD(post.creator) + \", \"\n\tstr += \"[\" + post.createdAt.Format(\"2006-01-02 3:04pm (MST)\") + \"](\" + post.GetURL() + \")\"\n\tstr += \" \\\\[[reply](\" + post.GetReplyFormURL() + \")]\"\n\tstr += \" \\\\[[x](\" + post.GetDeleteFormURL() + \")]\\n\"\n\tif levels \u003e 0 {\n\t\tif post.replies.Size() \u003e 0 {\n\t\t\tpost.replies.Iterate(\"\", \"\", func(n *avl.Node) bool {\n\t\t\t\tstr += indent + \"\\n\"\n\t\t\t\tstr += n.Value().(*Post).RenderPost(indent+\"\u003e \", levels-1)\n\t\t\t\treturn false\n\t\t\t})\n\t\t}\n\t} else {\n\t\tif post.replies.Size() \u003e 0 {\n\t\t\tstr += indent + \"\\n\"\n\t\t\tstr += indent + \"_[see all \" + strconv.Itoa(post.replies.Size()) + \" replies](\" + post.GetURL() + \")_\\n\"\n\t\t}\n\t}\n\treturn str\n}\n\n// render reply and link to context thread\nfunc (post *Post) RenderInner() string {\n\tif post.IsThread() {\n\t\tpanic(\"unexpected thread\")\n\t}\n\tthreadID := post.threadID\n\t// replyID := post.id\n\tparentID := post.parentID\n\tstr := \"\"\n\tstr += \"_[see thread](\" + post.board.GetURLFromThreadAndReplyID(\n\t\tthreadID, 0) + \")_\\n\\n\"\n\tthread := post.board.GetThread(post.threadID)\n\tvar parent *Post\n\tif thread.id == parentID {\n\t\tparent = thread\n\t} else {\n\t\tparent = thread.GetReply(parentID)\n\t}\n\tstr += parent.RenderPost(\"\", 0)\n\tstr += \"\\n\"\n\tstr += post.RenderPost(\"\u003e \", 5)\n\treturn str\n}\n"
                },
                {
                  "Name": "public.gno",
                  "Body": "package boards\n\nimport (\n\t\"std\"\n\t\"strconv\"\n)\n\n//----------------------------------------\n// Public facing functions\n\nfunc GetBoardIDFromName(name string) (BoardID, bool) {\n\tboardI, exists := gBoardsByName.Get(name)\n\tif !exists {\n\t\treturn 0, false\n\t}\n\treturn boardI.(*Board).id, true\n}\n\nfunc CreateBoard(name string) BoardID {\n\tstd.AssertOriginCall()\n\tbid := incGetBoardID()\n\tcaller := std.GetOrigCaller()\n\tif usernameOf(caller) == \"\" {\n\t\tpanic(\"unauthorized\")\n\t}\n\turl := \"/r/demo/boards:\" + name\n\tboard := newBoard(bid, url, name, caller)\n\tbidkey := boardIDKey(bid)\n\tgBoards.Set(bidkey, board)\n\tgBoardsByName.Set(name, board)\n\treturn board.id\n}\n\nfunc checkAnonFee() bool {\n\tsent := std.GetOrigSend()\n\tanonFeeCoin := std.Coin{\"ugnot\", int64(gDefaultAnonFee)}\n\tif len(sent) == 1 \u0026\u0026 sent[0].IsGTE(anonFeeCoin) {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc CreateThread(bid BoardID, title string, body string) PostID {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tif usernameOf(caller) == \"\" {\n\t\tif !checkAnonFee() {\n\t\t\tpanic(\"please register, otherwise minimum fee \" + strconv.Itoa(gDefaultAnonFee) + \" is required if anonymous\")\n\t\t}\n\t}\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\tpanic(\"board not exist\")\n\t}\n\tthread := board.AddThread(caller, title, body)\n\treturn thread.id\n}\n\nfunc CreateReply(bid BoardID, threadid, postid PostID, body string) PostID {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tif usernameOf(caller) == \"\" {\n\t\tif !checkAnonFee() {\n\t\t\tpanic(\"please register, otherwise minimum fee \" + strconv.Itoa(gDefaultAnonFee) + \" is required if anonymous\")\n\t\t}\n\t}\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\tpanic(\"board not exist\")\n\t}\n\tthread := board.GetThread(threadid)\n\tif thread == nil {\n\t\tpanic(\"thread not exist\")\n\t}\n\tif postid == threadid {\n\t\treply := thread.AddReply(caller, body)\n\t\treturn reply.id\n\t} else {\n\t\tpost := thread.GetReply(postid)\n\t\treply := post.AddReply(caller, body)\n\t\treturn reply.id\n\t}\n}\n\n// If dstBoard is private, does not ping back.\n// If board specified by bid is private, panics.\nfunc CreateRepost(bid BoardID, postid PostID, title string, body string, dstBoardID BoardID) PostID {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tif usernameOf(caller) == \"\" {\n\t\t// TODO: allow with gDefaultAnonFee payment.\n\t\tif !checkAnonFee() {\n\t\t\tpanic(\"please register, otherwise minimum fee \" + strconv.Itoa(gDefaultAnonFee) + \" is required if anonymous\")\n\t\t}\n\t}\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\tpanic(\"src board not exist\")\n\t}\n\tif board.IsPrivate() {\n\t\tpanic(\"cannot repost from a private board\")\n\t}\n\tdst := getBoard(dstBoardID)\n\tif dst == nil {\n\t\tpanic(\"dst board not exist\")\n\t}\n\tthread := board.GetThread(postid)\n\tif thread == nil {\n\t\tpanic(\"thread not exist\")\n\t}\n\trepost := thread.AddRepostTo(caller, title, body, dst)\n\treturn repost.id\n}\n\nfunc DeletePost(bid BoardID, threadid, postid PostID, reason string) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\tpanic(\"board not exist\")\n\t}\n\tthread := board.GetThread(threadid)\n\tif thread == nil {\n\t\tpanic(\"thread not exist\")\n\t}\n\tif postid == threadid {\n\t\t// delete thread\n\t\tif !thread.HasPermission(caller, DeletePermission) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t\tboard.DeleteThread(threadid)\n\t} else {\n\t\t// delete thread's post\n\t\tpost := thread.GetReply(postid)\n\t\tif post == nil {\n\t\t\tpanic(\"post not exist\")\n\t\t}\n\t\tif !post.HasPermission(caller, DeletePermission) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t\tthread.DeletePost(postid)\n\t}\n}\n\nfunc EditPost(bid BoardID, threadid, postid PostID, title, body string) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\tpanic(\"board not exist\")\n\t}\n\tthread := board.GetThread(threadid)\n\tif thread == nil {\n\t\tpanic(\"thread not exist\")\n\t}\n\tif postid == threadid {\n\t\t// edit thread\n\t\tif !thread.HasPermission(caller, EditPermission) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t\tthread.Update(title, body)\n\t} else {\n\t\t// edit thread's post\n\t\tpost := thread.GetReply(postid)\n\t\tif post == nil {\n\t\t\tpanic(\"post not exist\")\n\t\t}\n\t\tif !post.HasPermission(caller, EditPermission) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t\tpost.Update(title, body)\n\t}\n}\n"
                },
                {
                  "Name": "render.gno",
                  "Body": "package boards\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n//----------------------------------------\n// Render functions\n\nfunc RenderBoard(bid BoardID) string {\n\tboard := getBoard(bid)\n\tif board == nil {\n\t\treturn \"missing board\"\n\t}\n\treturn board.RenderBoard()\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\tstr := \"These are all the boards of this realm:\\n\\n\"\n\t\tgBoards.Iterate(\"\", \"\", func(n *avl.Node) bool {\n\t\t\tboard := n.Value().(*Board)\n\t\t\tstr += \" * [\" + board.url + \"](\" + board.url + \")\\n\"\n\t\t\treturn false\n\t\t})\n\t\treturn str\n\t}\n\tparts := strings.Split(path, \"/\")\n\tif len(parts) == 1 {\n\t\t// /r/demo/boards:BOARD_NAME\n\t\tname := parts[0]\n\t\tboardI, exists := gBoardsByName.Get(name)\n\t\tif !exists {\n\t\t\treturn \"board does not exist: \" + name\n\t\t}\n\t\treturn boardI.(*Board).RenderBoard()\n\t} else if len(parts) == 2 {\n\t\t// /r/demo/boards:BOARD_NAME/THREAD_ID\n\t\tname := parts[0]\n\t\tboardI, exists := gBoardsByName.Get(name)\n\t\tif !exists {\n\t\t\treturn \"board does not exist: \" + name\n\t\t}\n\t\tpid, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn \"invalid thread id: \" + parts[1]\n\t\t}\n\t\tboard := boardI.(*Board)\n\t\tthread := board.GetThread(PostID(pid))\n\t\tif thread == nil {\n\t\t\treturn \"thread does not exist with id: \" + parts[1]\n\t\t}\n\t\treturn thread.RenderPost(\"\", 5)\n\t} else if len(parts) == 3 {\n\t\t// /r/demo/boards:BOARD_NAME/THREAD_ID/REPLY_ID\n\t\tname := parts[0]\n\t\tboardI, exists := gBoardsByName.Get(name)\n\t\tif !exists {\n\t\t\treturn \"board does not exist: \" + name\n\t\t}\n\t\tpid, err := strconv.Atoi(parts[1])\n\t\tif err != nil {\n\t\t\treturn \"invalid thread id: \" + parts[1]\n\t\t}\n\t\tboard := boardI.(*Board)\n\t\tthread := board.GetThread(PostID(pid))\n\t\tif thread == nil {\n\t\t\treturn \"thread does not exist with id: \" + parts[1]\n\t\t}\n\t\trid, err := strconv.Atoi(parts[2])\n\t\tif err != nil {\n\t\t\treturn \"invalid reply id: \" + parts[2]\n\t\t}\n\t\treply := thread.GetReply(PostID(rid))\n\t\tif reply == nil {\n\t\t\treturn \"reply does not exist with id: \" + parts[2]\n\t\t}\n\t\treturn reply.RenderInner()\n\t} else {\n\t\treturn \"unrecognized path \" + path\n\t}\n}\n"
                },
                {
                  "Name": "role.gno",
                  "Body": "package boards\n\ntype Permission string\n\nconst (\n\tDeletePermission Permission = \"role:delete\"\n\tEditPermission   Permission = \"role:edit\"\n)\n"
                },
                {
                  "Name": "z_0_a_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\nimport (\n\t\"gno.land/r/demo/boards\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid := boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\tboards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Error:\n// unauthorized\n"
                },
                {
                  "Name": "z_0_b_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 199000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tbid = boards.CreateBoard(\"test_board\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Error:\n// payment must not be less than 200000000\n"
                },
                {
                  "Name": "z_0_c_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tboards.CreateThread(1, \"First Post (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Error:\n// board not exist\n"
                },
                {
                  "Name": "z_0_d_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateReply(bid, 0, 0, \"Reply of the second post\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Error:\n// thread not exist\n"
                },
                {
                  "Name": "z_0_e_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\tboards.CreateReply(bid, 0, 0, \"Reply of the second post\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Error:\n// board not exist\n"
                },
                {
                  "Name": "z_0_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar bid boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid := boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\tboards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Output:\n// \\[[post](/r/demo/boards?help\u0026__func=CreateThread\u0026bid=1\u0026body.type=textarea)]\n//\n// ----------------------------------------\n// ## [First Post (title)](/r/demo/boards:test_board/1)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm UTC](/r/demo/boards:test_board/1) \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)] (0 replies)\n//\n// ----------------------------------------\n// ## [Second Post (title)](/r/demo/boards:test_board/2)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm UTC](/r/demo/boards:test_board/2) \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)] (1 replies)\n"
                },
                {
                  "Name": "z_10_a_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\t// boardId 2 not exist\n\tboards.DeletePost(2, pid, pid, \"\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// board not exist\n"
                },
                {
                  "Name": "z_10_b_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\t// pid of 2 not exist\n\tboards.DeletePost(bid, 2, 2, \"\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// thread not exist\n"
                },
                {
                  "Name": "z_10_c_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n\trid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n\trid = boards.CreateReply(bid, pid, pid, \"First reply of the First post\\n\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\tboards.DeletePost(bid, pid, rid, \"\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// \u003e First reply of the First post\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=2)]\n//\n// ----------------------------------------------------\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n"
                },
                {
                  "Name": "z_10_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\tboards.DeletePost(bid, pid, pid, \"\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// ----------------------------------------------------\n// thread does not exist with id: 1\n"
                },
                {
                  "Name": "z_11_a_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\t// board 2 not exist\n\tboards.EditPost(2, pid, pid, \"Edited: First Post in (title)\", \"Edited: Body of the first post. (body)\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// board not exist\n"
                },
                {
                  "Name": "z_11_b_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\t// thread 2 not exist\n\tboards.EditPost(bid, 2, pid, \"Edited: First Post in (title)\", \"Edited: Body of the first post. (body)\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// thread not exist\n"
                },
                {
                  "Name": "z_11_c_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\t// post 2 not exist\n\tboards.EditPost(bid, pid, 2, \"Edited: First Post in (title)\", \"Edited: Body of the first post. (body)\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// post not exist\n"
                },
                {
                  "Name": "z_11_d_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n\trid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n\trid = boards.CreateReply(bid, pid, pid, \"First reply of the First post\\n\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\tboards.EditPost(bid, pid, rid, \"\", \"Edited: First reply of the First post\\n\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// \u003e First reply of the First post\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=2)]\n//\n// ----------------------------------------------------\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// \u003e Edited: First reply of the First post\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=2)]\n"
                },
                {
                  "Name": "z_11_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tpid = boards.CreateThread(bid, \"First Post in (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n\tboards.EditPost(bid, pid, pid, \"Edited: First Post in (title)\", \"Edited: Body of the first post. (body)\")\n\tprintln(\"----------------------------------------------------\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// ----------------------------------------------------\n// # Edited: First Post in (title)\n//\n// Edited: Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n"
                },
                {
                  "Name": "z_1_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar board *boards.Board\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\t_ = boards.CreateBoard(\"test_board_1\")\n\t_ = boards.CreateBoard(\"test_board_2\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"\"))\n}\n\n// Output:\n// These are all the boards of this realm:\n//\n//  * [/r/demo/boards:test_board_1](/r/demo/boards:test_board_1)\n//  * [/r/demo/boards:test_board_2](/r/demo/boards:test_board_2)\n"
                },
                {
                  "Name": "z_2_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\tboards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # Second Post (title)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)]\n//\n// \u003e Reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n"
                },
                {
                  "Name": "z_3_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n}\n\nfunc main() {\n\trid := boards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n\tprintln(rid)\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// 3\n// # Second Post (title)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)]\n//\n// \u003e Reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n"
                },
                {
                  "Name": "z_4_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\trid := boards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n\tprintln(rid)\n}\n\nfunc main() {\n\trid2 := boards.CreateReply(bid, pid, pid, \"Second reply of the second post\")\n\tprintln(rid2)\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// 3\n// 4\n// # Second Post (title)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)]\n//\n// \u003e Reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n//\n// \u003e Second reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/4) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=4\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=4)]\n\n// Realm:\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/boards\"]\n// u[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:101]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000003\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/r/demo/boards.Post\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/r/demo/boards.Post\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Escaped\": true,\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:102\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:101\",\n//         \"ModTime\": \"109\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:109\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:110]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000004\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/r/demo/boards.Post\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/r/demo/boards.Post\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Escaped\": true,\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:110\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:109\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:109]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000004\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"b58581159917d8d7ad0992009d7184fc8ca00fcc\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:101\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"fb593e86d35aaf607e0d21e6bd4f84519c44585f\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:110\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:109\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:96\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:112]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:112\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:113]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:113\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:114]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:114\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:115]={\n//     \"Fields\": [\n//         {\n//             \"N\": \"AAAAgJSeXbo=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"65536\"\n//             }\n//         },\n//         {\n//             \"N\": \"AbSNdvQQIhE=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"1024\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"time.Location\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": {\n//                     \"@type\": \"/gno.RefValue\",\n//                     \"Escaped\": true,\n//                     \"ObjectID\": \"336074805fc853987abe6f7fe3ad97a6a6f3077a:2\"\n//                 },\n//                 \"Index\": \"188\",\n//                 \"TV\": null\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:115\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:116]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"65536\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"1024\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"time.Location\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:116\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/r/demo/boards.Board\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/r/demo/boards.Board\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Escaped\": true,\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:81\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"N\": \"BAAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/r/demo/boards.PostID\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"std.Address\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"Second reply of the second post\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/p/demo/avl.Tree\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"130542396d7549d1d516a3ef4a63bb44ef3da06f\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:112\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/p/demo/avl.Tree\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"80acd8746478317194b8546170335c796a4dfb3f\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:113\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/p/demo/avl.Tree\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"c1a8f769f3b9d52dd38ac4759116edaca287636f\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:114\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/r/demo/boards.PostID\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/r/demo/boards.PostID\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/r/demo/boards.BoardID\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"time.Time\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"8164abed5231309c88497013f7da72a1b5d427b0\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:115\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"time.Time\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"c3a60b602b564d07677a212372f4ac1cae4270fd\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:116\"\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"0\",\n//         \"RefCount\": \"2\"\n//     }\n// }\n// u[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:108]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000003\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/r/demo/boards.Post\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/r/demo/boards.Post\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Escaped\": true,\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:102\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:108\",\n//         \"ModTime\": \"117\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:117\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:118]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000004\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/r/demo/boards.Post\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/r/demo/boards.Post\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Escaped\": true,\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:111\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:118\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:117\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// c[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:117]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"0000000004\"\n//             }\n//         },\n//         {},\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"64\"\n//             }\n//         },\n//         {\n//             \"N\": \"AgAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"32\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"6a86bc7763703c8f2b9d286368921159d6db121c\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:108\"\n//                     }\n//                 }\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"52faa8a2dfefd4b6b6249eff2f9c123ad455e81d\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:118\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:117\",\n//         \"ModTime\": \"0\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:97\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:81]={\n//     \"Fields\": [\n//         {\n//             \"N\": \"AQAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/r/demo/boards.BoardID\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"/r/demo/boards:test_board\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"16\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"test_board\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"std.Address\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.StringValue\",\n//                 \"value\": \"g1wymu47drhr0kuq2098m792lytgtj2nyx77yrsm\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/p/demo/avl.Tree\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"5b4b593f1d4b37cb99166247ea28174f91087fdd\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:82\"\n//             }\n//         },\n//         {\n//             \"N\": \"BAAAAAAAAAA=\",\n//             \"T\": {\n//                 \"@type\": \"/gno.PrimitiveType\",\n//                 \"value\": \"65536\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"time.Time\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"7e9fd9bb5e90a06c7751585cd80f23aedddde25b\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:83\"\n//             }\n//         },\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.RefType\",\n//                 \"ID\": \"gno.land/p/demo/avl.Tree\"\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.RefValue\",\n//                 \"Hash\": \"edb1857302fa916c562cd077cdf2a3626e29ae2b\",\n//                 \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:84\"\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:81\",\n//         \"IsEscaped\": true,\n//         \"ModTime\": \"108\",\n//         \"RefCount\": \"6\"\n//     }\n// }\n// u[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:96]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"609e7f519c65f94503427a14f973b4b83989cdc8\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:109\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:96\",\n//         \"ModTime\": \"108\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:95\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// u[f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:97]={\n//     \"Fields\": [\n//         {\n//             \"T\": {\n//                 \"@type\": \"/gno.PointerType\",\n//                 \"Elt\": {\n//                     \"@type\": \"/gno.RefType\",\n//                     \"ID\": \"gno.land/p/demo/avl.Node\"\n//                 }\n//             },\n//             \"V\": {\n//                 \"@type\": \"/gno.PointerValue\",\n//                 \"Base\": null,\n//                 \"Index\": \"0\",\n//                 \"TV\": {\n//                     \"T\": {\n//                         \"@type\": \"/gno.RefType\",\n//                         \"ID\": \"gno.land/p/demo/avl.Node\"\n//                     },\n//                     \"V\": {\n//                         \"@type\": \"/gno.RefValue\",\n//                         \"Hash\": \"6760340f5b40e05221dc530940683b0b9a422503\",\n//                         \"ObjectID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:117\"\n//                     }\n//                 }\n//             }\n//         }\n//     ],\n//     \"ObjectInfo\": {\n//         \"ID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:97\",\n//         \"ModTime\": \"108\",\n//         \"OwnerID\": \"f6dbf411da22e67d74cd7ddba6a76cd7e14a4822:95\",\n//         \"RefCount\": \"1\"\n//     }\n// }\n// switchrealm[\"gno.land/r/demo/boards\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/users\"]\n// switchrealm[\"gno.land/r/demo/boards\"]\n// switchrealm[\"gno.land/r/boards_test\"]\n"
                },
                {
                  "Name": "z_5_b_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// create board via registered user\n\tbid := boards.CreateBoard(\"test_board\")\n\n\t// create post via anon user\n\ttest2 := testutils.TestAddress(\"test2\")\n\tstd.TestSetOrigCaller(test2)\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 9000000}}, nil)\n\n\tpid := boards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// please register, otherwise minimum fee 100000000 is required if anonymous\n"
                },
                {
                  "Name": "z_5_c_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// create board via registered user\n\tbid := boards.CreateBoard(\"test_board\")\n\n\t// create post via anon user\n\ttest2 := testutils.TestAddress(\"test2\")\n\tstd.TestSetOrigCaller(test2)\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 101000000}}, nil)\n\n\tpid := boards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tboards.CreateReply(bid, pid, pid, \"Reply of the first post\")\n\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post (title)\n//\n// Body of the first post. (body)\n// \\- [g1w3jhxapjta047h6lta047h6lta047h6laqcyu4](/r/users:g1w3jhxapjta047h6lta047h6lta047h6laqcyu4), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)]\n//\n// \u003e Reply of the first post\n// \u003e \\- [g1w3jhxapjta047h6lta047h6lta047h6laqcyu4](/r/users:g1w3jhxapjta047h6lta047h6lta047h6laqcyu4), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/1/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=1\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=2)]\n"
                },
                {
                  "Name": "z_5_d_filetest.gno",
                  "Body": "package main\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nconst admin = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\nfunc main() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\t// create board via registered user\n\tbid := boards.CreateBoard(\"test_board\")\n\tpid := boards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\n\t// create reply via anon user\n\ttest2 := testutils.TestAddress(\"test2\")\n\tstd.TestSetOrigCaller(test2)\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 9000000}}, nil)\n\tboards.CreateReply(bid, pid, pid, \"Reply of the first post\")\n\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Error:\n// please register, otherwise minimum fee 100000000 is required if anonymous\n"
                },
                {
                  "Name": "z_5_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\trid := boards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\trid2 := boards.CreateReply(bid, pid, pid, \"Second reply of the second post\\n\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # Second Post (title)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)]\n//\n// \u003e Reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n//\n// \u003e Second reply of the second post\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/4) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=4\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=4)]\n"
                },
                {
                  "Name": "z_6_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n\trid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\trid = boards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\tboards.CreateReply(bid, pid, pid, \"Second reply of the second post\\n\")\n\tboards.CreateReply(bid, pid, rid, \"First reply of the first reply\\n\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # Second Post (title)\n//\n// Body of the second post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=2\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=2)]\n//\n// \u003e Reply of the second post\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n// \u003e\n// \u003e \u003e First reply of the first reply\n// \u003e \u003e\n// \u003e \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/5) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=5\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=5)]\n//\n// \u003e Second reply of the second post\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/4) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=4\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=4)]\n"
                },
                {
                  "Name": "z_7_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nfunc init() {\n\t// register\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\t// create board and post\n\tbid := boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n}\n\nfunc main() {\n\tprintln(boards.Render(\"test_board\"))\n}\n\n// Output:\n// \\[[post](/r/demo/boards?help\u0026__func=CreateThread\u0026bid=1\u0026body.type=textarea)]\n//\n// ----------------------------------------\n// ## [First Post (title)](/r/demo/boards:test_board/1)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm UTC](/r/demo/boards:test_board/1) \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=1\u0026postid=1)] (0 replies)\n"
                },
                {
                  "Name": "z_8_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 2000000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tbid boards.BoardID\n\tpid boards.PostID\n\trid boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tbid = boards.CreateBoard(\"test_board\")\n\tboards.CreateThread(bid, \"First Post (title)\", \"Body of the first post. (body)\")\n\tpid = boards.CreateThread(bid, \"Second Post (title)\", \"Body of the second post. (body)\")\n\trid = boards.CreateReply(bid, pid, pid, \"Reply of the second post\")\n}\n\nfunc main() {\n\tboards.CreateReply(bid, pid, pid, \"Second reply of the second post\\n\")\n\trid2 := boards.CreateReply(bid, pid, rid, \"First reply of the first reply\\n\")\n\tprintln(boards.Render(\"test_board/\" + strconv.Itoa(int(pid)) + \"/\" + strconv.Itoa(int(rid2))))\n}\n\n// Output:\n// _[see thread](/r/demo/boards:test_board/2)_\n//\n// Reply of the second post\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/3) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=3\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=3)]\n//\n// _[see all 1 replies](/r/demo/boards:test_board/2/3)_\n//\n// \u003e First reply of the first reply\n// \u003e\n// \u003e \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:test_board/2/5) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=1\u0026threadid=2\u0026postid=5\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=1\u0026threadid=2\u0026postid=5)]\n"
                },
                {
                  "Name": "z_9_a_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar dstBoard boards.BoardID\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tdstBoard = boards.CreateBoard(\"dst_board\")\n\n\tboards.CreateRepost(0, 0, \"First Post in (title)\", \"Body of the first post. (body)\", dstBoard)\n}\n\nfunc main() {\n}\n\n// Error:\n// src board not exist\n"
                },
                {
                  "Name": "z_9_b_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tsrcBoard boards.BoardID\n\tpid      boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tsrcBoard = boards.CreateBoard(\"first_board\")\n\tpid = boards.CreateThread(srcBoard, \"First Post in (title)\", \"Body of the first post. (body)\")\n\n\tboards.CreateRepost(srcBoard, pid, \"First Post in (title)\", \"Body of the first post. (body)\", 0)\n}\n\nfunc main() {\n}\n\n// Error:\n// dst board not exist\n"
                },
                {
                  "Name": "z_9_filetest.gno",
                  "Body": "// PKGPATH: gno.land/r/boards_test\npackage boards_test\n\n// SEND: 200000000ugnot\n\nimport (\n\t\"strconv\"\n\n\t\"gno.land/r/demo/boards\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tfirstBoard  boards.BoardID\n\tsecondBoard boards.BoardID\n\tpid         boards.PostID\n)\n\nfunc init() {\n\tusers.Register(\"\", \"gnouser\", \"my profile\")\n\n\tfirstBoard = boards.CreateBoard(\"first_board\")\n\tsecondBoard = boards.CreateBoard(\"second_board\")\n\tpid = boards.CreateThread(firstBoard, \"First Post in (title)\", \"Body of the first post. (body)\")\n\n\tboards.CreateRepost(firstBoard, pid, \"First Post in (title)\", \"Body of the first post. (body)\", secondBoard)\n}\n\nfunc main() {\n\tprintln(boards.Render(\"second_board/\" + strconv.Itoa(int(pid))))\n}\n\n// Output:\n// # First Post in (title)\n//\n// Body of the first post. (body)\n// \\- [@gnouser](/r/users:gnouser), [2009-02-13 11:31pm (UTC)](/r/demo/boards:second_board/1/1) \\[[reply](/r/demo/boards?help\u0026__func=CreateReply\u0026bid=2\u0026threadid=1\u0026postid=1\u0026body.type=textarea)] \\[[x](/r/demo/boards?help\u0026__func=DeletePost\u0026bid=2\u0026threadid=1\u0026postid=1)]\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "banktest",
              "Path": "gno.land/r/demo/banktest",
              "Files": [
                {
                  "Name": "README.md",
                  "Body": "This is a simple test realm contract that demonstrates how to use the banker.\n\nSee [gno.land/r/banktest/banktest.go](/r/banktest/banktest.go) to see the original contract code.\n\nThis article will go through each line to explain how it works.\n\n```go\npackage banktest\n```\n\nThis package is locally named \"banktest\" (could be anything).\n\n```go\nimport (\n    \"std\"\n)\n```\n\nThe \"std\" package is defined by the gno code in stdlibs/std/. \u003c/br\u003e\nSelf explanatory; and you'll see more usage from std later.\n\n```go\ntype activity struct {\n    caller   std.Address\n    sent     std.Coins\n    returned std.Coins\n    time     time.Time\n}\n\nfunc (act *activity) String() string {\n    return act.caller.String() + \" \" +\n        act.sent.String() + \" sent, \" +\n        act.returned.String() + \" returned, at \" +\n        act.time.Format(\"2006-01-02 3:04pm MST\")\n}\n\nvar latest [10]*activity\n```\n\nThis is just maintaining a list of recent activity to this contract.\nNotice that the \"latest\" variable is defined \"globally\" within\nthe context of the realm with path \"gno.land/r/banktest\".\n\nThis means that calls to functions defined within this package\nare encapsulated within this \"data realm\", where the data is\nmutated based on transactions that can potentially cross many\nrealm and non-realm package boundaries (in the call stack).\n\n```go\n// Deposit will take the coins (to the realm's pkgaddr) or return them to user.\nfunc Deposit(returnDenom string, returnAmount int64) string {\n    std.AssertOriginCall()\n    caller := std.GetOrigCaller()\n    send := std.Coins{{returnDenom, returnAmount}}\n```\n\nThis is the beginning of the definition of the contract function named\n\"Deposit\".  `std.AssertOriginCall() asserts that this function was called by a\ngno transactional Message. The caller is the user who signed off on this\ntransactional message. Send is the amount of deposit sent along with this\nmessage.\n\n```go\n    // record activity\n    act := \u0026activity{\n        caller:   caller,\n        sent:     std.GetOrigSend(),\n        returned: send,\n        time:     time.Now(),\n    }\n    for i := len(latest) - 2; i \u003e= 0; i-- {\n        latest[i+1] = latest[i] // shift by +1.\n    }\n    latest[0] = act\n```\n\nUpdating the \"latest\" array for viewing at gno.land/r/banktest: (w/ trailing colon).\n\n```go\n    // return if any.\n    if returnAmount \u003e 0 {\n```\n\nIf the user requested the return of coins...\n\n```go\n        banker := std.GetBanker(std.BankerTypeOrigSend)\n```\n\nuse a std.Banker instance to return any deposited coins to the original sender.\n\n```go\n        pkgaddr := std.GetOrigPkgAddr()\n        // TODO: use std.Coins constructors, this isn't generally safe.\n        banker.SendCoins(pkgaddr, caller, send)\n        return \"returned!\"\n```\n\nNotice that each realm package has an associated Cosmos address.\n\n\nFinally, the results are rendered via an ABCI query call when you visit [/r/banktest:](/r/banktest:).\n\n```go\nfunc Render(path string) string {\n    // get realm coins.\n    banker := std.GetBanker(std.BankerTypeReadonly)\n    coins := banker.GetCoins(std.GetOrigPkgAddr())\n\n    // render\n    res := \"\"\n    res += \"## recent activity\\n\"\n    res += \"\\n\"\n    for _, act := range latest {\n        if act == nil {\n            break\n        }\n        res += \" * \" + act.String() + \"\\n\"\n    }\n    res += \"\\n\"\n    res += \"## total deposits\\n\"\n    res += coins.String()\n    return res\n}\n```\n\nYou can call this contract yourself, by vistiing [/r/banktest](/r/banktest) and the [quickstart guide](/r/boards:gnolang/4).\n"
                },
                {
                  "Name": "banktest.gno",
                  "Body": "package banktest\n\nimport (\n\t\"std\"\n\t\"time\"\n)\n\ntype activity struct {\n\tcaller   std.Address\n\tsent     std.Coins\n\treturned std.Coins\n\ttime     time.Time\n}\n\nfunc (act *activity) String() string {\n\treturn act.caller.String() + \" \" +\n\t\tact.sent.String() + \" sent, \" +\n\t\tact.returned.String() + \" returned, at \" +\n\t\tact.time.Format(\"2006-01-02 3:04pm MST\")\n}\n\nvar latest [10]*activity\n\n// Deposit will take the coins (to the realm's pkgaddr) or return them to user.\nfunc Deposit(returnDenom string, returnAmount int64) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tsend := std.Coins{{returnDenom, returnAmount}}\n\t// record activity\n\tact := \u0026activity{\n\t\tcaller:   caller,\n\t\tsent:     std.GetOrigSend(),\n\t\treturned: send,\n\t\ttime:     time.Now(),\n\t}\n\tfor i := len(latest) - 2; i \u003e= 0; i-- {\n\t\tlatest[i+1] = latest[i] // shift by +1.\n\t}\n\tlatest[0] = act\n\t// return if any.\n\tif returnAmount \u003e 0 {\n\t\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n\t\tpkgaddr := std.GetOrigPkgAddr()\n\t\t// TODO: use std.Coins constructors, this isn't generally safe.\n\t\tbanker.SendCoins(pkgaddr, caller, send)\n\t\treturn \"returned!\"\n\t} else {\n\t\treturn \"thank you!\"\n\t}\n}\n\nfunc Render(path string) string {\n\t// get realm coins.\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\tcoins := banker.GetCoins(std.GetOrigPkgAddr())\n\n\t// render\n\tres := \"\"\n\tres += \"## recent activity\\n\"\n\tres += \"\\n\"\n\tfor _, act := range latest {\n\t\tif act == nil {\n\t\t\tbreak\n\t\t}\n\t\tres += \" * \" + act.String() + \"\\n\"\n\t}\n\tres += \"\\n\"\n\tres += \"## total deposits\\n\"\n\tres += coins.String()\n\treturn res\n}\n"
                },
                {
                  "Name": "z_0_filetest.gno",
                  "Body": "package main\n\n// NOTE: this doesn't do anything, as it sends to \"main\".\n// SEND: 100000000ugnot\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/banktest\"\n)\n\nfunc main() {\n\tbanktestAddr := std.DerivePkgAddr(\"gno.land/r/banktest\")\n\n\t// print main balance before.\n\tmainaddr := std.DerivePkgAddr(\"main\")\n\tstd.TestSetOrigCaller(mainaddr)\n\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\tmainbal := banker.GetCoins(mainaddr)\n\tprintln(\"main before:\", mainbal) // plus OrigSend equals 300.\n\n\t// simulate a Deposit call.\n\tstd.TestSetOrigPkgAddr(banktestAddr)\n\tstd.TestIssueCoins(banktestAddr, std.Coins{{\"ugnot\", 100000000}})\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 100000000}}, nil)\n\tres := banktest.Deposit(\"ugnot\", 100000000)\n\tprintln(\"Deposit():\", res)\n\n\t// print main balance after.\n\tmainbal = banker.GetCoins(mainaddr)\n\tprintln(\"main after:\", mainbal) // still 300.\n\n\t// simulate a Render().\n\tres = banktest.Render(\"\")\n\tprintln(res)\n}\n\n// Output:\n// main before: 200000000ugnot\n// Deposit(): returned!\n// main after: 300000000ugnot\n// ## recent activity\n//\n//  * g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4 100000000ugnot sent, 100000000ugnot returned, at 2009-02-13 11:31pm UTC\n//\n// ## total deposits\n"
                },
                {
                  "Name": "z_1_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/banktest\"\n)\n\nfunc main() {\n\tbanktestAddr := std.DerivePkgAddr(\"gno.land/r/banktest\")\n\n\t// simulate a Deposit call.\n\tstd.TestSetOrigPkgAddr(banktestAddr)\n\tstd.TestIssueCoins(banktestAddr, std.Coins{{\"ugnot\", 100000000}})\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 100000000}}, nil)\n\tres := banktest.Deposit(\"ugnot\", 101000000)\n\tprintln(res)\n}\n\n// Error:\n// cannot send \"101000000ugnot\", limit \"100000000ugnot\" exceeded with \"\" already spent\n"
                },
                {
                  "Name": "z_2_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/r/demo/banktest\"\n)\n\nfunc main() {\n\tbanktestAddr := std.DerivePkgAddr(\"gno.land/r/demo/banktest\")\n\n\t// print main balance before.\n\tmainaddr := std.DerivePkgAddr(\"main\")\n\tstd.TestSetOrigCaller(mainaddr)\n\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\tmainbal := banker.GetCoins(mainaddr)\n\tprintln(\"main before:\", mainbal) // plus OrigSend equals 300.\n\n\t// simulate a Deposit call.\n\tstd.TestSetOrigPkgAddr(banktestAddr)\n\tstd.TestIssueCoins(banktestAddr, std.Coins{{\"ugnot\", 100000000}})\n\tstd.TestSetOrigSend(std.Coins{{\"ugnot\", 100000000}}, nil)\n\tres := banktest.Deposit(\"ugnot\", 55000000)\n\tprintln(\"Deposit():\", res)\n\n\t// print main balance after.\n\tmainbal = banker.GetCoins(mainaddr)\n\tprintln(\"main after:\", mainbal) // now 255.\n\n\t// simulate a Render().\n\tres = banktest.Render(\"\")\n\tprintln(res)\n}\n\n// Output:\n// main before: 200000000ugnot\n// Deposit(): returned!\n// main after: 255000000ugnot\n// ## recent activity\n//\n//  * g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4 100000000ugnot sent, 55000000ugnot returned, at 2009-02-13 11:31pm UTC\n//\n// ## total deposits\n// 45000000ugnot\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "types",
              "Path": "gno.land/r/demo/types",
              "Files": [
                {
                  "Name": "types.gno",
                  "Body": "// package to test types behavior in various conditions (TXs, imports).\npackage types\n\nimport (\n\t\"errors\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nvar (\n\tgInt         int      = -42\n\tgUint        uint     = 42\n\tgString      string   = \"a string\"\n\tgStringSlice []string = []string{\"a\", \"string\", \"slice\"}\n\tgError       error    = errors.New(\"an error\")\n\tgIntSlice    []int    = []int{-42, 0, 42}\n\tgUintSlice   []uint   = []uint{0, 42, 84}\n\tgTree        avl.Tree\n\t// gInterface  = interface{}{-42, \"a string\", uint(42)}\n)\n\nfunc init() {\n\tgTree.Set(\"a\", \"content of A\")\n\tgTree.Set(\"b\", \"content of B\")\n}\n\nfunc Noop()                     {}\nfunc RetTimeNow() time.Time     { return time.Now() }\nfunc RetString() string         { return gString }\nfunc RetStringPointer() *string { return \u0026gString }\nfunc RetUint() uint             { return gUint }\nfunc RetInt() int               { return gInt }\nfunc RetUintPointer() *uint     { return \u0026gUint }\nfunc RetIntPointer() *int       { return \u0026gInt }\nfunc RetTree() avl.Tree         { return gTree }\nfunc RetIntSlice() []int        { return gIntSlice }\nfunc RetUintSlice() []uint      { return gUintSlice }\nfunc RetStringSlice() []string  { return gStringSlice }\nfunc RetError() error           { return gError }\nfunc Panic()                    { panic(\"PANIC!\") }\n\n// TODO: floats\n// TODO: typed errors\n// TODO: ret interface\n// TODO: recover\n// TODO: take types as input\n\nfunc Render(path string) string {\n\treturn \"package to test data types.\"\n}\n"
                },
                {
                  "Name": "types_test.gno",
                  "Body": "package types\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "markdown",
              "Path": "gno.land/r/demo/markdown_test",
              "Files": [
                {
                  "Name": "markdown.gno",
                  "Body": "package markdown\n\n// this package can be used to test markdown rendering engines.\n\nfunc Render(path string) string {\n\toutput := `_imported from https://github.com/markedjs/marked/blob/master/docs/demo/quickref.md_\n\nMarkdown Quick Reference\n========================\n\nThis guide is a very brief overview, with examples, of the syntax that [Markdown] supports. It is itself written in Markdown and you can copy the samples over to the left-hand pane for experimentation. It's shown as *text* and not *rendered HTML*.\n\n[Markdown]: http://daringfireball.net/projects/markdown/\n\n\nSimple Text Formatting\n======================\n\nFirst thing is first. You can use *stars* or _underscores_ for italics. **Double stars** and __double underscores__ for bold. ***Three together*** for ___both___.\n\nParagraphs are pretty easy too. Just have a blank line between chunks of text.\n\n\u003e This chunk of text is in a block quote. Its multiple lines will all be\n\u003e indented a bit from the rest of the text.\n\u003e\n\u003e \u003e Multiple levels of block quotes also work.\n\nSometimes you want to include code, such as when you are explaining how ` + \"`\u003ch1\u003e`\" + ` HTML tags work, or maybe you are a programmer and you are discussing ` + \"`someMethod()`\" + `.\n\nIf you want to include code and have new\nlines preserved, indent the line with a tab\nor at least four spaces:\n\n    Extra spaces work here too.\n    This is also called preformatted text and it is useful for showing examples.\n    The text will stay as text, so any *markdown* or \u003cu\u003eHTML\u003c/u\u003e you add will\n    not show up formatted. This way you can show markdown examples in a\n    markdown document.\n\n\u003e     You can also use preformatted text with your blockquotes\n\u003e     as long as you add at least five spaces.\n\n\nHeadings\n========\n\nThere are a couple of ways to make headings. Using three or more equals signs on a line under a heading makes it into an \"h1\" style. Three or more hyphens under a line makes it \"h2\" (slightly smaller). You can also use multiple pound symbols (` + \"`#`\" + `) before and after a heading. Pounds after the title are ignored. Here are some examples:\n\nThis is H1\n==========\n\nThis is H2\n----------\n\n# This is H1\n## This is H2\n### This is H3 with some extra pounds ###\n#### You get the idea ####\n##### I don't need extra pounds at the end\n###### H6 is the max\n\n\nLinks\n=====\n\nLet's link to a few sites. First, let's use the bare URL, like \u003chttps://www.github.com\u003e. Great for text, but ugly for HTML.\nNext is an inline link to [Google](https://www.google.com). A little nicer.\nThis is a reference-style link to [Wikipedia] [1].\nLastly, here's a pretty link to [Yahoo]. The reference-style and pretty links both automatically use the links defined below, but they could be defined *anywhere* in the markdown and are removed from the HTML. The names are also case insensitive, so you can use [YaHoO] and have it link properly.\n\n[1]: https://www.wikipedia.org\n[Yahoo]: https://www.yahoo.com\n\nTitle attributes may be added to links by adding text after a link.\nThis is the [inline link](https://www.bing.com \"Bing\") with a \"Bing\" title.\nYou can also go to [W3C] [2] and maybe visit a [friend].\n\n[2]: https://w3c.org (The W3C puts out specs for web-based things)\n[Friend]: https://facebook.com \"Facebook!\"\n\nEmail addresses in plain text are not linked: test@example.com.\nEmail addresses wrapped in angle brackets are linked: \u003ctest@example.com\u003e.\nThey are also obfuscated so that email harvesting spam robots hopefully won't get them.\n\n\nLists\n=====\n\n* This is a bulleted list\n* Great for shopping lists\n- You can also use hyphens\n+ Or plus symbols\n\nThe above is an \"unordered\" list. Now, on for a bit of order.\n\n1. Numbered lists are also easy\n2. Just start with a number\n3738762. However, the actual number doesn't matter when converted to HTML.\n1. This will still show up as 4.\n\nYou might want a few advanced lists:\n\n- This top-level list is wrapped in paragraph tags\n- This generates an extra space between each top-level item.\n\n- You do it by adding a blank line\n\n- This nested list also has blank lines between the list items.\n\n- How to create nested lists\n  1. Start your regular list\n  2. Indent nested lists with two spaces\n  3. Further nesting means you should indent with two more spaces\n    * This line is indented with four spaces.\n\n- List items can be quite lengthy. You can keep typing and either continue\nthem on the next line with no indentation.\n\n- Alternately, if that looks ugly, you can also\n  indent the next line a bit for a prettier look.\n\n- You can put large blocks of text in your list by just indenting with two spaces.\n\n  This is formatted the same as code, but you can inspect the HTML\n  and find that it's just wrapped in a ` + \"`\u003cp\u003e`\" + ` tag and *won't* be shown\n  as preformatted text.\n\n  You can keep adding more and more paragraphs to a single\n  list item by adding the traditional blank line and then keep\n  on indenting the paragraphs with two spaces.\n\n  You really only need to indent the first line,\nbut that looks ugly.\n\n- Lists support blockquotes\n\n  \u003e Just like this example here. By the way, you can\n  \u003e nest lists inside blockquotes!\n  \u003e - Fantastic!\n\n- Lists support preformatted text\n\n      You just need to indent an additional four spaces.\n\n\nEven More\n=========\n\nHorizontal Rule\n---------------\n\nIf you need a horizontal rule you just need to put at least three hyphens, asterisks, or underscores on a line by themselves. You can also even put spaces between the characters.\n\n---\n****************************\n_ _ _ _ _ _ _\n\nThose three all produced horizontal lines. Keep in mind that three hyphens under any text turns that text into a heading, so add a blank like if you use hyphens.\n\nImages\n------\n\nImages work exactly like links, but they have exclamation points in front. They work with references and titles too.\n\n![Google Logo](https://www.google.com/images/errors/logo_sm.gif) and ![Happy].\n\n[Happy]: https://wpclipart.com/smiley/happy/simple_colors/smiley_face_simple_green_small.png (\"Smiley face\")\n\n\nInline HTML\n-----------\n\nIf markdown is too limiting, you can just insert your own \u003cstrike\u003ecrazy\u003c/strike\u003e HTML. Span-level HTML \u003cu\u003ecan *still* use markdown\u003c/u\u003e. Block level elements must be separated from text by a blank line and must not have any spaces before the opening and closing HTML.\n\n\u003cdiv style='font-family: \"Comic Sans MS\", \"Comic Sans\", cursive;'\u003e\nIt is a pity, but markdown does **not** work in here for most markdown parsers.\n[Marked] handles it pretty well.\n\u003c/div\u003e`\n\treturn output\n}\n"
                },
                {
                  "Name": "markdown_test.gno",
                  "Body": "package markdown\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRender(t *testing.T) {\n\toutput := Render(\"\")\n\tif !strings.Contains(output, \"\\nMarkdown Quick Reference\\n\") {\n\t\tt.Errorf(\"invalid output\")\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "gnoblog",
              "Path": "gno.land/r/gnoland/blog",
              "Files": [
                {
                  "Name": "admin.gno",
                  "Body": "package gnoblog\n\nimport (\n\t\"std\"\n\t\"strings\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\nvar (\n\tadminAddr     std.Address\n\tmoderatorList avl.Tree\n\tcommenterList avl.Tree\n\tinPause       bool\n)\n\nfunc init() {\n\t// adminAddr = std.GetOrigCaller() // FIXME: find a way to use this from the main's genesis.\n\tadminAddr = \"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\"\n}\n\nfunc AdminSetAdminAddr(addr std.Address) {\n\tassertIsAdmin()\n\tadminAddr = addr\n}\n\nfunc AdminSetInPause(state bool) {\n\tinPause = state\n}\n\nfunc AdminAddModerator(addr std.Address) {\n\tassertIsAdmin()\n\tmoderatorList.Set(addr.String(), true)\n}\n\nfunc AdminRemoveModerator(addr std.Address) {\n\tassertIsAdmin()\n\tmoderatorList.Set(addr.String(), false) // FIXME: delete instead?\n}\n\nfunc ModAddPost(slug, title, body, tags string) {\n\tassertIsModerator()\n\n\tcaller := std.GetOrigCaller()\n\ttagList := strings.Split(tags, \",\")\n\terr := b.NewPost(caller, slug, title, body, tagList)\n\tcheckErr(err)\n}\n\nfunc ModEditPost(slug, title, body, tags string) {\n\tassertIsModerator()\n\n\ttagList := strings.Split(tags, \",\")\n\terr := b.GetPost(slug).Update(title, body, tagList)\n\tcheckErr(err)\n}\n\nfunc ModAddCommenter(addr std.Address) {\n\tassertIsModerator()\n\tcommenterList.Set(addr.String(), true)\n}\n\nfunc ModDelCommenter(addr std.Address) {\n\tassertIsModerator()\n\tcommenterList.Set(addr.String(), false) // FIXME: delete instead?\n}\n\nfunc ModDelComment(slug string, index int) {\n\tassertIsModerator()\n\n\terr := b.GetPost(slug).DeleteComment(index)\n\tcheckErr(err)\n}\n\nfunc isAdmin(addr std.Address) bool {\n\treturn addr == adminAddr\n}\n\nfunc isModerator(addr std.Address) bool {\n\t_, found := moderatorList.Get(addr.String())\n\treturn found\n}\n\nfunc isCommenter(addr std.Address) bool {\n\t_, found := commenterList.Get(addr.String())\n\treturn found\n}\n\nfunc assertIsAdmin() {\n\tcaller := std.GetOrigCaller()\n\tif !isAdmin(caller) {\n\t\tpanic(\"access restricted.\")\n\t}\n}\n\nfunc assertIsModerator() {\n\tcaller := std.GetOrigCaller()\n\tif isAdmin(caller) || isModerator(caller) {\n\t\treturn\n\t}\n\tpanic(\"access restricted\")\n}\n\nfunc assertIsCommenter() {\n\tcaller := std.GetOrigCaller()\n\tif isAdmin(caller) || isModerator(caller) || isCommenter(caller) {\n\t\treturn\n\t}\n\tpanic(\"access restricted\")\n}\n\nfunc assertNotInPause() {\n\tif inPause {\n\t\tpanic(\"access restricted (pause)\")\n\t}\n}\n"
                },
                {
                  "Name": "gnoblog.gno",
                  "Body": "package gnoblog\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/blog\"\n)\n\nvar b = \u0026blog.Blog{\n\tTitle:  \"Gnoland's Blog\",\n\tPrefix: \"/r/gnoland/blog:\",\n}\n\nfunc AddComment(postSlug, comment string) {\n\tassertIsCommenter()\n\tassertNotInPause()\n\n\tcaller := std.GetOrigCaller()\n\terr := b.GetPost(postSlug).AddComment(caller, comment)\n\tcheckErr(err)\n}\n\nfunc Render(path string) string {\n\treturn b.Render(path)\n}\n"
                },
                {
                  "Name": "gnoblog_test.gno",
                  "Body": "package gnoblog\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPackage(t *testing.T) {\n\tstd.TestSetOrigCaller(std.Address(\"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\"))\n\n\tauthor := std.GetOrigCaller()\n\n\t// by default, no posts.\n\t{\n\t\tgot := Render(\"\")\n\t\texpected := `\n# Gnoland's Blog\n\nNo posts.\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// create two posts, list post.\n\t{\n\t\tModAddPost(\"slug1\", \"title1\", \"body1\", \"tag1,tag2\")\n\t\tModAddPost(\"slug2\", \"title2\", \"body2\", \"tag1,tag3\")\n\t\tgot := Render(\"\")\n\t\texpected := `\n# Gnoland's Blog\n\n## [\u0026#9656; title1](/r/gnoland/blog:p/slug1)\n\n## [\u0026#9656; title2](/r/gnoland/blog:p/slug2)\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// view post.\n\t{\n\t\tgot := Render(\"p/slug2\")\n\t\texpected := `\n# [Gnoland's Blog](/r/gnoland/blog:) / p / title2\n\nbody2\n\n[#tag1](/r/gnoland/blog:t/tag1) [#tag3](/r/gnoland/blog:t/tag3)\n\nby g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// list by tags.\n\t{\n\t\tgot := Render(\"t/invalid\")\n\t\texpected := \"# [Gnoland's Blog](/r/gnoland/blog:) / t / invalid\\n\\nNo posts.\"\n\t\tassertMDEquals(t, got, expected)\n\n\t\tgot = Render(\"t/tag2\")\n\t\texpected = `\n# [Gnoland's Blog](/r/gnoland/blog:) / t / tag2\n\n## [\u0026#9656; title1](/r/gnoland/blog:p/slug1)\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// add comments.\n\t{\n\t\tAddComment(\"slug1\", \"comment1\")\n\t\tAddComment(\"slug2\", \"comment2\")\n\t\tAddComment(\"slug1\", \"comment3\")\n\t\tAddComment(\"slug2\", \"comment4\")\n\t\tAddComment(\"slug1\", \"comment5\")\n\t\tgot := Render(\"p/slug2\")\n\t\texpected := `\n# [Gnoland's Blog](/r/gnoland/blog:) / p / title2\n\nbody2\n\n[#tag1](/r/gnoland/blog:t/tag1) [#tag3](/r/gnoland/blog:t/tag3)\n\nby g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\n\n#### by g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\ncomment4\n\n#### by g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\ncomment2\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// edit post.\n\t{\n\t\tModEditPost(\"slug2\", \"title2++\", \"body2++\", \"tag1,tag4\")\n\t\tgot := Render(\"p/slug2\")\n\t\texpected := `\n# [Gnoland's Blog](/r/gnoland/blog:) / p / title2++\n\nbody2++\n\n[#tag1](/r/gnoland/blog:t/tag1) [#tag4](/r/gnoland/blog:t/tag4)\n\nby g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\n\n#### by g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\ncomment4\n\n#### by g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq on 2009-02-13 11:31pm UTC\ncomment2\n`\n\t\tassertMDEquals(t, got, expected)\n\t}\n\n\t// TODO: pagination.\n\t// TODO: ?format=...\n\n\t// all 404s\n\t{\n\t\tnotFoundPaths := []string{\n\t\t\t\"p/slug3\",\n\t\t\t\"p\",\n\t\t\t\"p/\",\n\t\t\t\"x/x\",\n\t\t\t\"t\",\n\t\t\t\"t/\",\n\t\t\t\"/\",\n\t\t\t\"p/slug1/\",\n\t\t}\n\t\tfor _, notFoundPath := range notFoundPaths {\n\t\t\tgot := Render(notFoundPath)\n\t\t\texpected := \"404\"\n\t\t\tif got != expected {\n\t\t\t\tt.Errorf(\"path %q: expected %q, got %q.\", notFoundPath, expected, got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc assertMDEquals(t *testing.T, got, expected string) {\n\tt.Helper()\n\texpected = strings.TrimSpace(expected)\n\tgot = strings.TrimSpace(got)\n\tif expected != got {\n\t\tt.Errorf(\"invalid render output.\\nexpected %q.\\ngot      %q.\", expected, got)\n\t}\n}\n"
                },
                {
                  "Name": "util.gno",
                  "Body": "package gnoblog\n\nfunc checkErr(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "faucet",
              "Path": "gno.land/r/gnoland/faucet",
              "Files": [
                {
                  "Name": "admin.gno",
                  "Body": "package faucet\n\nimport (\n\t\"errors\"\n\t\"std\"\n)\n\nfunc AdminSetInPause(inPause bool) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\tgInPause = inPause\n\treturn \"\"\n}\n\nfunc AdminSetMessage(message string) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\tgMessage = message\n\treturn \"\"\n}\n\nfunc AdminSetTransferLimit(amount int64) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\tgLimit = std.Coin{Denom: \"ugnot\", Amount: amount}\n\treturn \"\"\n}\n\nfunc AdminSetAdminAddr(addr std.Address) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\tgAdminAddr = addr\n\treturn \"\"\n}\n\nfunc AdminAddController(addr std.Address) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\n\tsize := gControllers.Size()\n\n\tif size \u003e= gControllersMaxSize {\n\t\treturn \"can not add more controllers than allowed\"\n\t}\n\n\tif gControllers.Has(addr.String()) {\n\t\treturn addr.String() + \" exists, no need to add.\"\n\t}\n\n\tgControllers.Set(addr.String(), addr)\n\n\treturn \"\"\n}\n\nfunc AdminRemoveController(addr std.Address) string {\n\tif err := assertIsAdmin(); err != nil {\n\t\treturn err.Error()\n\t}\n\n\tif !gControllers.Has(addr.String()) {\n\t\treturn addr.String() + \" is not on the controller list\"\n\t}\n\n\t_, ok := gControllers.Remove(addr.String())\n\n\t// it not should happen.\n\t// we will check anyway to prevent issues in the underline implementation.\n\n\tif !ok {\n\t\treturn addr.String() + \" is not on the controller list\"\n\t}\n\n\treturn \"\"\n}\n\nfunc assertIsAdmin() error {\n\tcaller := std.GetOrigCaller()\n\tif caller != gAdminAddr {\n\t\treturn errors.New(\"restricted for admin\")\n\t}\n\treturn nil\n}\n"
                },
                {
                  "Name": "faucet.gno",
                  "Body": "package faucet\n\nimport (\n\t\"errors\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\t// configurable by admin.\n\tgAdminAddr          std.Address = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\tgControllers                    = avl.NewTree()\n\tgControllersMaxSize             = 10 // limit it to 10\n\tgInPause                        = false\n\tgMessage                        = \"# Community Faucet.\\n\\n\"\n\n\t// internal vars, for stats.\n\tgTotalTransferred std.Coins\n\tgTotalTransfers   = uint(0)\n\n\t// per request limit, 350 gnot\n\tgLimit std.Coin = std.Coin{\"ugnot\", 350000000}\n)\n\nfunc Transfer(to std.Address, send int64) string {\n\tif err := assertIsController(); err != nil {\n\t\treturn err.Error()\n\t}\n\n\tif gInPause {\n\t\treturn errors.New(\"faucet in pause\").Error()\n\t}\n\n\t// limit the per request\n\tif send \u003e gLimit.Amount {\n\t\treturn errors.New(\"Per request limit \" + gLimit.String() + \" exceed\").Error()\n\t}\n\tsendCoins := std.Coins{std.Coin{Denom: \"ugnot\", Amount: send}}\n\n\tgTotalTransferred = gTotalTransferred.Add(sendCoins)\n\tgTotalTransfers++\n\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tpkgaddr := std.GetOrigPkgAddr()\n\tbanker.SendCoins(pkgaddr, to, sendCoins)\n\treturn \"\"\n}\n\nfunc GetPerTransferLimit() int64 {\n\treturn gLimit.Amount\n}\n\nfunc Render(_ string) string {\n\tbanker := std.GetBanker(std.BankerTypeRealmSend)\n\tbalance := banker.GetCoins(std.GetOrigPkgAddr())\n\n\toutput := gMessage\n\tif gInPause {\n\t\toutput += \"Status: inactive.\\n\"\n\t} else {\n\t\toutput += \"Status: active.\\n\"\n\t}\n\toutput += ufmt.Sprintf(\"Balance: %s.\\n\", balance.String())\n\toutput += ufmt.Sprintf(\"Total transfers: %s (in %d times).\\n\\n\", gTotalTransferred.String(), gTotalTransfers)\n\n\toutput += \"Package address: \" + std.GetOrigPkgAddr().String() + \"\\n\\n\"\n\toutput += ufmt.Sprintf(\"Admin: %s\\n\\n \", gAdminAddr.String())\n\toutput += ufmt.Sprintf(\"Controllers:\\n\\n \")\n\n\tfor i := 0; i \u003c gControllers.Size(); i++ {\n\t\t_, v := gControllers.GetByIndex(i)\n\t\toutput += ufmt.Sprintf(\"%s  \", v.(std.Address))\n\t}\n\n\toutput += \"\\n\\n\"\n\toutput += ufmt.Sprintf(\"Per request limit: %s\\n\\n\", gLimit.String())\n\n\treturn output\n}\n\nfunc assertIsController() error {\n\tcaller := std.GetOrigCaller()\n\n\tok := gControllers.Has(caller.String())\n\tif !ok {\n\t\treturn errors.New(caller.String() + \" is not on the controller list\")\n\t}\n\treturn nil\n}\n"
                },
                {
                  "Name": "faucet_test.gno",
                  "Body": "package faucet\n\nimport (\n\t\"fmt\"\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/gnoland/faucet\"\n)\n\nfunc TestPackage(t *testing.T) {\n\tvar (\n\t\tadminaddr        = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\t\tfaucetaddr       = std.DerivePkgAddr(\"gno.land/r/faucet\")\n\t\tcontrolleraddr1  = testutils.TestAddress(\"controller1\")\n\t\tcontrolleraddr2  = testutils.TestAddress(\"controller2\")\n\t\tcontrolleraddr3  = testutils.TestAddress(\"controller3\")\n\t\tcontrolleraddr4  = testutils.TestAddress(\"controller4\")\n\t\tcontrolleraddr5  = testutils.TestAddress(\"controller5\")\n\t\tcontrolleraddr6  = testutils.TestAddress(\"controller6\")\n\t\tcontrolleraddr7  = testutils.TestAddress(\"controller7\")\n\t\tcontrolleraddr8  = testutils.TestAddress(\"controller8\")\n\t\tcontrolleraddr9  = testutils.TestAddress(\"controller9\")\n\t\tcontrolleraddr10 = testutils.TestAddress(\"controller10\")\n\t\tcontrolleraddr11 = testutils.TestAddress(\"controller11\")\n\n\t\ttest1addr = testutils.TestAddress(\"test1\")\n\t)\n\t// deposit 1000gnot to faucet contract\n\n\tstd.TestIssueCoins(faucetaddr, std.Coins{{\"ugnot\", 1000000000}})\n\tstd.TestSetOrigPkgAddr(faucetaddr)\n\tassertBalance(t, faucetaddr, 1000000000)\n\n\t// by default, balance is empty, and as a user I cannot call Transfer, or Admin commands.\n\n\tassertBalance(t, test1addr, 0)\n\tstd.TestSetOrigCaller(test1addr)\n\tassertErr(t, faucet.Transfer(test1addr, 1000000))\n\n\tassertErr(t, faucet.AdminAddController(controlleraddr1))\n\tstd.TestSetOrigCaller(controlleraddr1)\n\tassertErr(t, faucet.Transfer(test1addr, 1000000))\n\n\t// as an admin, add the controller to contract and deposit more 2000gnot to contract\n\tstd.TestSetOrigCaller(adminaddr)\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr1))\n\tassertBalance(t, faucetaddr, 1000000000)\n\n\t// now, send some tokens as controller.\n\tstd.TestSetOrigCaller(controlleraddr1)\n\tassertNoErr(t, faucet.Transfer(test1addr, 1000000))\n\tassertBalance(t, test1addr, 1000000)\n\tassertNoErr(t, faucet.Transfer(test1addr, 1000000))\n\tassertBalance(t, test1addr, 2000000)\n\tassertBalance(t, faucetaddr, 998000000)\n\n\t// remove controller\n\t// as an admin, remove controller\n\tstd.TestSetOrigCaller(adminaddr)\n\tassertNoErr(t, faucet.AdminRemoveController(controlleraddr1))\n\tstd.TestSetOrigCaller(controlleraddr1)\n\tassertErr(t, faucet.Transfer(test1addr, 1000000))\n\n\t// duplicate controller\n\tstd.TestSetOrigCaller(adminaddr)\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr1))\n\tassertErr(t, faucet.AdminAddController(controlleraddr1))\n\t// add more than more than allowed controllers\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr2))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr3))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr4))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr5))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr6))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr7))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr8))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr9))\n\tassertNoErr(t, faucet.AdminAddController(controlleraddr10))\n\tassertErr(t, faucet.AdminAddController(controlleraddr11))\n\n\t// send more than per transfer limit\n\tstd.TestSetOrigCaller(adminaddr)\n\tfaucet.AdminSetTransferLimit(300000000)\n\tstd.TestSetOrigCaller(controlleraddr1)\n\tassertErr(t, faucet.Transfer(test1addr, 301000000))\n\n\t// block transefer from the address not on the controllers list.\n\tstd.TestSetOrigCaller(controlleraddr11)\n\tassertErr(t, faucet.Transfer(test1addr, 1000000))\n}\n\nfunc assertErr(t *testing.T, err string) {\n\tt.Helper()\n\n\tif err == \"\" {\n\t\tt.Logf(\"info: got err: %v\", err)\n\t\tt.Errorf(\"expected an error, got nil.\")\n\t}\n}\n\nfunc assertNoErr(t *testing.T, err string) {\n\tt.Helper()\n\tif err != \"\" {\n\t\tt.Errorf(\"got err: %v.\", err)\n\t}\n}\n\nfunc assertBalance(t *testing.T, addr std.Address, expectedBal int64) {\n\tt.Helper()\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\tcoins := banker.GetCoins(addr)\n\tgot := coins.AmountOf(\"ugnot\")\n\n\tif expectedBal != got {\n\t\tt.Errorf(\"invalid balance: expected %d, got %d.\", expectedBal, got)\n\t}\n}\n"
                },
                {
                  "Name": "z0_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"gno.land/r/gnoland/faucet\"\n)\n\n// assert render with empty path and no controllers\nfunc main() {\n\tprintln(faucet.Render(\"\"))\n}\n\n// Output:\n// # Community Faucet.\n//\n// Status: active.\n// Balance: 200000000ugnot.\n// Total transfers:  (in 0 times).\n//\n// Package address: g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4\n//\n// Admin: g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n//\n//  Controllers:\n//\n//\n//\n// Per request limit: 350000000ugnot\n"
                },
                {
                  "Name": "z1_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"gno.land/r/gnoland/faucet\"\n)\n\n// assert render with a path and no controllers\nfunc main() {\n\tprintln(faucet.Render(\"path\"))\n}\n\n// Output:\n// # Community Faucet.\n//\n// Status: active.\n// Balance: 200000000ugnot.\n// Total transfers:  (in 0 times).\n//\n// Package address: g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4\n//\n// Admin: g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n//\n//  Controllers:\n//\n//\n//\n// Per request limit: 350000000ugnot\n"
                },
                {
                  "Name": "z2_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/gnoland/faucet\"\n)\n\n// assert render with empty path and 2 controllers\nfunc main() {\n\tvar (\n\t\tadminaddr       = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\t\tcontrolleraddr1 = testutils.TestAddress(\"controller1\")\n\t\tcontrolleraddr2 = testutils.TestAddress(\"controller2\")\n\t)\n\tstd.TestSetOrigCaller(adminaddr)\n\terr := faucet.AdminAddController(controlleraddr1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = faucet.AdminAddController(controlleraddr2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(faucet.Render(\"\"))\n}\n\n// Output:\n// # Community Faucet.\n//\n// Status: active.\n// Balance: 200000000ugnot.\n// Total transfers:  (in 0 times).\n//\n// Package address: g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4\n//\n// Admin: g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n//\n//  Controllers:\n//\n//  g1vdhkuarjdakxcetjx9047h6lta047h6lsdacav  g1vdhkuarjdakxcetjxf047h6lta047h6lnrev3v\n//\n// Per request limit: 350000000ugnot\n"
                },
                {
                  "Name": "z3_filetest.gno",
                  "Body": "package main\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/testutils\"\n\t\"gno.land/r/gnoland/faucet\"\n)\n\n// assert render with 2 controllers and 2 transfers\nfunc main() {\n\tvar (\n\t\tadminaddr       = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\t\tcontrolleraddr1 = testutils.TestAddress(\"controller1\")\n\t\tcontrolleraddr2 = testutils.TestAddress(\"controller2\")\n\t\ttestaddr1       = testutils.TestAddress(\"test1\")\n\t\ttestaddr2       = testutils.TestAddress(\"test2\")\n\t)\n\tstd.TestSetOrigCaller(adminaddr)\n\terr := faucet.AdminAddController(controlleraddr1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = faucet.AdminAddController(controlleraddr2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tstd.TestSetOrigCaller(controlleraddr1)\n\terr = faucet.Transfer(testaddr1, 1000000)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tstd.TestSetOrigCaller(controlleraddr2)\n\terr = faucet.Transfer(testaddr1, 2000000)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(faucet.Render(\"\"))\n}\n\n// Output:\n// # Community Faucet.\n//\n// Status: active.\n// Balance: 197000000ugnot.\n// Total transfers: 3000000ugnot (in 2 times).\n//\n// Package address: g17rgsdnfxzza0sdfsdma37sdwxagsz378833ca4\n//\n// Admin: g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n//\n//  Controllers:\n//\n//  g1vdhkuarjdakxcetjx9047h6lta047h6lsdacav  g1vdhkuarjdakxcetjxf047h6lta047h6lnrev3v\n//\n// Per request limit: 350000000ugnot\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "validators",
              "Path": "gno.land/r/system/validators",
              "Files": [
                {
                  "Name": "validators.gno",
                  "Body": "// This package is used to manage the validator set.\npackage validators\n\n// write specs.\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "names",
              "Path": "gno.land/r/system/names",
              "Files": [
                {
                  "Name": "genesis.gno",
                  "Body": "package names\n\nimport \"std\"\n\nfunc init() {\n\t// Please, do not edit this file to reserve your username, use a transaction instead.\n\tvar (\n\t\tjaekwon       = std.Address(\"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\")\n\t\tmanfred       = std.Address(\"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\")\n\t\ttest1         = std.Address(\"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\")\n\t\treservedAdmin = std.Address(\"g100000000000000000000000000000000000000\") // FIXME: create a multisig.\n\t\treservedNames = []string{\n\t\t\t// FIXME: complete this list.\n\t\t\t\"gno\", \"gnolang\", \"tendermint\", \"cosmos\", \"hub\", \"admin\",\n\t\t\t\"ethereum\", \"bitcoin\",\n\t\t\t// FIXME: reserve brands? then, require KYC to unlock?\n\t\t}\n\t)\n\tnamespaces.Set(\"demo\", \u0026Space{Admins: []std.Address{jaekwon, manfred}})\n\tnamespaces.Set(\"gnoland\", \u0026Space{Admins: []std.Address{jaekwon, manfred}})\n\tnamespaces.Set(\"system\", \u0026Space{Admins: []std.Address{jaekwon, manfred}})\n\tnamespaces.Set(\"jaekwon\", \u0026Space{Admins: []std.Address{jaekwon}})\n\tnamespaces.Set(\"manfred\", \u0026Space{Admins: []std.Address{manfred}})\n\tnamespaces.Set(\"test1\", \u0026Space{Admins: []std.Address{test1}})\n\n\tfor _, keyword := range reservedNames {\n\t\tnamespaces.Set(keyword, \u0026Space{Admins: []std.Address{reservedAdmin}})\n\t}\n}\n"
                },
                {
                  "Name": "names.gno",
                  "Body": "// The realm r/system/names is used to manage namespaces on gno.land.\npackage names\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\n// \"AddPkg\" will check if r/system/names exists. If yes, it will\n// inspect the realm's state and use the following variable to\n// determine if an address can publish a package or not.\nvar namespaces avl.Tree // name(string) -\u003e Space\n\ntype Space struct {\n\tAdmins  []std.Address\n\tEditors []std.Address\n\tInPause bool\n}\n\nfunc Register(namespace string) {\n\t// TODO: input sanitization:\n\t// - already exists / reserved.\n\t// - min/max length, format.\n\t// - fees (dynamic, based on length).\n\tpanic(\"not implemented\")\n}\n\nfunc AddAdmin(namespace string, newAdmin std.Address) {\n\t// TODO: assertIsAdmin()\n\tpanic(\"not implemented\")\n}\n\nfunc RemoveAdmin(namespace string, newAdmin std.Address) {\n\t// TODO: assertIsAdmin()\n\t// TODO: check if self.\n\tpanic(\"not implemented\")\n}\n\nfunc AddEditor(namespace string, newAdmin std.Address) {\n\t// TODO: assertIsAdmin()\n\tpanic(\"not implemented\")\n}\n\nfunc RemoveEditor(namespace string, newAdmin std.Address) {\n\t// TODO: assertIsAdmin()\n\t// TODO: check if self.\n\tpanic(\"not implemented\")\n}\n\nfunc SetInPause(namespace string, state bool) {\n\t// TODO: assertIsAdmin()\n\tpanic(\"not implemented\")\n}\n\nfunc Render(path string) string {\n\t// TODO: by namespace.\n\t// TODO: by address.\n\treturn \"not implemented\"\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "rewards",
              "Path": "gno.land/r/system/rewards",
              "Files": [
                {
                  "Name": "rewards.gno",
                  "Body": "// This package will be used to manage proof-of-contributions on the exposed smart-contract side.\npackage rewards\n\n// TODO: write specs.\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_addpkg",
            "creator": "g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5",
            "package": {
              "Name": "deep",
              "Path": "gno.land/r/demo/deep/very/deep",
              "Files": [
                {
                  "Name": "render.gno",
                  "Body": "package deep\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"it works!\"\n\t} else {\n\t\treturn \"hi \" + path\n\t}\n}\n"
                }
              ]
            },
            "deposit": ""
          }
        ],
        "fee": {
          "gas_wanted": "50000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": null,
            "signature": null
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Invite",
            "args": [
              "g1589c8cekvmjfmy0qrd4f3z52r7fn7rgk02667s:1\ng13sm84nuqed3fuank8huh7x9mupgw22uft3lcl8:1\ng1m6732pkrngu9vrt0g7056lvr9kcqc4mv83xl5q:1\ng1wg88rhzlwxjd2z4j5de5v5xq30dcf6rjq3dhsj:1\ng18pmaskasz7mxj6rmgrl3al58xu45a7w0l5nmc0:1\ng19wwhkmqlns70604ksp6rkuuu42qhtvyh05lffz:1\ng187982000zsc493znqt828s90cmp6hcp2erhu6m:1\ng1ndpsnrspdnauckytvkfv8s823t3gmpqmtky8pl:1\ng16ja66d65emkr0zxd2tu7xjvm7utthyhpej0037:1\ng1ds24jj9kqjcskd0gzu24r9e4n62ggye230zuv5:1\ng1trkzq75ntamsnw9xnrav2v7gy2lt5g6p29yhdr:1\ng1rrf8s5mrmu00sx04fzfsvc399fklpeg2x0a7mz:1\ng19p5ntfvpt4lwq4jqsmnxsnelhf3tff9scy3w8w:1\ng1tue8l73d6rq4vhqdsp2sr3zhuzpure3k2rnwpz:1\ng14hhsss4ngx5kq77je5g0tl4vftg8qp45ceadk3:1\ng1768hvkh7anhd40ch4h7jdh6j3mpcs7hrat4gl0:1\ng15fa8kyjhu88t9dr8zzua8fwdvkngv5n8yqsm0n:1\ng1xhccdjcscuhgmt3quww6qdy3j3czqt3urc2eac:1\ng1z629z04f85k4t5gnkk5egpxw9tqxeec435esap:1\ng1pfldkplz9puq0v82lu9vqcve9nwrxuq9qe5ttv:1\ng152pn0g5qfgxr7yx8zlwjq48hytkafd8x7egsfv:1\ng1cf2ye686ke38vjyqakreprljum4xu6rwf5jskq:1\ng1c5shztyaj4gjrc5zlwmh9xhex5w7l4asffs2w6:1\ng1lhpx2ktk0ha3qw42raxq4m24a4c4xqxyrgv54q:1\ng1026p54q0j902059sm2zsv37krf0ghcl7gmhyv7:1\ng1n4yvwnv77frq2ccuw27dmtjkd7u4p4jg0pgm7k:1\ng13m7f2e6r3lh3ykxupacdt9sem2tlvmaamwjhll:1\ng19uxluuecjlsqvwmwu8sp6pxaaqfhk972q975xd:1\ng1j80fpcsumfkxypvydvtwtz3j4sdwr8c2u0lr64:1\ng1tjdpptuk9eysq6z38nscqyycr998xjyx3w8jvw:1\ng19t3n89slfemgd3mwuat4lajwcp0yxrkadgeg7a:1\ng1yqndt8xx92l9h494jfruz2w79swzjes3n4wqjc:1\ng13278z0a5ufeg80ffqxpda9dlp599t7ekregcy6:1\ng1ht236wjd83x96uqwh9rh3fq6pylyn78mtwq9v6:1\ng1fj9jccm3zjnqspq7lp2g7lj4czyfq0s35600g9:1\ng1wwppuzdns5u6c6jqpkzua24zh6ppsus6399cea:1\ng1k8pjnguyu36pkc8hy0ufzgpzfmj2jl78la7ek3:1\ng1e8umkzumtxgs8399lw0us4rclea3xl5gxy9spp:1\ng14qekdkj2nmmwea4ufg9n002a3pud23y8k7ugs5:1\ng19w2488ntfgpduzqq3sk4j5x387zynwknqdvjqf:1\ng1495y3z7zrej4rendysnw5kaeu4g3d7x7w0734g:1\ng1hygx8ga9qakhkczyrzs9drm8j8tu4qds9y5e3r:1\ng1f977l6wxdh3qu60kzl75vx2wmzswu68l03r8su:1\ng1644qje5rx6jsdqfkzmgnfcegx4dxkjh6rwqd69:1\ng1mzjajymvmtksdwh3wkrndwj6zls2awl9q83dh6:1\ng1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq:10\ng14da4n9hcynyzz83q607uu8keuh9hwlv42ra6fa:10\ng14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t:5\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AmG6kzznyo1uNqWPAYU6wDpsmzQKDaEOrVRaZ08vOyX0"
            },
            "signature": "S8iMMzlOMK8dmox78R9Z8+pSsS8YaTCXrIcaHDpiOgkOy7gqoQJ0oftM0zf8zAz4xpezK8Lzg8Q0fCdXJxV76w=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Invite",
            "args": [
              "g1thlf3yct7n7ex70k0p62user0kn6mj6d3s0cg3\ng1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AmG6kzznyo1uNqWPAYU6wDpsmzQKDaEOrVRaZ08vOyX0"
            },
            "signature": "njczE6xYdp01+CaUU/8/v0YC/NuZD06+qLind+ZZEEMNaRe/4Ln+4z7dG6HYlaWUMsyI1KCoB6NIehoE0PZ44Q=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Invite",
            "args": [
              "g1589c8cekvmjfmy0qrd4f3z52r7fn7rgk02667s\ng13sm84nuqed3fuank8huh7x9mupgw22uft3lcl8\ng1m6732pkrngu9vrt0g7056lvr9kcqc4mv83xl5q\ng1wg88rhzlwxjd2z4j5de5v5xq30dcf6rjq3dhsj\ng18pmaskasz7mxj6rmgrl3al58xu45a7w0l5nmc0\ng19wwhkmqlns70604ksp6rkuuu42qhtvyh05lffz\ng187982000zsc493znqt828s90cmp6hcp2erhu6m\ng1ndpsnrspdnauckytvkfv8s823t3gmpqmtky8pl\ng16ja66d65emkr0zxd2tu7xjvm7utthyhpej0037\ng1ds24jj9kqjcskd0gzu24r9e4n62ggye230zuv5\ng1trkzq75ntamsnw9xnrav2v7gy2lt5g6p29yhdr\ng1rrf8s5mrmu00sx04fzfsvc399fklpeg2x0a7mz\ng19p5ntfvpt4lwq4jqsmnxsnelhf3tff9scy3w8w\ng1tue8l73d6rq4vhqdsp2sr3zhuzpure3k2rnwpz\ng14hhsss4ngx5kq77je5g0tl4vftg8qp45ceadk3\ng1768hvkh7anhd40ch4h7jdh6j3mpcs7hrat4gl0\ng15fa8kyjhu88t9dr8zzua8fwdvkngv5n8yqsm0n\ng1xhccdjcscuhgmt3quww6qdy3j3czqt3urc2eac\ng1z629z04f85k4t5gnkk5egpxw9tqxeec435esap\ng1pfldkplz9puq0v82lu9vqcve9nwrxuq9qe5ttv\ng152pn0g5qfgxr7yx8zlwjq48hytkafd8x7egsfv\ng1cf2ye686ke38vjyqakreprljum4xu6rwf5jskq\ng1c5shztyaj4gjrc5zlwmh9xhex5w7l4asffs2w6\ng1lhpx2ktk0ha3qw42raxq4m24a4c4xqxyrgv54q\ng1026p54q0j902059sm2zsv37krf0ghcl7gmhyv7\ng1n4yvwnv77frq2ccuw27dmtjkd7u4p4jg0pgm7k\ng13m7f2e6r3lh3ykxupacdt9sem2tlvmaamwjhll\ng19uxluuecjlsqvwmwu8sp6pxaaqfhk972q975xd\ng1j80fpcsumfkxypvydvtwtz3j4sdwr8c2u0lr64\ng1tjdpptuk9eysq6z38nscqyycr998xjyx3w8jvw\ng19t3n89slfemgd3mwuat4lajwcp0yxrkadgeg7a\ng1yqndt8xx92l9h494jfruz2w79swzjes3n4wqjc\ng13278z0a5ufeg80ffqxpda9dlp599t7ekregcy6\ng1ht236wjd83x96uqwh9rh3fq6pylyn78mtwq9v6\ng1fj9jccm3zjnqspq7lp2g7lj4czyfq0s35600g9\ng1wwppuzdns5u6c6jqpkzua24zh6ppsus6399cea\ng1k8pjnguyu36pkc8hy0ufzgpzfmj2jl78la7ek3\ng1e8umkzumtxgs8399lw0us4rclea3xl5gxy9spp\ng14qekdkj2nmmwea4ufg9n002a3pud23y8k7ugs5\ng19w2488ntfgpduzqq3sk4j5x387zynwknqdvjqf\ng1495y3z7zrej4rendysnw5kaeu4g3d7x7w0734g\ng1hygx8ga9qakhkczyrzs9drm8j8tu4qds9y5e3r\ng1f977l6wxdh3qu60kzl75vx2wmzswu68l03r8su\ng1644qje5rx6jsdqfkzmgnfcegx4dxkjh6rwqd69\ng1mzjajymvmtksdwh3wkrndwj6zls2awl9q83dh6\ng1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq\ng14da4n9hcynyzz83q607uu8keuh9hwlv42ra6fa\ng14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "4000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AmG6kzznyo1uNqWPAYU6wDpsmzQKDaEOrVRaZ08vOyX0"
            },
            "signature": "7AmlhZhsVkxCUl0bbpvpPMnIKihwtG7A5IFR6Tg4xStWLgaUr05XmWRKlO2xjstTtwbVKQT5mFL4h5wyX4SQzw=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "2000000000ugnot",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "",
              "administrator",
              "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AmG6kzznyo1uNqWPAYU6wDpsmzQKDaEOrVRaZ08vOyX0"
            },
            "signature": "AqCqe0cS55Ym7/BvPDoCDyPP5q8284gecVQ2PMOlq/4lJpO9Q18SOWKI15dMEBY1pT0AYyhCeTirlsM1I3Y4Cg=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1qpymzwx4l4cy6cerdyajp9ksvjsf20rk5y9rtt",
            "send": "2000000000ugnot",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "",
              "zo_oma",
              "Love is the encryption  key\u003c3"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "A6yg5/iiktruezVw5vZJwLlGwyrvw8RlqOToTRMWXkE2"
            },
            "signature": "GGp+bVL2eEvKecPqgcULSABYOSnSMnJzfIsR8ZIRER1GGX/fOiCReX4WKMrGLVROJVfbLQkDRwvhS4TLHlSoSQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq",
            "send": "2000000000ugnot",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "",
              "manfred",
              "https://github.com/moul"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "2000000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"
            },
            "signature": "9CWeNbKx+hEL+RdHplAVAFntcrAVx5mK9tMqoywuHVoreH844n3yOxddQrGfBk6T2tMBmNWakERRqWZfS+bYAQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1fj9jccm3zjnqspq7lp2g7lj4czyfq0s35600g9",
            "send": "2000000000ugnot",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "",
              "piupiu",
              "@piux2"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "Ar68lqbU2YC63fbMcYUtJhYO3/66APM/EqF7m0nUjGyz"
            },
            "signature": "pTUpP0d/XlfVe3TH1hlaoLhKadzIKG1gtQ/Ueuat72p+659RWRea58Z0mk6GgPE/EeTbhMEY45zufevBdGJVoQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1ds24jj9kqjcskd0gzu24r9e4n62ggye230zuv5",
            "send": "",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
              "anarcher",
              "https://twitter.com/anarcher"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AjpLbKdQeH+yB/1OCB148l5GlRRrXma71hdA8EES3H7f"
            },
            "signature": "pf5xm8oWIQIOEwSGw4icPmynLXb1P1HxKfjeh8UStU1mlIBPKa7yppeIMPpAflC0o2zjFR7Axe7CimAebm3BHg=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g15gdm49ktawvkrl88jadqpucng37yxutucuwaef",
            "send": "2000000000ugnot",
            "pkg_path": "gno.land/r/demo/users",
            "func": "Register",
            "args": [
              "",
              "ideamour",
              "\u003c3"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AhClx4AsDuX3DNCPxhDwWnrfd4MIZmxJE4vt47ClVvT2"
            },
            "signature": "IQe64af878k6HjLDqIJeg27GXAVF6xS+96cDe2jMlxNV6+8sOcuUctp0GiWVnYfN4tpthC6d4WhBo+VlpHqkbg=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateBoard",
            "args": [
              "testboard"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"
            },
            "signature": "vzlSxEFh5jOkaSdv3rsV91v/OJKEF2qSuoCpri1u5tRWq62T7xr3KHRCF5qFnn4aQX/yE8g8f/Y//WPOCUGhJw=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateThread",
            "args": [
              "1",
              "Hello World",
              "This is a demo of Gno smart contract programming.  This document was\nconstructed by Gno onto a smart contract hosted on the data Realm \nname [\"gno.land/r/demo/boards\"](https://gno.land/r/demo/boards/)\n([github](https://github.com/gnolang/gno/tree/master/examples/gno.land/r/demo/boards)).\n\n## Starting the `gnoland` node node/validator.\n\nNOTE: Where you see `--remote localhost:26657` here, that flag can be replaced\nwith `--remote localhost:26657` for local testnets.\n\n### build gnoland.\n\n```bash\ngit clone git@github.com:gnolang/gno.git\ncd ./gno\nmake \n```\n\n### add test account.\n\n```bash\n./build/gnokey add test1 --recover\n```\n\nUse this mnemonic:\n\u003e source bonus chronic canvas draft south burst lottery vacant surface solve popular case indicate oppose farm nothing bullet exhibit title speed wink action roast\n\n### start gnoland validator node.\n\n```bash\n./build/gnoland\n```\n\n(This can be reset with `make reset`).\n\n### start gnoland web server (optional).\n\n```bash\ngo run ./gnoland/website\n```\n\n## Signing and broadcasting transactions.\n\n### publish the \"gno.land/p/demo/avl\" package.\n\n```bash\n./build/gnokey maketx addpkg test1 --pkgpath \"gno.land/p/demo/avl\" --pkgdir \"examples/gno.land/p/demo/avl\" --deposit 100ugnot --gas-fee 1ugnot --gas-wanted 2000000 \u003e addpkg.avl.unsigned.txt\n./build/gnokey query \"auth/accounts/g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\n./build/gnokey sign test1 --txpath addpkg.avl.unsigned.txt --chainid \"dev\" --number 0 --sequence 0 \u003e addpkg.avl.signed.txt\n./build/gnokey broadcast addpkg.avl.signed.txt --remote localhost:26657\n```\n\n### publish the \"gno.land/r/demo/boards\" realm package.\n\n```bash\n./build/gnokey maketx addpkg test1 --pkgpath \"gno.land/r/demo/boards\" --pkgdir \"examples/gno.land/r/demo/boards\" --deposit 100ugnot --gas-fee 1ugnot --gas-wanted 300000000 \u003e addpkg.boards.unsigned.txt\n./build/gnokey sign test1 --txpath addpkg.boards.unsigned.txt --chainid \"dev\" --number 0 --sequence 1 \u003e addpkg.boards.signed.txt\n./build/gnokey broadcast addpkg.boards.signed.txt --remote localhost:26657\n```\n\n### create a board with a smart contract call.\n\n```bash\n./build/gnokey maketx call test1 --pkgpath \"gno.land/r/demo/boards\" --func CreateBoard --args \"testboard\" --gas-fee 1ugnot --gas-wanted 2000000 \u003e createboard.unsigned.txt\n./build/gnokey sign test1 --txpath createboard.unsigned.txt --chainid \"dev\" --number 0 --sequence 2 \u003e createboard.signed.txt\n./build/gnokey broadcast createboard.signed.txt --remote localhost:26657\n```\nNext, query for the permanent board ID by querying (you need this to create a new post):\n\n```bash\n./build/gnokey query \"vm/qeval\" --data \"gno.land/r/demo/boards\nGetBoardIDFromName(\\\"testboard\\\")\"\n```\n\n### create a post of a board with a smart contract call.\n\n```bash\n./build/gnokey maketx call test1 --pkgpath \"gno.land/r/demo/boards\" --func CreatePost --args 1 --args \"Hello World\" --args#file \"./examples/gno.land/r/demo/boards/README.md\" --gas-fee 1ugnot --gas-wanted 2000000 \u003e createpost.unsigned.txt\n./build/gnokey sign test1 --txpath createpost.unsigned.txt --chainid \"dev\" --number 0 --sequence 3 \u003e createpost.signed.txt\n./build/gnokey broadcast createpost.signed.txt --remote localhost:26657\n```\n\n### create a comment to a post.\n\n```bash\n./build/gnokey maketx call test1 --pkgpath \"gno.land/r/demo/boards\" --func CreateReply --args 1 --args 1 --args \"A comment\" --gas-fee 1ugnot --gas-wanted 2000000 \u003e createcomment.unsigned.txt\n./build/gnokey sign test1 --txpath createcomment.unsigned.txt --chainid \"dev\" --number 0 --sequence 4 \u003e createcomment.signed.txt\n./build/gnokey broadcast createcomment.signed.txt --remote localhost:26657\n```\n\n```bash\n./build/gnokey query \"vm/qrender\" --data \"gno.land/r/demo/boards\ntestboard/1\"\n```\n\n### render page with optional path expression.\n\nThe contents of `https://gno.land/r/demo/boards:` and `https://gno.land/r/demo/boards:testboard` are rendered by calling\nthe `Render(path string)` function like so:\n\n```bash\n./build/gnokey query \"vm/qrender\" --data \"gno.land/r/demo/boards\ntestboard\"\n```\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"
            },
            "signature": "V43B1waFxhzheW9TfmCpjLdrC4dC1yjUGES5y3J6QsNar6hRpNz4G1thzWmWK7xXhg8u1PCIpxLxGczKQYhuPw=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateThread",
            "args": [
              "1",
              "NFT example",
              "NFT's are all the rage these days, for various reasons.\n\nI read over EIP-721 which appears to be the de-facto NFT standard on Ethereum. Then, made a sample implementation of EIP-721 (let's here called GRC-721). The implementation isn't complete, but it demonstrates the main functionality.\n\n - [EIP-721](https://eips.ethereum.org/EIPS/eip-721)\n - [gno.land/r/demo/nft/nft.gno](https://gno.land/r/demo/nft/nft.gno)\n - [zrealm_nft3.gno test](https://github.com/gnolang/gno/blob/master/examples/gno.land/r/demo/nft/z_3_filetest.gno)\n\nIn short, this demonstrates how to implement Ethereum contract interfaces in Gno.land; by using only standard Go language features.\n\nPlease leave a comment ([guide](https://gno.land/r/demo/boards:testboard/1)).\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"
            },
            "signature": "ZXfrTiHxPFQL8uSm+Tv7WXIHPMca9okhm94RAlC6YgNbB1VHQYYpoP4w+cnL3YskVzGrOZxensXa9CAZ+cNNeg=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateThread",
            "args": [
              "1",
              "Simple echo example with coins",
              "This is a simple test realm contract that demonstrates how to use the banker.\n\nSee [gno.land/r/demo/banktest/banktest.gno](/r/banktest/banktest.gno) to see the original contract code.\n\nThis article will go through each line to explain how it works.\n\n```go\npackage banktest\n```\n\nThis package is locally named \"banktest\" (could be anything).\n\n```go\nimport (\n\t\"std\"\n)\n```\n\nThe \"std\" package is defined by the gno code in stdlibs/std/. \u003c/br\u003e\nSelf explanatory; and you'll see more usage from std later.\n\n```go\ntype activity struct {\n\tcaller   std.Address\n\tsent     std.Coins\n\treturned std.Coins\n\ttime     std.Time\n}\n\nfunc (act *activity) String() string {\n\treturn act.caller.String() + \" \" +\n\t\tact.sent.String() + \" sent, \" +\n\t\tact.returned.String() + \" returned, at \" +\n\t\tstd.FormatTimestamp(act.time, \"2006-01-02 3:04pm MST\")\n}\n\nvar latest [10]*activity\n```\n\nThis is just maintaining a list of recent activity to this contract.\nNotice that the \"latest\" variable is defined \"globally\" within\nthe context of the realm with path \"gno.land/r/demo/banktest\".\n\nThis means that calls to functions defined within this package\nare encapsulated within this \"data realm\", where the data is \nmutated based on transactions that can potentially cross many\nrealm and non-realm packge boundaries (in the call stack).\n\n```go\n// Deposit will take the coins (to the realm's pkgaddr) or return them to user.\nfunc Deposit(returnDenom string, returnAmount int64) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\tsend := std.Coins{{returnDenom, returnAmount}}\n```\n\nThis is the beginning of the definition of the contract function named\n\"Deposit\".  `std.AssertOriginCall() asserts that this function was called by a\ngno transactional Message. The caller is the user who signed off on this\ntransactional message. Send is the amount of deposit sent along with this\nmessage.\n\n```go\n\t// record activity\n\tact := \u0026activity{\n\t\tcaller:   caller,\n\t\tsent:     std.GetOrigSend(),\n\t\treturned: send,\n\t\ttime:     std.GetTimestamp(),\n\t}\n\tfor i := len(latest) - 2; i \u003e= 0; i-- {\n\t\tlatest[i+1] = latest[i] // shift by +1.\n\t}\n\tlatest[0] = act\n```\n\nUpdating the \"latest\" array for viewing at gno.land/r/demo/banktest: (w/ trailing colon).\n\n```go\n\t// return if any.\n\tif returnAmount \u003e 0 {\n```\n\nIf the user requested the return of coins...\n\n```go\n\t\tbanker := std.GetBanker(std.BankerTypeOrigSend)\n```\n\nuse a std.Banker instance to return any deposited coins to the original sender.\n\n```go\n\t\tpkgaddr := std.GetOrigPkgAddr()\n\t\t// TODO: use std.Coins constructors, this isn't generally safe.\n\t\tbanker.SendCoins(pkgaddr, caller, send)\n\t\treturn \"returned!\"\n```\n\nNotice that each realm package has an associated Cosmos address.\n\n\nFinally, the results are rendered via an ABCI query call when you visit [/r/banktest:](/r/banktest:).\n\n```go\nfunc Render(path string) string {\n\t// get realm coins.\n\tbanker := std.GetBanker(std.BankerTypeReadonly)\n\tcoins := banker.GetCoins(std.GetOrigPkgAddr())\n\n\t// render\n\tres := \"\"\n\tres += \"## recent activity\\n\"\n\tres += \"\\n\"\n\tfor _, act := range latest {\n\t\tif act == nil {\n\t\t\tbreak\n\t\t}\n\t\tres += \" * \" + act.String() + \"\\n\"\n\t}\n\tres += \"\\n\"\n\tres += \"## total deposits\\n\"\n\tres += coins.String()\n\treturn res\n}\n```\n\nYou can call this contract yourself, by vistiing [/r/banktest](/r/banktest) and the [quickstart guide](/r/boards:testboard/4).\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"
            },
            "signature": "iZX/llZlNTdZMLv1goCTgK2bWqzT8enlTq56wMTCpVxJGA0BTvuEM5Nnt9vrnlG6Taqj2GuTrmEnJBkDFTmt9g=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateThread",
            "args": [
              "1",
              "TASK: Describe in your words",
              "Describe in an essay (250+ words), on your favorite medium, why you are interested in gno.land and gnolang.\n\nReply here with a URL link to your written piece as a comment, for rewards.\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AmG6kzznyo1uNqWPAYU6wDpsmzQKDaEOrVRaZ08vOyX0"
            },
            "signature": "4HBNtrta8HdeHj4JTN56PBTRK8GOe31NMRRXDiyYtjozuyRdWfOGEsGjGgHWcoBUJq6DepBgD4FetdqfhZ6TNQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq",
            "send": "",
            "pkg_path": "gno.land/r/demo/boards",
            "func": "CreateThread",
            "args": [
              "1",
              "Getting Started",
              "This is a demo of Gno smart contract programming.  This document was\nconstructed by Gno onto a smart contract hosted on the data Realm\nname [\"gno.land/r/demo/boards\"](https://gno.land/r/demo/boards/)\n([github](https://github.com/gnolang/gno/tree/master/examples/gno.land/r/demo/boards)).\n\n\n\n## Build `gnokey`, create your account, and interact with Gno.\n\nNOTE: Where you see `--remote localhost:26657` here, that flag can be replaced\nwith `--remote localhost:26657` for local testnets.\n\n### Build `gnokey`.\n\n```bash\ngit clone git@github.com:gnolang/gno.git\ncd ./gno\nmake\n```\n\n### Generate a seed/mnemonic code.\n\n```bash\n./build/gnokey generate\n```\n\nNOTE: You can generate 24 words with any good bip39 generator.\n\n### Create a new account using your mnemonic.\n\n```bash\n./build/gnokey add KEYNAME --recover\n```\n\nNOTE: `KEYNAME` is your key identifier, and should be changed.\n\n### Verify that you can see your account locally.\n\n```bash\n./build/gnokey list\n```\n\n## Interact with the blockchain:\n\n### Get your current balance, account number, and sequence number.\n\n```bash\n./build/gnokey query auth/accounts/ACCOUNT_ADDR --remote localhost:26657\n```\n\nNOTE: you can retrieve your `ACCOUNT_ADDR` with `./build/gnokey list`.\n\n### Acquire testnet tokens using the official faucet.\n\nGo to https://gno.land/faucet\n\n### Create a board with a smart contract call.\n\nNOTE: `BOARDNAME` will be the slug of the board, and should be changed.\n\n```bash\n./build/gnokey maketx call KEYNAME --pkgpath \"gno.land/r/demo/boards\" --func \"CreateBoard\" --args \"BOARDNAME\" --gas-fee \"1000000ugnot\" --gas-wanted \"2000000\" --broadcast true --chainid dev --remote localhost:26657\n```\n\nInteractive documentation: https://gno.land/r/demo/boards?help\u0026__func=CreateBoard\n\nNext, query for the permanent board ID by querying (you need this to create a new post):\n\n```bash\n./build/gnokey query \"vm/qeval\" --data \"gno.land/r/demo/boards\nGetBoardIDFromName(\\\"BOARDNAME\\\")\" --remote localhost:26657\n```\n\n### Create a post of a board with a smart contract call.\n\nNOTE: If a board was created successfully, your SEQUENCE_NUMBER would have increased.\n\n```bash\n./build/gnokey maketx call KEYNAME --pkgpath \"gno.land/r/demo/boards\" --func \"CreateThread\" --args BOARD_ID --args \"Hello gno.land\" --args\\#file \"./examples/gno.land/r/demo/boards/example_post.md\" --gas-fee 1000000ugnot --gas-wanted 2000000 --broadcast true --chainid dev --remote localhost:26657\n```\n\nInteractive documentation: https://gno.land/r/demo/boards?help\u0026__func=CreateThread\n\n### Create a comment to a post.\n\n```bash\n./build/gnokey maketx call KEYNAME --pkgpath \"gno.land/r/demo/boards\" --func \"CreateReply\" --args \"BOARD_ID\" --args \"1\" --args \"1\" --args \"Nice to meet you too.\" --gas-fee 1000000ugnot --gas-wanted 2000000 --broadcast true --chainid dev --remote localhost:26657\n```\n\nInteractive documentation: https://gno.land/r/demo/boards?help\u0026__func=CreateReply\n\n```bash\n./build/gnokey query \"vm/qrender\" --data \"gno.land/r/demo/boards\nBOARDNAME/1\" --remote localhost:26657\n```\n\n### Render page with optional path expression.\n\nThe contents of `https://gno.land/r/demo/boards:` and `https://gno.land/r/demo/boards:gnolang` are rendered by calling\nthe `Render(path string)` function like so:\n\n```bash\n./build/gnokey query \"vm/qrender\" --data \"gno.land/r/demo/boards\ngnolang\"\n```\n\n## Starting a local `gnoland` node:\n\n### Add test account.\n\n```bash\n./build/gnokey add test1 --recover\n```\n\nUse this mneonic:\n\u003e source bonus chronic canvas draft south burst lottery vacant surface solve popular case indicate oppose farm nothing bullet exhibit title speed wink action roast\n\n### Start `gnoland` node.\n\n```bash\n./build/gnoland\n```\n\nNOTE: This can be reset with `make reset`\n\n### Publish the \"gno.land/p/demo/avl\" package.\n\n```bash\n./build/gnokey maketx addpkg test1 --pkgpath \"gno.land/p/demo/avl\" --pkgdir \"examples/gno.land/p/demo/avl\" --deposit 100000000ugnot --gas-fee 1000000ugnot --gas-wanted 2000000 --broadcast true --chainid dev --remote localhost:26657\n```\n\n### Publish the \"gno.land/r/demo/boards\" realm package.\n\n```bash\n./build/gnokey maketx addpkg test1 --pkgpath \"gno.land/r/demo/boards\" --pkgdir \"examples/gno.land/r/demo/boards\" --deposit 100000000ugnot --gas-fee 1000000ugnot --gas-wanted 300000000 --broadcast true --chainid dev --remote localhost:26657\n```\n"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"
            },
            "signature": "sHjOGXZEi9wt2FSXFHmkDDoVQyepvFHKRDDU0zgedHYnCYPx5/YndyihsDD5Y2Z7/RgNYBh4JlJwDMGFNStzBQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq",
            "send": "",
            "pkg_path": "gno.land/r/gnoland/blog",
            "func": "ModAddPost",
            "args": [
              "post1",
              "First post",
              "Lorem Ipsum",
              "tag1,tag2"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"
            },
            "signature": "sHjOGXZEi9wt2FSXFHmkDDoVQyepvFHKRDDU0zgedHYnCYPx5/YndyihsDD5Y2Z7/RgNYBh4JlJwDMGFNStzBQ=="
          }
        ],
        "memo": ""
      },
      {
        "msg": [
          {
            "@type": "/vm.m_call",
            "caller": "g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq",
            "send": "",
            "pkg_path": "gno.land/r/gnoland/blog",
            "func": "ModAddPost",
            "args": [
              "post2",
              "Second post",
              "Lorem Ipsum",
              "tag1,tag3"
            ]
          }
        ],
        "fee": {
          "gas_wanted": "2000000",
          "gas_fee": "1000000ugnot"
        },
        "signatures": [
          {
            "pub_key": {
              "@type": "/tm.PubKeySecp256k1",
              "value": "AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"
            },
            "signature": "sHjOGXZEi9wt2FSXFHmkDDoVQyepvFHKRDDU0zgedHYnCYPx5/YndyihsDD5Y2Z7/RgNYBh4JlJwDMGFNStzBQ=="
          }
        ],
        "memo": ""
      }
    ]
  }
}