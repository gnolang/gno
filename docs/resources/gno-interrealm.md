# Interrealm Specification

_NOTE: Keep up to date with docs/resources/gnoland-whitepaper_

## Introduction

**Gno is the first multi-user general-purpose programming language.**

All of our programming languages to date are designed for a single programmer
user. All programming languages make the same assumption that there is only one
user -- the programmer, or program executor user. Whether written in C, C++,
Python, Java, Javascript, or Go, it is assumed that all of the dependencies of
the program are trusted. If there is a vulnerability in any of the dependencies
there is a vulnerability in the program; it is the job of the programmer or
program/product manager to ensure that the overall program is free of exploits.

When interacting with programs owned by another user (or process) various
techniques are used such as via IPC APIs often generated by tools like
Protobuf/GRPC; but such tools add extra complexity, additional surface area for
exploits, additional compute complexity, and do not benefit directly from the
language's native rules and type-checker--especially for inter-process passing
of in-memory object references.

Gno is a minimal extension of the Go language for multi-user programmin with
interrealm syntax and rules. Gno allows a massive number of programmers to
iteratively and interactively develop a single shared program such as Gno.land.
In other words, Go is a restricted subset of the Gno language in the
single-user context.

Some of these interrealm rules can be checked during the static preprocessor
type-checking phase but others are checked at runtime with guards.

### Interrealm Programming Context

Gno.land supports three types of packages:
- **Realms (`/r/`)**: Stateful user applications (smart contracts) that
  maintain persistent state between transactions
- **Pure Packages (`/p/`)**: Stateless libraries that provide reusable 
  functionality
- **Ephemeral Packages (`/e/`)**: Temporary code execution with MsgRun
  which allows a custom main() function to be run instead of a single
  function call as with MsgExec.

For an overview of the different package types in Gno (`/p/`, `/r/`, and 
`/e/`), see [Anatomy of a Gno Package](../builders/anatomy-of-a-gno-package.md).

Interrealm programming refers to the ability of one realm to call functions 
in another realm. This can occur between:
- Regular realms (`/r/`) calling other regular realms via MsgExec and MsgRun.
- Ephemeral realms (`/e/`) calling regular realms via MsgRun (like main.go)

The key concept is that code executing in one realm-context can interact with 
and call functions in other realms, enabling complex multi-user interactions 
while maintaining clear boundaries and permissions.

The Gno language is extended to support a `context.Context`-like argument
to denote the current realm-context of a Gno function. This allows a user
realm function to call itself safely as if it were being called by an external user,
and helps avoid a class of security issues that would otherwise exist.

All logic in Gno execute under a current realm-context and
realm-storage-context. The realm-context and realm-storage-context refer to the
same realm-storage after a crossing-call of a function or method, but they may
diverge when calling a non-crossing method of a real object residing in a
different realm than the current realm-context.

### Realm-Storage Write Access

Every object in Gno is persisted in disk with additional metadata including the
object ID and an optional OwnerID (if persisted with a ref-count of exactly 1).
The object ID is only set at the end of a realm-transaction during
realm-transaction finalization (more on that later). A GnoVM transaction is
composed of one or many scoped (stacked) realm-transactions.

```go
type ObjectInfo struct {
	ID       ObjectID  // set if real.
	Hash     ValueHash `json:",omitempty"` // zero if dirty.
	OwnerID  ObjectID  `json:",omitempty"` // parent in the ownership tree.
	ModTime  uint64    // time last updated.
	RefCount int       // for persistence. deleted/gc'd if 0.

	// Object has multiple references (refcount > 1) and is persisted separately
	IsEscaped bool `json:",omitempty"` // hash in iavl.
    ...
}
```

When an object is persisted during realm-transaction finalization the object
becomes "real" (as in it is really persisted in the virtual machine state) and
is said to "reside" in the realm; and otherwise is considered "unreal". New
objects instantiated during a transaction are always unreal; and during
finalization such objects are either discarded (transaction-level garbage
collected) or become persisted and real.

Unreal (new) objects that become referenced by a real (persisted) object at
runtime will get their OwnerID set to the parent object's storage realm, but
will not yet have its object ID set before realm-transaction finalization.
Subsequent references at runtime of such an unreal object by real objects
residing in other realms do not override the OwnerID intially set, so during
realm-transaction finalization it ends up residing in the first realm it became
associated with (referenced from). Unreal objects that become persisted but was
never directly referenced by any real object during runtime will only get its
OwnerID set to the realm of the first real ancestor.

Real objects with ref-count of 1 have their hash included in the sole parent
object's serialized byte form, thus an object tree of only ref-count 1
descendants are Merkle-hashed completely.

When a real or unreal object ends up with a ref-count of 2 or greater during
realm-transaction finalization its OwnerID is set to zero and the object is
considered to have "escaped". When such a real object is persisted with
ref-count of 2 or greater it is forever considered escaped even if its
ref-count is in later transactions is reduced to 1. Escaped real objects do not
have their hash included in the parent objects' serialized byte form but
instead are Merkle-ized separately in an iavl tree of escaped object hashes
(keyed by the escaped object's ID) for each realm package. (This is implemented
as a stub but not yet implemented for the initial release of Gno.land)

Go's language rules for value access through dot-selectors & index-expressions
are the same within the same realm, but exposed values through dot-selector &
index-expressions are tainted read-only when performed by external realm logic.

**A real object can only be directly mutated through dot-selectors and
index-expressions if the object resides in the same realm as the current
realm-storage-context. Unreal objects can always be directly mutated if its
elements are directly exposed.**

### Crossing-Functions and Crossing-Methods

A crossing-function or crossing-method is that which is declared in a realm and
has as its first argument `cur realm`. The `cur realm` argument must appear as
the first argument of a crossing-function or crossing-method's argument
parameter list. To prevent confusion it is illegal to use anywhere else, and
cannot be used in p packages. 

The current realm-context and realm-storage-context changes when a
crossing-function or crossing-method is called with the `cross` keyword in the
first argument as in `fn(cross, ...)`. Such a call is called a "cross-call" or
"crossing-call".

```go
package main
import "gno.land/r/alice/extrealm"

func MyMakeBread(cur realm, ingredients ...any) { ... }

func main(cur realm) {
    MyMakeBread(cross, "flour", "water") // ok -- cross into self.
    extrealm.MakeBread(cross, "flour", "water") // ok -- cross into extrealm
}
```

(In Linux/Unix operating systems user processes can cross-call into the kernel
by calling special syscall functions, but user processes cannot directly
cross-call into other users' processes. This makes the GnoVM a more complete
multi-user operating system than traditional operating systems.)

When a crossing-function or crossing-method is called with `nil` as the first
argument instead of `cross` it is called a non-crossing-call; and no
realm-context nor realm-storage-context changes takes place.

```go
package main
import "gno.land/r/alice/extrealm"

func MyMakeBread(cur realm, ingredients ...any) { ... }

func main(cur realm) {
    MyMakeBread(nil, "flour", "water") // ok -- non-crossing.
    extrealm.MakeBread(nil, "flour", "water") // invalid -- external realm function
}
```

To prevent confusion a non-crossing-call of a crossing-function or
crossing-method declared in a realm different than that of the caller's
realm-context and realm-storage-context will result in either a type-check
error; or a runtime error if the crossing-function or crossing-method is
variable.

`runtime.CurrentRealm()` returns the current realm-context that was last
cross-called to. `runtime.PreviousRealm()` returns the realm-context cross-called
to before the last cross-call. All cross-calls are explicit with the `cross`
keyword, as well as non-crossing-calls of crossing-functions and
crossing-methods with `nil` instead of `cross`.

Besides (explicit) realm-context changes via the `fn(cross, ...)` cross-call
syntax, implicit realm-storage-context changes occurs when calling a
non-crossing method of a receiver object residing in different realm-storage.
This change in realm-storage-context allows any non-crossing method to directly
modify its receiver (and also any objects directly reachable and residing in
the same realm-storage) without changing the realm-context (so
`runtime.CurrentRealm()` and `runtime.PreviousRealm()` do not change; the
agency of the caller remains the same). This allows non-crossing methods of
receivers to behave the same whether declared in a realm package or p package
such that p package code copied over to a realm package r realm package code
copied over to another realm have the exact same behavior. Crossing methods of
a realm package would still behave differently when copied over to another
realm as crossing-methods always change the realm-context and
realm-storage-context to the declared realm.

If the receiver resides in realm-storage that differs from the caller's
realm-storage-context such a receiver's non-crossing method cannot directly
modify the receiver (nor any reachable object that resides in any realm-storage
besides that of the caller's own realm-storage-context). 

On the other hand if the method is a crossing-method as in
`receiver.Method(cross, args...)` and the method is cross-called both the
realm-context and realm-storage-context changes to that of the realm package in
which the type/method is declared (which is not necessarily the same as where
the receiver resides). Such a crossing method-call cannot directly modify the
real receiver if it happens to reside in an external realm that differs from
where the type and methods are declared; but it can modify any unreal receiver
or unreal reachable objects. As mentioned previously a non-crossing-call of a
crossing-method will fail at during type-checking or at runtime if the receiver
resides in an external realm-storage.

MsgCall can only call crossing-functions.

MsgRun will run a file's `main()` function in the user's realm-context and may
call both crossing and non-crossing functions and methods.

A realm package's initialization (including `init()` calls) executes with
current realm-context of itself, and its `runtime.PreviousRealm()` will panic
unless the call stack includes a crossing function called like `fn(cross,
...)`.

### Realm Boundaries

The current and previous runtime realm-context have an associated Gno address
from which native coins can be sent from and received to. Such native coins can
only be sent from a banker instantiated with either realm-context.  The
realm-storage-context is not accessible at runtime and so there is no
associated Gno address.

When a crossing-function or crossing-method is cross-called it shifts the
"current" runtime realm-context to the "previous" runtime realm-context such
that `runtime.PreviousRealm()` returns what used to be returned with
`runtime.CurrentRealm()` before the realm boundary. The current
realm-storage-context is always set to that of realm-context after
cross-calling.

Every crossing-call of a crossing-function or crossing-method creates a new
realm boundary even when there is no resulting change/shift in realm-context or
realm-storage-context.

A realm boundary also exists for every call that results in a change of
realm-storage-context: whether with a crossing-call to another realm-context
and realm-storage context or with a (non-crossing) call of a non-crossing
method of a real receiver residing in another realm-storage than the current
realm-storage-context. No realm boundary occurs when calling a non-crossing
method of an unreal receiver or a non-crossing function.

A realm boundary does not always change the realm-context nor always change the
realm-storage-context. A crossing-call into the same realm-context never
changes the realm-context and may not change the realm-storage-context either;
a crossing-call into a different realm always changes the realm-context but may
not change the realm-storage-context; a (non-crossing) call of a method of a
real object residing in an external realm-storage never changes the
realm-context but changes the realm-storage-context. However, a
non-crossing-call of a crossing-function or crossing-method will never create a
realm boundary.

No realm boundary is created for non-crossing functions and non-crossing
methods of unreal receivers.

### Realm-Transaction Finalization

Realm-transaction finalization occurs when returning from a realm
boundary. When returning from a cross-call (with `cross`) realm-transaction
finalization will occur even with no change of realm-context or
realm-storage-context. Realm-transaction finalization does NOT occur when
returning from a non-crossing-call of a method of an unreal receiver or a real
receiver that resides in the same realm-storage-context as that of the caller.

During realm-transaction finalization all new reachable objects are assigned
object IDs and stored in the current realm-storage-context; and ref-count-zero
objects deleted (full "disk-persistent cycle GC" will come after launch); and
any modified ref-counts and new Merkle hash root computed. 

### Readonly Taint Specification

Go's language rules for value access through dot-selectors & index-expressions
are the same within the same realm, but exposed values through dot-selector &
index-expressions are tainted read-only when performed by an external realm.

The readonly taint prevents the direct modification of real objects by any
logic, even from logic declared in the same realm as that of the object's
storage-realm.

A realm cannot directly modify another realm's objects without calling a
function that gives permission for the modification to occur.

For example `externalrealm.Foo` is a dot-selector expression on an external
object (package) so the value is tainted with the `N_Readonly` attribute.

The same is true for `externalobject.FieldA` where `externalobject` resides in
an external realm.

The same is true for `externalobject[0]`: direct index expressions also taint
the resulting value with the `N_Readonly` attribute. 

The same is true for `externalobject.FieldA.FieldB[0]`: the readonly taint
persists for any subsequent direct access, so even if FieldA or FieldB resided in
the caller's own realm-context or realm-storage the result is tainted readonly.

A Gno package's global variables even when exposed (e.g. `package realm1; var
MyGlobal int = 1`) are safe from external manipulation (e.g. `import
"xxx/realm1"; realm1.MyGlobal = 2`) by the readonly taint when accessed
directly by dot-selector or index-expression from external realm logic; and
also by a separate `DidUpdate()` guard when accessed by other means such as by
return value of a function and the return value is real and external.

A function or method's arguments and return values retain and pass through any
readonly taint from caller to callee. Even if realm's function (or method)
returns an untainted real object, the runtime guard in `DidUpdate()` prevents
it from being modified by an external realm-storage-context.

For a realm (user) to manipulate an untainted object residing in an external
realm, a function (or method) can be declared in the external realm which
references and modifies the aforementioned untainted object directly (by a name
declared outside of the scope of said function or method). Or, the function can
take in as argument an untainted real object returned by another function.

Besides protecting against writing by direct access, the readonly taint also
helps prevent a class of security issue where a realm may be tricked into
modifying something that it otherwise would not want to modify. Since the
readonly taint prohibits mutations even from logic declared in the same realm,
it protects realms against mutating its own object that it doesn't intend to:
such as when a realm's real object is passed as an argument to a mutator
function where the object happens to match the type of the argument.

Objects returned from functions or methods are not readonly tainted. So if
`func (eo object) GetA() any { return eo.FieldA }` then `externalobject.GetA()`
returns an object that is not tainted assuming eo.FieldA was not otherwise
tainted. While the parent object `eo` is still protected from direct
modification by external realm logic, the returned object from `GetA()` can be
passed as an argument to logic declared in the residing realm of `eo.FieldA`
for direct mutation.

Whether or not an object is readonly tainted it can always be mutated by a
method declared on the receiver.

```go
// /r/alice

var blacklist []string

func GetBlacklist() []string {
    return blacklist
}

func FilterList(cur realm, testlist []string) { // blanks out blacklist items from testlist
    for i, item := range testlist {
        if contains(blacklist, item) {
            testlist[i] = ""
        }
    }
}
```

This is a toy example, but you can see that the intent of `FilterList()` is to
modify an externally provided slice; yet if you call `alice.FilterList(cross,
alice.GetBlacklist())` you can trick alice into modifying its own blacklist--the
result is that alice.BlackList becomes full of blank values.

With the readonly taint `var Blacklist []string` solves the problem for you;
that is, /r/bob cannot successfully call `alice.FilterList(cross,
alice.Blacklist)` because `alice.Blacklist` is readonly tainted for bob.

The problem remains if alice implements `func GetBlacklist() []string { return
Blacklist }` since then /r/bob can call `alice.FilterList(cross,
alice.GetBlacklist())` and the argument is not readonly tainted.

Future versions of Gno may also expose a new modifier keyword `readonly` to
allow for return values of functions to be tainted as readonly. Then with `func
GetBlacklist() readonly []string` the return value would be readonly tainted
for both bob and alice.

### Interrealm Specification Design Goals

P package code should behave the same even when copied verbatim in a realm
package; and likewise non-crossing code should behave the same when copied
verbatim from one realm to another. Otherwise there will be lots of security
related bugs from user error.

Realm crossing with respect to `runtime.CurrentRealm()` and
`runtime.PreviousRealm()` must be explicit and warrants type-checking; because
a crossing-function of a realm should be able to call another crossing-function
of the same realm without necessarily crossing (changing the realm-context).
Sometimes the previous realm and current realm must be the same realm, such as
when a realm consumes a service that it offers to external realms and users.

Where a real object resides should not matter too much, as it is often
difficult to predict. Thus the realm-context as returned by
`runtime.PreviousRealm()` and `runtime.CurrentRealm()` should not change with
non-crossing method calls, and the realm-storage-context should be determined
for non-crossing methods only by the realm-storage of the receiver. The
realm-storage of a receiver should only matter for when elements reside in
external realm-storage and direct dot-selector or index-expression access of
sub-elements are desired of the aforementioned element.

A method should be able to modify the receiver and associated objects of the
same realm-storage as that of the receiver.

A method should be able to create new objects that reside in the same realm by
association in order to maintain storage realm consistency and encapsulation
and reduce fragmentation.

It is difficult to migrate an object form one realm to another even when its
ref-count is 1; such an object may be deep with many descendants of ref-count 1
and so performance is unpredictable.

Code declared in p packages (or declared in "immutable" realm packages) can
help different realms enforce contracts trustlessly, even those that involve
the caller's current realm. Otherwise two mutable (upgradeable) realms cannot
export trust unto the chain because functions declared in those two realms can
be upgraded.

Both `fn(cross, ...)` and `func fn(cur realm, ...){...}` may become special
syntax in future Gno versions.

### `panic()` and `revive(fn)`

`panic()` behaves the same within the same realm boundary, but when a panic
crosses a realm boundary (as defined in [Realm
Boundries](#realm-boundaries)) the Machine aborts the program. This is
because in a multi-user environment it isn't safe to let the caller recover from
realm panics that often leave the state in an invalid state.

This would be sufficient, but we also want to write our tests to be able
to detect such aborts and make assertions. For this reason Gno provides
the `revive(fn)` builtin.

```go
abort := revive(func() {
    cross(func(_ realm) {
        panic("cross-realm panic")
    })
})
abort == "cross-realm panic"
```

`revive(fn)` will execute 'fn' and return the exception that crossed a realm
boundary during finalization.

This is only enabled in testing mode (for now), behavior is only partially
implemented. In the future `revive(fn)` will be available for non-testing code,
and the behavior will change such that `fn()` is run in transactional
(cache-wrapped) memory context and any mutations discarded if and only if there
was an abort.

TL;DR: `revive(fn)` is Gno's builtin for STM (software transactional memory).

### `attach()`

In future releases of Gno the `attach()` function can be used to associate
unreal objects to the current realm-storage-context before being passed into
function declared in an external realm package, or into a method of a real
receiver residing in an exteral realm-context.

## Application

P package code cannot contain crossing functions. P package code also cannot
import R realm packages. But p package code can cross-call crossing functions
such as those passed in as an argument.

You must declare a public realm function to be a crossing function if it is
intended to be called by end users, because users cannot MsgCall non-crossing
functions (for safety/consistency) or p package functions (stateless).

Utility functions that are a common sequence of non-crossing logic can be
offered in realm packages as non-crossing functions. These can also import and
use other realm utility non-crossing functions; whereas p packages cannot
import realm packages at all. And convenience/utility functions that are being
staged before publishing as permanent p code should also reside in upgradeable
realms.

Generally you want your methods to be non-crossing for portability. They are
bound to the realm-storage of the receiver object (if real), and that object is
like a standalone realm unto itself in that they could be referenced from
external realms. This is consistent with any p code copied over to r realms;
none of those methods can be crossing, and behavior would be the same whether
residing in one realm or another. A real object is NOT like a realm unto itself
in that if it references another object residing in the same realm-storage a
method of the former object can directly mutate the latter object.

You can always cross-call a method from a non-crossing method if you need it.

Implementation for `runtime.CurrentRealm()` and `runtime.PreviousRealm()` are
defined in `stdlibs/std/native.gno/go` and related files in the directory,
while overrides for testing are defined in `testing/stdlibs/std/std.gno/go`.
All stdlibs functions are available unless overridden by the latter.

### MsgCall

MsgCall may only call crossing functions. This is to prevent potential
confusion for non-sophisticated users. Non-crossing calls of non-crossing
functions of other realms is still possible with MsgRun.

```go
// PKGPATH: gno.land/r/test/test

func Public(_ realm) {

    // Returns (
    //     addr:<origin_caller>,
    //     pkgpath:""
    // ) == std.NewUserRealm(origin_caller)
    runtime.PreviousRealm()

    // Returns (
    //     addr:<derived_from "gno.land/r/test/test">,
    //     pkgpath:"gno.land/r/test/test"
    // ) == std.NewCodeRealm("gno.land/r/test/test")
    runtime.CurrentRealm()

    // Call a crossing function of same realm with crossing
    AnotherPublic(cross)

    // Call a crossing function of same realm without crossing
    AnotherPublic(cur)
}

func AnotherPublic(_ realm) {
    ...
}
```

### MsgRun

```go
// PKGPATH: gno.land/e/g1user/run

import "gno.land/r/realmA"

func main() {
    // There is assumed to be in "frame -1"
    // a crossing from UserRealm(g1user) to
    // CodeRealm(gno.land/e/g1user/run) before
    // main() is called, so crossing() here
    // is redundant.
    // crossing()

    // Returns (
    //     addr:g1user,
    //     pkgpath:""
    // ) == std.NewUserRealm(g1user)
    runtime.PreviousRealm()

    // Returns (
    //     addr:g1user,
    //     pkgpath:"gno.land/e/g1user/run"
    // ) == std.NewUserRealm(g1user, "gno.land/e/g1user/run")
    runtime.CurrentRealm()

    realmA.PublicNoncrossing()
    realmA.PublicCrossing(cross)
}
```

Notice in `gnovm/pkg/gnolang/misc.go`, the following:

```go
// For keeping record of package & realm coins.
// If you need the bech32 address it is faster to call DerivePkgBech32Addr().
func DerivePkgCryptoAddr(pkgPath string) crypto.Address {
	b32addr, ok := IsGnoRunPath(pkgPath)
	if ok {
		addr, err := crypto.AddressFromBech32(b32addr)
		if err != nil {
			panic("invalid bech32 address in run path: " + pkgPath)
		}
		return addr
	}
	// NOTE: must not collide with pubkey addrs.
	return crypto.AddressFromPreimage([]byte("pkgPath:" + pkgPath))
}

func DerivePkgBech32Addr(pkgPath string) crypto.Bech32Address {
	b32addr, ok := IsGnoRunPath(pkgPath)
	if ok {
		return crypto.Bech32Address(b32addr)
	}
	// NOTE: must not collide with pubkey addrs.
	return crypto.AddressFromPreimage([]byte("pkgPath:" + pkgPath)).Bech32()
}
```

These function names are distinct from what is available in Gno
from `stdlibs/std/crypto.gno`:

```go
// Returns a crypto hash derived pkgPath, unless pkgPath is a MsgRun run path,
// in which case the address is extracted from the path.
func DerivePkgAddr(pkgPath string) Address {
	addr := derivePkgAddr(pkgPath) <-- calls gno.DerivePkgBech32Addr()
	return Address(addr)
}
```

1. `std.DerivePkgAddr("gno.land/r/name123/realm")` - bech32 from hash(path)
2. `std.DerivePkgAddr("gno.land/e/g1user/run")` - bech32 substring "g1user"

Therefore in the MsgRun file's `init()` function the previous realm and current
realm have different pkgpaths (the origin caller always has empty pkgpath) but
the address is the same.

### MsgAddPackage

During MsgAddPackage `runtime.PreviousRealm()` refers to the package deployer both
in global var decls and inside `init()` functions. After that the package
deployer is no longer provided, so packages need to remember the deployer in
the initialization phase if needed.

```go
// PKGPATH: gno.land/r/test/test

func init() {
    // Returns (
    //     addr:<origin_deployer>,
    //     pkgpath:""
    // ) == std.NewUserRealm(origin_deployer)
    // Inside init() and global var decls
    // are the only time runtime.PreviousRealm()
    // returns the deployer of the package.
    // Save it here or lose it forever.
    runtime.PreviousRealm()

    // Returns (
    //     addr:<origin_deployer>,
    //     pkgpath:"gno.land/r/test/test"
    // ) == std.NewCodeRealm("gno.land/r/test/test")
    runtime.CurrentRealm()
}

// Same as in init().
var _ = runtime.PreviousRealm()
```

```go
// PKGPATH: gno.land/e/g1user/run

func init() {
    // Returns (
    //     addr:g1user,
    //     pkgpath:""
    // ) == std.NewUserRealm(g1user)
    runtime.PreviousRealm()

    // Returns (
    //     addr:g1user,
    //     pkgpath:"gno.land/e/g1user/run"
    // ) == std.NewCodeRealm("gno.land/e/g1user/run")
    runtime.CurrentRealm()
}
```

The same applies for pure package (`/p/`) initialization. During initialization 
and tests, `runtime.CurrentRealm()` can return a package path that starts with 
"/p/". This is because the package is technically still mutable during its 
initialization phase. After initialization, pure packages become immutable and 
cannot maintain state.

## Future Work

`std.SetOriginCaller()` should maybe be deprecated in favor of
`std.SetRealm(std.NewUserRealm(user))` renamed to
`std.SetRealm(std.NewOriginRealm(user))`.

`std.SetRealm(std.NewCodeRealm(path))` renamed to
`std.SetRealm(std.NewPackageRealm(path))`.

-------

## Appendix

### Testing overrides with stdlibs/testing

The `gnovm/tests/stdlibs/testing/context_testing.gno` file provides functions
for overriding frame details from Gno test code.

`testing.SetRealm(std.NewUserRealm("g1user"))` is identical to
`testing.SetOriginCaller("g1user")`. Both will override the Gno frame to make it
appear as if the current frame is the end user signing with a hardware signer.
Both will also set `ExecContext.OriginCaller` to that user. One of these will
become deprecated.

#### Gno test cases with `_test.gno` like `TestFoo(t *testing.T)`

```go
// PKGPATH: gno.land/r/user/myrealm
package myrealm

import (
    "std"
    "testing"
)

func TestFoo(t *testing.T) {
    // At first OriginCaller is not set.

    // Override the OriginCaller.
    testing.SetRealm(std.NewUserRealm("g1user"))

    // Identical behavior:
    testing.SetOriginCaller("g1user")

    // This panics now: seeking beyond the overridden origin frame:
    // runtime.PreviousRealm()

    // Simulate g1user cross-calling Public().
    // Produce a new frame to override
    func() {
        testing.SetRealm(std.SetCodeRealm("gno.land/r/user/myrealm"))

        runtime.PreviousRealm() // "g1user", ""
        runtime.CurrentRealm()  // bech32(hash("gno.land/r/user/myrealm")), "gno.land/r/user/myrealm"

        Public(...) // already in "gno.land/r/user/myrealm"
    }()

    // The following is identical to the above,
    // but not possible in p packages which
    // cannot import realms.
    cross(Public)(...)
}
```

#### Gno filetest cases with `_filetest.gno`

```go
// PKGPATH: gno.land/r/test/test
package test

import (
    "std"
    "stdlibs/testing"

    "gno.land/r/user/myrealm"
)

func init() {
    // XXX Frame not found, there is no deployer for filetests.
    runtime.PreviousRealm()

    // Returns (
    //     addr:std.DerivePkgAddr("gno.land/r/test/test")
    //     pkgpath:"gno.land/r/test/test"
    // ) == std.NewCodeRealm("gno.land/r/test/test")
    runtime.CurrentRealm()
}

func main() {
    // There is assumed to be in "frame -1"
    // a crossing from UserRealm(g1user) to
    // CodeRealm("gno.land/r/test/test") before
    // main() is called, so crossing() here
    // is redundant.

    // Returns (
    //     addr:g1user,
    //     pkgpath:""
    // ) == std.NewUserRealm(g1user)
    runtime.PreviousRealm()

    // Returns (
    //     addr:g1user,
    //     pkgpath:"gno.land/r/test/test"
    // ) == std.NewCodeRealm("gno.land/r/test/test")
    runtime.CurrentRealm()

    // gno.land/r/test/test cross-calling
    // gno.land/r/user/myrealm:
    cross(myrealm.Public)(...)
}

// Output:
// XXX
```
