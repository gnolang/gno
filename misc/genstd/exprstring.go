// Forked from go/types (go 1.20.3) to implement support for *linkedIdent.
// It cannot be easily split from the original as WriteExpr is highly recursive.

// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements printing of expressions.

package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/types"
)

const (
	printerModeGoQualified = iota
	printerModeGnoType
)

type exprPrinter struct {
	mode int
}

// ExprString returns the (possibly shortened) string representation for x.
// Shortened representations are suitable for user interfaces but may not
// necessarily follow Go syntax.
//
// ExprString is identical to [types.ExprString] with the difference that it
// supports *linkedIdent.
func (ep *exprPrinter) ExprString(x ast.Expr) string {
	var buf bytes.Buffer
	ep.WriteExpr(&buf, x)
	return buf.String()
}

// WriteExpr writes the (possibly shortened) string representation for x to buf.
// Shortened representations are suitable for user interfaces but may not
// necessarily follow Go syntax.
//
// WriteExpr is identical to [types.WriteExpr] with the difference that it
// supports *linkedIdent.
func (ep *exprPrinter) WriteExpr(buf *bytes.Buffer, x ast.Expr) {
	// The AST preserves source-level parentheses so there is
	// no need to introduce them here to correct for different
	// operator precedences. (This assumes that the AST was
	// generated by a Go parser.)

	switch x := x.(type) {
	default:
		// fallback to go original -- for all non-recursive ast.Expr types
		types.WriteExpr(buf, x)

	case *linkedIdent:
		switch ep.mode {
		case printerModeGoQualified:
			n := pkgNameFromPath(x.lt.goPackage)
			buf.WriteString(n)
			buf.WriteByte('.')
			buf.WriteString(x.lt.goName)
		case printerModeGnoType:
			buf.WriteString(x.lt.gnoName)
		default:
			panic(fmt.Errorf("invalid mode %d", ep.mode))
		}

	case *ast.Ellipsis:
		buf.WriteString("...")
		if x.Elt != nil {
			ep.WriteExpr(buf, x.Elt)
		}

	case *ast.FuncLit:
		buf.WriteByte('(')
		ep.WriteExpr(buf, x.Type)
		buf.WriteString(" literal)") // shortened

	case *ast.CompositeLit:
		ep.WriteExpr(buf, x.Type)
		buf.WriteByte('{')
		if len(x.Elts) > 0 {
			buf.WriteString("â€¦")
		}
		buf.WriteByte('}')

	case *ast.ParenExpr:
		buf.WriteByte('(')
		ep.WriteExpr(buf, x.X)
		buf.WriteByte(')')

	case *ast.SelectorExpr:
		ep.WriteExpr(buf, x.X)
		buf.WriteByte('.')
		buf.WriteString(x.Sel.Name)

	case *ast.IndexExpr, *ast.IndexListExpr:
		ix := tpUnpackIndexExpr(x)
		ep.WriteExpr(buf, ix.X)
		buf.WriteByte('[')
		ep.writeExprList(buf, ix.Indices)
		buf.WriteByte(']')

	case *ast.SliceExpr:
		ep.WriteExpr(buf, x.X)
		buf.WriteByte('[')
		if x.Low != nil {
			ep.WriteExpr(buf, x.Low)
		}
		buf.WriteByte(':')
		if x.High != nil {
			ep.WriteExpr(buf, x.High)
		}
		if x.Slice3 {
			buf.WriteByte(':')
			if x.Max != nil {
				ep.WriteExpr(buf, x.Max)
			}
		}
		buf.WriteByte(']')

	case *ast.TypeAssertExpr:
		ep.WriteExpr(buf, x.X)
		buf.WriteString(".(")
		ep.WriteExpr(buf, x.Type)
		buf.WriteByte(')')

	case *ast.CallExpr:
		ep.WriteExpr(buf, x.Fun)
		buf.WriteByte('(')
		ep.writeExprList(buf, x.Args)
		if x.Ellipsis.IsValid() {
			buf.WriteString("...")
		}
		buf.WriteByte(')')

	case *ast.StarExpr:
		buf.WriteByte('*')
		ep.WriteExpr(buf, x.X)

	case *ast.UnaryExpr:
		buf.WriteString(x.Op.String())
		ep.WriteExpr(buf, x.X)

	case *ast.BinaryExpr:
		ep.WriteExpr(buf, x.X)
		buf.WriteByte(' ')
		buf.WriteString(x.Op.String())
		buf.WriteByte(' ')
		ep.WriteExpr(buf, x.Y)

	case *ast.ArrayType:
		buf.WriteByte('[')
		if x.Len != nil {
			ep.WriteExpr(buf, x.Len)
		}
		buf.WriteByte(']')
		ep.WriteExpr(buf, x.Elt)

	case *ast.StructType:
		buf.WriteString("struct{")
		ep.writeFieldList(buf, x.Fields.List, "; ", false)
		buf.WriteByte('}')

	case *ast.FuncType:
		buf.WriteString("func")
		ep.writeSigExpr(buf, x)

	case *ast.InterfaceType:
		buf.WriteString("interface{")
		ep.writeFieldList(buf, x.Methods.List, "; ", true)
		buf.WriteByte('}')

	case *ast.MapType:
		buf.WriteString("map[")
		ep.WriteExpr(buf, x.Key)
		buf.WriteByte(']')
		ep.WriteExpr(buf, x.Value)

	case *ast.ChanType:
		var s string
		switch x.Dir {
		case ast.SEND:
			s = "chan<- "
		case ast.RECV:
			s = "<-chan "
		default:
			s = "chan "
		}
		buf.WriteString(s)
		ep.WriteExpr(buf, x.Value)
	}
}

func (ep *exprPrinter) writeSigExpr(buf *bytes.Buffer, sig *ast.FuncType) {
	buf.WriteByte('(')
	ep.writeFieldList(buf, sig.Params.List, ", ", false)
	buf.WriteByte(')')

	res := sig.Results
	n := res.NumFields()
	if n == 0 {
		// no result
		return
	}

	buf.WriteByte(' ')
	if n == 1 && len(res.List[0].Names) == 0 {
		// single unnamed result
		ep.WriteExpr(buf, res.List[0].Type)
		return
	}

	// multiple or named result(s)
	buf.WriteByte('(')
	ep.writeFieldList(buf, res.List, ", ", false)
	buf.WriteByte(')')
}

func (ep *exprPrinter) writeFieldList(buf *bytes.Buffer, list []*ast.Field, sep string, iface bool) {
	for i, f := range list {
		if i > 0 {
			buf.WriteString(sep)
		}

		// field list names
		ep.writeIdentList(buf, f.Names)

		// types of interface methods consist of signatures only
		if sig, _ := f.Type.(*ast.FuncType); sig != nil && iface {
			ep.writeSigExpr(buf, sig)
			continue
		}

		// named fields are separated with a blank from the field type
		if len(f.Names) > 0 {
			buf.WriteByte(' ')
		}

		ep.WriteExpr(buf, f.Type)

		// ignore tag
	}
}

func (ep *exprPrinter) writeIdentList(buf *bytes.Buffer, list []*ast.Ident) {
	for i, x := range list {
		if i > 0 {
			buf.WriteString(", ")
		}
		buf.WriteString(x.Name)
	}
}

func (ep *exprPrinter) writeExprList(buf *bytes.Buffer, list []ast.Expr) {
	for i, x := range list {
		if i > 0 {
			buf.WriteString(", ")
		}
		ep.WriteExpr(buf, x)
	}
}

// The following are copied from go/internal/typeparams.
// We cannot use the original directly as it comes from an "internal" package.

// tpIndexExpr wraps an ast.IndexExpr or ast.IndexListExpr.
//
// Orig holds the original ast.Expr from which this IndexExpr was derived.
type tpIndexExpr struct {
	Orig ast.Expr // the wrapped expr, which may be distinct from the IndexListExpr below.
	*ast.IndexListExpr
}

func tpUnpackIndexExpr(n ast.Node) *tpIndexExpr {
	switch e := n.(type) {
	case *ast.IndexExpr:
		return &tpIndexExpr{e, &ast.IndexListExpr{
			X:       e.X,
			Lbrack:  e.Lbrack,
			Indices: []ast.Expr{e.Index},
			Rbrack:  e.Rbrack,
		}}
	case *ast.IndexListExpr:
		return &tpIndexExpr{e, e}
	}
	return nil
}
