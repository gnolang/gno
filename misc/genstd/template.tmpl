// This file is autogenerated from the genstd tool (@/misc/genstd); do not edit.
// To regenerate it, run `go generate` from this directory.

package stdlibs

import (
	"reflect"

	gno "github.com/gnolang/gno/gnovm/pkg/gnolang"
{{- range .Imports }}
	{{ .Name }} {{ printf "%q" .Path }}
{{- end }}
)

// NativeFunc represents a function in the standard library which has a native
// (go-based) implementation, commonly referred to as a "native binding".
type NativeFunc struct {
	gnoPkg     string
	gnoFunc    gno.Name
	params     []gno.FieldTypeExpr
	results    []gno.FieldTypeExpr
	hasMachine bool
	f          func(m *gno.Machine)
}

// HasMachineParam returns whether the given native binding has a machine parameter.
// This means that the Go version of this function expects a *gno.Machine
// as its first parameter.
func (n *NativeFunc) HasMachineParam() bool {
	return n.hasMachine
}

var nativeFuncs = [...]NativeFunc{
{{- range $i, $m := .Mappings }}
	{
		{{ printf "%q" $m.GnoImportPath }},
		{{ printf "%q" $m.GnoFunc }},
		{{- /* TODO: set nil if empty */}}
		[]gno.FieldTypeExpr{
		{{- range $i, $p := $m.Params }}
			{Name: gno.N("p{{ $i }}"), Type: gno.X({{ printf "%q" $p.GnoType }})},
		{{- end }}
		},
		[]gno.FieldTypeExpr{
		{{- range $i, $r := $m.Results }}
			{Name: gno.N("r{{ $i }}"), Type: gno.X({{ printf "%q" $r.GnoType }})},
		{{- end }}
		},
		{{ if $m.MachineParam }}true{{ else }}false{{ end }},
		func(m *gno.Machine) {
			{{ if $m.Params -}}
				b := m.LastBlock()
				var (
				{{- range $pn, $pv := $m.Params -}}
					{{- if $pv.IsTypedValue }}
						p{{ $pn }} = gno.NewValuePathBlock(1, {{ $pn }}, "")).TV
					{{- else }}
						p{{ $pn }} {{ $pv.GoQualifiedName }}
						rp{{ $pn }} = reflect.ValueOf(&p{{ $pn }}).Elem()
					{{- end }}
				{{- end }}
				)

				{{ range $pn, $pv := $m.Params -}}
					{{- if not $pv.IsTypedValue }}
						gno.Gno2GoValue(b.GetPointerTo(nil, gno.NewValuePathBlock(1, {{ $pn }}, "")).TV, rp{{ $pn }})
					{{- end -}}
				{{ end }}
			{{- end }}

			{{ range $rn, $rv := $m.Results -}}
				{{- if gt $rn 0 -}}, {{ end -}}
				r{{ $rn }}
			{{- end -}}
			{{- if $m.Results }} := {{ end -}}
			{{ $.PkgName $m.GoImportPath }}.{{ $m.GoFunc }}(
				{{- if $m.MachineParam }}
					m,
				{{ end -}}
				{{- range $pn, $pv := $m.Params -}}
					p{{ $pn }},
				{{- end -}}
			)

			{{ range $rn, $rv := $m.Results -}}
				{{- if $rv.IsTypedValue }}
					m.PushValue(r{{ $rn }})
				{{- else }}
					m.PushValue(gno.Go2GnoValue(
						m.Alloc,
						m.Store,
						reflect.ValueOf(&r{{ $rn }}).Elem(), {{- /* necessary to support interfaces (ie. error) */}}
					))
				{{- end }}
			{{- end }}
		},
	},
{{- end }}
}

var initOrder = [...]string{
{{- range .InitOrder }}
	{{ printf "%q" . }},
{{- end }}
}

// InitOrder returns the initialization order of the standard libraries.
// This is calculated starting from the list of all standard libraries and
// iterating through each: if a package depends on an unitialized package, that
// is processed first, and so on recursively; matching the behaviour of Go's
// [program initialization].
//
// [program initialization]: https://go.dev/ref/spec#Program_initialization
func InitOrder() []string {
	return initOrder[:]
}
