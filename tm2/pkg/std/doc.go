package std

import (
	"fmt"

	"github.com/gnolang/gno/tm2/pkg/amino"
	"github.com/gnolang/gno/tm2/pkg/crypto"
)

// SignDoc is the standard object for transactions.
// AccountNumber is a replay-prevention field for the whole account
// (eg. nonce) to prevent the replay of txs after an account has been deleted
// (due to zero balance). Sequence is a replay-prevention field for each transaction
// given a nonce
type SignDoc struct {
	ChainID       string `json:"chain_id" yaml:"chain_id"`
	AccountNumber uint64 `json:"account_number" yaml:"account_number"`
	Sequence      uint64 `json:"sequence" yaml:"sequence"`
	Fee           Fee    `json:"fee" yaml:"fee"`
	Msgs          []Msg  `json:"msgs" yaml:"msgs"`
	Memo          string `json:"memo" yaml:"memo"`
}

// GetSignaturePayload returns the sign payload for the SignDoc.
// The signature payload is generated by marshalling the SignDoc
// into Amino JSON, and then sorting the Amino JSON.
// Ultimately, the formula for signing is sign(sortJSON(aminoJSON(SignDoc)))
func GetSignaturePayload(s SignDoc) ([]byte, error) {
	// Prepare the amino JSON
	data, err := amino.MarshalJSON(s)
	if err != nil {
		return nil, fmt.Errorf("unable to marshal sign doc, %w", err)
	}

	// Sort the JSON
	sortedData, err := sortJSON(data)
	if err != nil {
		return nil, fmt.Errorf("unable to sort payload JSON, %w", err)
	}

	return sortedData, nil
}

// Signature represents a wrapped signature of a transaction
type Signature struct {
	PubKey    crypto.PubKey `json:"pub_key" yaml:"pub_key"` // optional
	Signature []byte        `json:"signature" yaml:"signature"`
}
