// Shim for Go's "testing" package to support minimal testing types.
package testing

import (
	"encoding/json"
	"fmt"
	"strings"
)

//----------------------------------------
// Top level functions

func Short() bool {
	return true // TODO configure somehow.
}

func Verbose() bool {
	return true // TODO configure somehow.
}

// Like AllocsPerRun() but returns an integer.
// TODO: actually compute allocations; for now return 0.
func AllocsPerRun2(runs int, f func()) (total int) {
	for i := 0; i < runs; i++ {
		f()
	}
	return 0
}

//----------------------------------------
// T

type T struct {
	name     string
	failed   bool
	finished bool
	output   []byte // Output generated by test
	verbose  bool
}

func NewT(name string) *T {
	return &T{name: name}
}

type testingFunc func(*T)

// Not yet implemented:
// func (t *T) Cleanup(f func()) {
// func (t *T) Deadline() (deadline time.Time, ok bool)
func (t *T) Error(args ...interface{}) {
	t.Log(args...)
	t.Fail()
}

func (t *T) Errorf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.Fail()
}

func (t *T) Fail() {
	t.failed = true
}

func (t *T) FailNow() {
	// TODO: maybe use panic to control flow. because can't use goroutine in gno now.
	t.Fail()
	t.finished = true
}

func (t *T) Failed() bool {
	return t.failed
}

func (t *T) Fatal(args ...interface{}) {
	t.Log(args...)
	t.FailNow()
}

func (t *T) Fatalf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.FailNow()
}

func (t *T) Log(args ...interface{}) {
	t.log(fmt.Sprintln(args...))
}

func (t *T) Logf(format string, args ...interface{}) {
	t.log(fmt.Sprintf(format, args...))
	t.log(fmt.Sprintln())
}

func (t *T) Name() string {
	return t.name
}

func (t *T) Parallel() {
	// does nothing.
}

func (t *T) Run(name string, f testingFunc) bool {
	panic("not yet implemented")
}

func (t *T) Setenv(key, value string) {
	panic("not yet implemented")
}

func (t *T) Skip(args ...interface{}) {
	t.Log(args...)
	t.SkipNow()
}

func (t *T) SkipNow() {
	panic("not yet implemented")
}

func (t *T) Skipped() bool {
	return false // todo:
}

func (t *T) Skipf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.SkipNow()
}

func (t *T) TempDir() string {
	panic("not yet implemented")
}

func (t *T) Helper() {
}

func (t *T) log(s string) {
	t.output = append(t.output, s...)
}

type Report struct {
	Name    string
	Verbose bool
	Failed  bool
	Skipped bool
	Output  string
}

func (t *T) report() Report {
	return Report{
		Name:    t.name,
		Verbose: t.verbose,
		Failed:  t.Failed(),
		Skipped: t.Skipped(),
		Output:  strings.TrimSpace(string(t.output)),
	}
}

//----------------------------------------
// B
// TODO: actually implement

type B struct {
	N int
}

func (b *B) Cleanup(f func())                          { panic("not yet implemented") }
func (b *B) Error(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Errorf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Fail()                                     { panic("not yet implemented") }
func (b *B) FailNow()                                  { panic("not yet implemented") }
func (b *B) Failed() bool                              { panic("not yet implemented") }
func (b *B) Fatal(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Fatalf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Helper()                                   { panic("not yet implemented") }
func (b *B) Log(args ...interface{})                   { panic("not yet implemented") }
func (b *B) Logf(format string, args ...interface{})   { panic("not yet implemented") }
func (b *B) Name() string                              { panic("not yet implemented") }
func (b *B) ReportAllocs()                             { panic("not yet implemented") }
func (b *B) ReportMetric(n float64, unit string)       { panic("not yet implemented") }
func (b *B) ResetTimer()                               { panic("not yet implemented") }
func (b *B) Run(name string, f func(b *B)) bool        { panic("not yet implemented") }
func (b *B) RunParallel(body func(*PB))                { panic("not yet implemented") }
func (b *B) SetBytes(n int64)                          { panic("not yet implemented") }
func (b *B) SetParallelism(p int)                      { panic("not yet implemented") }
func (b *B) Setenv(key, value string)                  { panic("not yet implemented") }
func (b *B) Skip(args ...interface{})                  { panic("not yet implemented") }
func (b *B) SkipNow()                                  { panic("not yet implemented") }
func (b *B) Skipf(format string, args ...interface{})  { panic("not yet implemented") }
func (b *B) Skipped() bool                             { panic("not yet implemented") }
func (b *B) StartTimer()                               { panic("not yet implemented") }
func (b *B) StopTimer()                                { panic("not yet implemented") }
func (b *B) TempDir() string                           { panic("not yet implemented") }

//----------------------------------------
// PB
// TODO: actually implement

type PB struct{}

func (pb *PB) Next() bool { panic("not yet implemented") }

type InternalTest struct {
	Name string
	F    testingFunc
}

func RunTest(verbose bool, test InternalTest) (ret string) {
	t := &T{name: test.Name, verbose: verbose}

	test.F(t)
	t.finished = true

	report := t.report()
	out, _ := json.Marshal(report)
	return string(out)
}
