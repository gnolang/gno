// Shim for Go's "testing" package to support minimal testing types.
package testing

import (
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
)

//----------------------------------------
// Top level functions

func Short() bool {
	return true // TODO configure somehow.
}

func Verbose() bool {
	return true // TODO configure somehow.
}

// Like AllocsPerRun() but returns an integer.
// TODO: actually compute allocations; for now return 0.
func AllocsPerRun2(runs int, f func()) (total int) {
	for i := 0; i < runs; i++ {
		f()
	}
	return 0
}

//----------------------------------------
// T

type T struct {
	name      string
	failed    bool
	finished  bool
	skipped   bool
	filtered  bool
	subs      []*T
	parent    *T
	output    []byte // Output generated by test
	verbose   bool
	runFilter filterMatch
}

func NewT(name string) *T {
	return &T{name: name}
}

type testingFunc func(*T)

// Not yet implemented:
// func (t *T) Cleanup(f func()) {
// func (t *T) Deadline() (deadline time.Time, ok bool)
func (t *T) Error(args ...interface{}) {
	t.Log(args...)
	t.Fail()
}

func (t *T) Errorf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.Fail()
}

func (t *T) Fail() {
	t.failed = true
	if t.parent != nil {
		fmt.Printf("--- FAIL  %s\n", t.name)
	}
}

func (t *T) FailNow() {
	// TODO: maybe use panic to control flow. because can't use goroutine in gno now.
	t.Fail()
	t.finished = true
}

func (t *T) Failed() bool {
	if t.failed {
		return true
	}
	for _, sub := range t.subs {
		if sub.Failed() {
			return true
		}
	}
	return false
}

func (t *T) Fatal(args ...interface{}) {
	t.Log(args...)
	t.FailNow()
}

func (t *T) Fatalf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.FailNow()
}

func (t *T) Log(args ...interface{}) {
	t.log(fmt.Sprintln(args...))
}

func (t *T) Logf(format string, args ...interface{}) {
	t.log(fmt.Sprintf(format, args...))
	t.log(fmt.Sprintln())
}

func (t *T) Name() string {
	return t.name
}

func (t *T) Parallel() {
	// does nothing.
}

func (t *T) Run(name string, f testingFunc) bool {
	fullName := t.name + "/" + rewrite(name)

	subT := &T{
		// parent:  t,
		name:      fullName,
		verbose:   t.verbose,
		runFilter: t.runFilter,
		parent:    t,
	}

	if t.subs == nil {
		t.subs = make([]*T, 0)
	}
	t.subs = append(t.subs, subT)

	tRunner(subT, f, true)
	return true
}

func (t *T) Setenv(key, value string) {
	panic("not yet implemented")
}

func (t *T) Skip(args ...interface{}) {
	t.Log(args...)
	t.SkipNow()
}

func (t *T) SkipNow() {
	panic("not yet implemented")
}

func (t *T) Skipped() bool {
	return t.skipped
}

func (t *T) Skipf(format string, args ...interface{}) {
	t.Logf(format, args...)
	t.SkipNow()
}

func (t *T) TempDir() string {
	panic("not yet implemented")
}

func (t *T) Helper() {
}

func (t *T) log(s string) {
	t.output = append(t.output, s...)
}

type Report struct {
	Name     string
	Verbose  bool
	Failed   bool
	Skipped  bool
	Filtered bool
	Output   string
	HasSubs  bool
}

func (t *T) report() Report {
	return Report{
		Name:     t.name,
		Verbose:  t.verbose,
		Failed:   t.Failed(),
		Skipped:  t.Skipped(),
		Filtered: t.filtered,
		Output:   strings.TrimSpace(t.Output()),
		HasSubs:  len(t.subs) > 0,
	}
}

func (t *T) Output() string {
	output := strings.TrimSpace(string(t.output))
	for _, sub := range t.subs {
		subOutput := sub.Output()
		if subOutput != "" {
			output += "\n\n" + subOutput
		}
	}
	return strings.TrimSpace(output)
}

//----------------------------------------
// B
// TODO: actually implement

type B struct {
	N int
}

func (b *B) Cleanup(f func())                          { panic("not yet implemented") }
func (b *B) Error(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Errorf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Fail()                                     { panic("not yet implemented") }
func (b *B) FailNow()                                  { panic("not yet implemented") }
func (b *B) Failed() bool                              { panic("not yet implemented") }
func (b *B) Fatal(args ...interface{})                 { panic("not yet implemented") }
func (b *B) Fatalf(format string, args ...interface{}) { panic("not yet implemented") }
func (b *B) Helper()                                   { panic("not yet implemented") }
func (b *B) Log(args ...interface{})                   { panic("not yet implemented") }
func (b *B) Logf(format string, args ...interface{})   { panic("not yet implemented") }
func (b *B) Name() string                              { panic("not yet implemented") }
func (b *B) ReportAllocs()                             { panic("not yet implemented") }
func (b *B) ReportMetric(n float64, unit string)       { panic("not yet implemented") }
func (b *B) ResetTimer()                               { panic("not yet implemented") }
func (b *B) Run(name string, f func(b *B)) bool        { panic("not yet implemented") }
func (b *B) RunParallel(body func(*PB))                { panic("not yet implemented") }
func (b *B) SetBytes(n int64)                          { panic("not yet implemented") }
func (b *B) SetParallelism(p int)                      { panic("not yet implemented") }
func (b *B) Setenv(key, value string)                  { panic("not yet implemented") }
func (b *B) Skip(args ...interface{})                  { panic("not yet implemented") }
func (b *B) SkipNow()                                  { panic("not yet implemented") }
func (b *B) Skipf(format string, args ...interface{})  { panic("not yet implemented") }
func (b *B) Skipped() bool                             { panic("not yet implemented") }
func (b *B) StartTimer()                               { panic("not yet implemented") }
func (b *B) StopTimer()                                { panic("not yet implemented") }
func (b *B) TempDir() string                           { panic("not yet implemented") }

//----------------------------------------
// PB
// TODO: actually implement

type PB struct{}

func (pb *PB) Next() bool { panic("not yet implemented") }

type InternalTest struct {
	Name string
	F    testingFunc
}

func (t *T) shouldRun(name string) bool {
	if t.runFilter == nil {
		return true
	}

	elem := strings.Split(name, "/")
	ok, partial := t.runFilter.matches(elem, matchString)
	_ = partial // we don't care right now
	return ok
}

func RunTest(runFlag string, verbose bool, test InternalTest) (ret string) {
	t := &T{
		name:    test.Name,
		verbose: verbose,
	}

	if runFlag != "" {
		t.runFilter = splitRegexp(runFlag)
	}

	tRunner(t, test.F, false)

doReport:
	report := t.report()
	out, _ := json.Marshal(report)
	return string(out)
}

func tRunner(t *T, fn testingFunc, logSteps bool) {
	if !t.shouldRun(t.name) {
		t.filtered = true
		if logSteps {
			// fmt.Printf("--- FILT  %s\n", t.name)
		}
		return
	}

	defer func() {
		err := recover()
		if err != nil {
			t.Fail()
			fmt.Printf(fmt.Sprintf("%v", err))
		}
	}()

	if logSteps {
		fmt.Printf("=== RUN   %s\n", t.name)
	}
	fn(t)

	t.finished = true
}
